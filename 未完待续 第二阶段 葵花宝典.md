### 第二部 葵花宝典

学习网站：http://www.cnblogs.com/pssp/p/5948356.html

http://www.w3school.com.cn/css/css_pseudo_elements.asp

#### 第一章 MySQL 数据库

##### 1.1 数据库简介

（1）概念：数据库（DataBase，DB）：指长期保存在计算机的存储设备上，按照一定规则组织起来，可以被各种用户或应用共享的数据集合。

（2）数据库管理系统（DataBase Management System，DBMS）：指一种操作和管理数据库的大型软件，用于建立、使用和维护数据库，对数据库进行统一管理和控制，以保证数据库的安全性和完整性。用户通过数据库管理系统访问数据库中的数据。MySQL  SQL Server Oracle 

​	 数据库软件应该为**数据库管理系统**，数据库是通过数据库管理系统创建和操作的。

​	 数据库：存储、维护和管理数据的集合。

（3）MySQL安装和卸载步骤详见第二阶段第一章md教程。

##### 1.2 SQL语言

（1）概述： SQL：Structure Query Language（结构化查询语言），SQL被美国国家标准局（ANSI）确定为关系型数据库语言的美国标准，后来被国际化标准组织（ISO）采纳为关系数据库语言的国际标准，该语言主要是实现对数据库Create, Read, Update, and Delete 通常称为CRUD操作。

（2）SQL语句分类：

​     （A）DDL（Data Definition Language）:数据定义语言,用来定义数据库对象:库,表,列等。

​    （B）DML（Data Manipulation Language）:数据操作语言,用来定义数据库记录(数据)。

​    （C）DCL（Data Control Language）:数据控制语言，用来定义访问权限和安全级别。   

​    （D）DQL（Data Query Language）：数据查询语言，用来查询记录（数据）。

​     注意sql:语句以;结尾，有一些命令不用;在mysql中，字符串类型和日期类型都要用单引号括起来。空值：null

​      MySQL注释：（1）#开头 （2）--空格 开头

​      DDL和DML区别：前者是对表或者表的整体信息进行操作，后者是对表中的具体数据操作

（3）SQL语句：

（3.1）创建数据库

```
SQL> CREATE DATABASE mydb1;
SQL> CREATE DATABASE mydb2 character SET GBK;
SQL> CREATE DATABASE mydb3 character SET GBK COLLATE gbk_chinese_ci;
```

（3.3）修改

```
#把mydb2的字符集修改为utf8
SQL> ALTER DATABASE mydb2 character SET utf8;
#修改表的字符集为gbk
ALTER TABLE user CHARACTER SET gbk;
#修改job列，使其长度为60
ALTER TABLE employee MODIFY job varchar(60);
#表名改为user
RENAME TABLE employee TO user;
#列名name修改为username
ALTER TABLE user CHANGE name username varchar(100);

临时更改客户端和服务器结果集的编码 
Set character_set_client=gbk;
Set character_set_results=gbk;
或者
SET  NAMES  ‘gbk’;  // client  connection results

#修改操作：UPDATE
语法：UPDATE 表名 SET 列名1=列值1,列名2=列值2 ... WHERE 列名=值
#将姓名为’lisi'’的员工薪水修改为4000元,性别改为‘female’。
UPDATE emp SET salary=4000,gender='female' WHERE name='lisi';
```

（3.4）增加和删除

```
#删除数据库mydb3
SQL> DROP DATABASE mydb3;
#删除表student1
SQL> DROP TABLE student1;
#在表employee中增加一个image列
ALTER TABLE employee ADD image blob;
#删除image列,一次只能删一列
ALTER TABLE employee DROP image;

删除操作：DELETE:
语法：DELETE from 表名 【WHERE 列名=值】
删除表中名称为’zhangsan’的记录。
DELETE FROM emp WHERE name=‘zhangsan’;
使用truncate删除表中记录。(先把表删除，然后再创建空表)
TRUNCATE TABLE emp;
DELETE与Truncate比较：
	DELETE 删除表中的数据，表结构还在;删除后的数据使用日志可以找回。
	TRUNCATE 删除是把表直接DROP掉，然后再创建一个同样的新表。
	TRUNCATE 删除的数据不能找回。执行速度比DELETE快。
	
#插入操作：INSERT
#语法： INSERT INTO 表名（列名1，列名2 ...）VALUES(列值1，列值2...);
#注意：列名与列值的类型、个数、顺序要一一对应。
#插入的日期和字符一样，都使用单引号括起来。
#一次添加一条信息
INSERT INTO emp(id,name,gender,birthday,salary,entry_date,resume)
VALUES(1,'zhangsan','female','1990-5-10',10000,'2015-5-5-','goodgirl');
#一次添加多条数据
INSERT INTO emp(id,name,gender,birthday,salary,entry_date,resume)
VALUES  (4,'你好','male','1995-5-10',10000,'2015-5-5','good boy'),
		(5,'你好','male','1995-5-10',10000,'2015-5-5','good boy'),
	 	(6,'你好','male','1995-5-10',10000,'2015-5-5','good boy');

```

（3.5）切换数据库

```
SQL> USE mydb2;
```

（3.6）表格创建格式

```
SQL> CREATE TABLE Employees
(
   id INT NOT NULL,
   age INT NOT NULL,
   first VARCHAR(255),
   last VARCHAR(255)
);
```

##### 1.3 SQL查询语句

（1）基本查询

```
#查看当前数据库服务器中的所有数据库
SQL> SHOW DATABASES;
#显示当前数据库中的所有表
SHOW TABLES;
#查看数据库名为mydb2的全部信息
SQL> Show CREATE DATABASE mydb2;
#查看表的创建细节
SHOW CREATE TABLE user;
#没有选择数据 null，查看当前使用的数据库
SQL> Select database(); 
#查看数据库编码的具体信息
Show variables like ‘character%’;
```

（2）select查询基本语法

```
SELECT 列名 FROM 表名
 查询语句书写顺序：select – from- where- groupby- having- order by-limit
 查询语句执行顺序：from - where -group by -having - select - order by-limit   
```

（3）where条件查询:

​	  where条件查询，不能与聚合函数共用，where语句就可以用以下符号限定条件：=、!=、<>、<、<=、>、>=；   BETWEEN…AND;(有先后顺序之分)  IN(set);(是否在集合set内)   IS NULL;  AND OR NOT   +  -  *  /  %

```
#查询学号为S_1001，或者姓名为liSi的记录,*表示所有数据
SELECT * FROM stu WHERE sid ='S_1001' OR sname='liSi';
#查询学号在S1001，S1002，S_1003之中的记录
SELECT * FROM stu WHERE sid IN ('S_1001','S_1002','S_1003');
SELECT * FROM stu WHERE sid='S_1001' or sid='S_1002' or sid='S_1003';
#查询学号不是S1001，S1002，S_1003的记录
SELECT * FROM tab_student WHERE sid NOT IN('S1001','S1002','S_1003');
```

（3.1）模糊查询：模糊查询需要使用关键字LIKE

​	      通配符:  _ 任意一个字符          %：任意0~n个字符

​		如： '张%'  --->张三丰  张三  张无忌      '李_'  --->李四  李逵  李刚 

```
#查询姓名中第2个字符为“i”的学生记录
SELECT * FROM stu WHERE sname LIKE '_i%'; 
#查询姓名中包含“a”字符的学生记录
SELECT * FROM stu WHERE sname LIKE '%a%';
```

（3.2）字段控制查询

（3.2.1）去除重复记录

```
#sal列中的重复记录将只显示一次
SELECT DISTINCT sal FROM emp;
SELECT DISTINCT sal,com FROM emp;
```

（3.2.2）计算两列之和，给列名添加名字

```
SELECT *,sal+comm FROM emp;
#因为sal和comm两列的类型都是数值类型，所以可以做+运算。
#字符串的合并不能使用+ ,使用concat(ename,'____',job);
select *,concat(ename,'______',job) from emp;

#comm列有很多记录的值为NULL，因为任何东西与NULL相加结果还是NULL，所以结算结果可能会出现NULL。下面使用了把NULL转换成数值0的函数IFNULL：
SELECT *,sal+IFNULL(comm,0) FROM emp;

#在上面查询中出现列名为sal+IFNULL(comm,0)，现在给该列定义一个别名，为total：
SELECT *, sal+IFNULL(comm,0) AS total FROM emp;
#AS可以省略
```

（4）分组查询

​	  当需要分组查询时需要使用GROUP BY子句，凡和聚合函数同时出现的列名，则一定要写在group by 之后

```
#查询每个部门的部门编号和每个部门的工资和：
SELECT deptno, SUM(sal) FROM emp GROUP BY deptno;
```

（5）having语句

​	  查询工资总和大于9000的部门编号以及工资和

```
SELECT deptno, SUM(sal) FROM emp GROUP BY deptno HAVING SUM(sal) > 9000;
```

注：having与where的区别:

   	1.having是在分组后对数据进行过滤,where是在分组前对数据进行过滤             

​	2.having后面可以使用分组函数(统计函数)

​           where后面不可以使用分组函数。

​	   WHERE是对分组前记录的条件，如果某行记录没有满足WHERE子句的条件，那么这行记录不会参加分组；而HAVING是对分组后数据的约束。

（6）排序

​	  查询所有雇员，按月薪降序排序，如果月薪相同时，按编号升序排序

```
SELECT * FROM emp ORDER BY sal DESC,empno ASC; 
```

（7）limit语句:LIMIT用来限定查询结果的起始行，以及总行数。

```
#查询5行记录，起始行从0开始,注意，起始行从0开始，即第一行开始！
SELECT * FROM emp LIMIT 0, 5;
#查询10行记录，起始行从3开始
SELECT* FROM emp LIMIT 3, 10;
```

（8）聚合函数：可以和having语句连用，但不能与where同用

​		聚合函数是用来做纵向运算的函数：

​		l  COUNT()：统计指定列不为NULL的记录行数；

​		l  MAX()：计算指定列最大值，如果指定列是字符串类型，会使用字符串排序运算；

​		l  MIN()：计算指定列最小值，如果指定列是字符串类型，那么使用字符串排序运算；

​		l  SUM()：计算指定列的数值和，如果指定列类型不是数值类型，那么计算结果为0；

​		l  AVG()：计算指定列的平均值，如果指定列类型不是数值类型，那么计算结果为0；

```
# 统计月薪与佣金之和大于2500元的人数：
SELECT COUNT(*) AS cnt FROM emp WHERE sal+IFNULL(comm,0) > 2500;
# 查询所有雇员月薪+佣金和：
SELECT SUM(sal+IFNULL(comm,0))FROM emp;
#查询最高工资和最低工资
SELECT MAX(sal), MIN(sal) FROM emp;
```

##### 1.4 数据的完整性

（1）作用：保证用户输入的数据保存到数据库中是正确的。

（2）方法：在创建表时给表中添加约束

​	 常用约束：主键约束(primary key )          唯一约束(unique [key])

 非空约束(not null)       默认约束(default )      外键约束(foreign key)

自动增长(auto_increment)

（3）分类：实体完整性；域完整性；引用完整性:  学生表(学号 ,姓名)   成绩表( 学号,科目,成绩)

（3.1）实体完整性

​	     实体：即表中的一行(一条记录)代表一个实体（entity）

​	     实体完整性的作用：标识每一行数据不重复。

​	     约束类型：主键约束;唯一约束;自动增长列

（3.1.2）主键约束（primary key）

​		注：每个表中要有一个主键。

​		特点：数据唯一，且不能为null

（3.1.3）唯一约束(unique)

​		特点：数据不能重复。可以为null

（3.1.4）自动增长列(auto_increment)

​		sqlserver数据库 (identity)  oracle数据库( sequence)

​		给主键添加自动增长的数值，列只能是整数类型

```
# 主键约束(默认不能为null)
#第一种写法
CREATE TABLE student(
	stuNo INT PRIMARY KEY,
	stuName VARCHAR(20),
	address VARCHAR(50)
);
#第二种写法,可以写联合主键
CREATE TABLE student(
	stuNo INT ,
	stuName VARCHAR(20),
	address VARCHAR(50),
	PRIMARY KEY(stuNo,stuName)
);
#第三种写法，先创建表，然后再添加主键
CREATE TABLE student2(
	stuNo INT,
	stuName VARCHAR(20),
	address VARCHAR(50)
);
#添加主键
ALTER TABLE student2 ADD PRIMARY KEY(stuNo);


#唯一约束 （可以为空）
CREATE TABLE student3(
	stuNo INT PRIMARY KEY,
	stuName VARCHAR(20),
	address VARCHAR(50),
	identityCard VARCHAR(18) UNIQUE 
);


#自动增长
CREATE TABLE student4(
	id INT PRIMARY KEY AUTO_INCREMENT,
	NAME VARCHAR(10)
);

ALTER TABLE student4 AUTO_INCREMENT = 10;

INSERT INTO student4(NAME) VALUES('xxx'),('yyy'),('zzz');
SELECT * FROM student4;
DROP TABLE student4;
```

（3.2）域完整性

​	     域代表当前单元格

​	     域完整性的作用：限制此单元格的数据正确，不对照此列的其它单元格比较

​	     域完整性约束：数据类型约束、非空约束（not null）、默认值约束(default)  

​	     check约束（mysql不支持）check(sex='男'or  sex='女')

（3.2.1）数据类型约束

（3.2.1.1）数值类型：

 	int：整型，占4字节；              

​	double（M,D）：浮点型，8个字节，M表示长度，D表示小数位数，例如double(5,2)表示最多5位，其中必须有2位小数，即最大值为999.99；

​	DECIMAL(M,D)：如果M>D，为M+2否则为D+2，M最大值为65

（3.2.1.2）日期类型：

​	DATE：日期类型，占3个字节，格式为YYYY-MM-DD

​	TIME：时间类型，占3个字节，格式为  HH:MM:SS

​	YEAR：占1个字节，格式为YYYY

​	DATETIME：日期时间类型，占8个字节，格式为YYYY-MM-DD HH:MM:SS

（3.2.1.3）字符串类型：

 	char：0-255字符，固定长度字符串类型； char(10) ，'aaa'占10位

​         varchar：0-65535 字节，可变长度字符串类型； varchar(10)  'aaa'  占3位

​	注意：0-255字符，0-65535 字节后面单位是不一样的，一个字节，一个字符，且它们保存和检索的方式不同，是否尾部空格被保留方面也不同，故定义时，同一个文件中char(m);char(n);varchar(a);varchar(b);m+n必须小于等于255；而a+b必须小于等于65535/3-2；其中减去的2是两个varchar数据所必须保留的两个尾部空格所占字符大小。

​         text：0-65 535字节大，文本字符串类型；有字符编码，存储比较大的文本数据。

​         blob：0-65 535字节，二进制形式的长文本数据；可以存储图片、音频、视频

（3.2.2）非空约束：Name varchar(50) not null

（3.2.3）默认值约束：default

```
#非空约束
CREATE TABLE student7(
	id INT PRIMARY KEY,
	NAME VARCHAR(20) NOT NULL
)

#默认值约束
CREATE TABLE student8(
	id INT PRIMARY KEY,
	NAME VARCHAR(20) NOT NULL,
	sex CHAR(1) DEFAULT '男'
)

INSERT INTO student8(id,NAME) VALUES(20,'zhaoliu');
insert into student8(id,NAME,sex) values(1,'tom','女');
insert into student8(id,NAME,sex) values(2,'jerry',default);
```

（3.3）引用完整性

​	     外键约束：FOREIGN KEY 	

```
#外键约束
CREATE TABLE score(
	id INT PRIMARY KEY,
	score INT,
	sid INT,
	CONSTRAINT FOREIGN KEY(sid) REFERENCES student8(id)
)
CREATE TABLE score2(
	id INT PRIMARY KEY,
	score INT,
	sid INT REFERENCES student8(id)
)

第二种添加外键方式:fk_stu_score为约束名，可任意设置
ALTER TABLE score1 ADD CONSTRAINT fk_stu_score FOREIGN KEY(id) REFERENCES stu(sid);
```

##### 1.5 多表查询

（1）概念：多个表之间有关系，则关系靠多表约束（外键约束）来维护。

（2）关系分类：

（2.1）一对多关系：在多的一方创建一个字段，字段作为外键指向一的一方的主键.

（2.2）多对多关系：创建第三张表,中间表中至少两个字段，这两个字段分别作为外键指向各自一方的主键.

（2.3）一对一关系：唯一外键对应：假设一对一是一个一对多的关系，在多的一方创建一个外键指向一的一方的主键，将外键设置为unique和非空.

​	    主键对应：让一对一的双方的主键进行建立关系.

```
#一对多的实现
#创建分类表
CREATE TABLE category(
  cid VARCHAR(32) PRIMARY KEY ,
  cname VARCHAR(100)		#分类名称
);

# 商品表
CREATE TABLE `products` (
  `pid` VARCHAR(32) PRIMARY KEY  ,
  `name` VARCHAR(40) ,
  `price` DOUBLE 
);

#添加外键字段
ALTER TABLE products ADD COLUMN category_id VARCHAR(32);

#添加约束
ALTER TABLE products ADD CONSTRAINT product_fk FOREIGN KEY (category_id) REFERENCES category (cid);

#多对多的实现
#订单表
CREATE TABLE `orders`(
  `oid` VARCHAR(32) PRIMARY KEY ,
  `totalprice` DOUBLE 	#总计
);

# 订单项表
CREATE TABLE orderitem(
  oid VARCHAR(50),	#订单id
  pid VARCHAR(50)	#商品id
);
#联合主键（可省略）
ALTER TABLE `orderitem` ADD PRIMARY KEY (oid,pid);

# 订单表和订单项表的主外键关系
ALTER TABLE `orderitem` ADD CONSTRAINT orderitem_orders_fk FOREIGN KEY (oid) REFERENCES orders(oid);

# 商品表和订单项表的主外键关系
ALTER TABLE `orderitem` ADD CONSTRAINT orderitem_product_fk FOREIGN KEY (pid) REFERENCES products(pid);


#初始化数据
#给商品表初始化数据
INSERT INTO products(pid,NAME,price,category_id) VALUES('p001','联想',5000,'c001');
INSERT INTO products(pid,NAME,price,category_id) VALUES('p002','海尔',3000,'c001');
INSERT INTO products(pid,NAME,price,category_id) VALUES('p003','雷神',5000,'c001');
INSERT INTO products(pid,NAME,price,category_id) VALUES('p004','JACK JONES',800,'c002');
INSERT INTO products(pid,NAME,price,category_id) VALUES('p005','真维斯',200,'c002');
INSERT INTO products(pid,NAME,price,category_id) VALUES('p006','花花公子',440,'c002');
INSERT INTO products(pid,NAME,price,category_id) VALUES('p007','劲霸',2000,'c002');
INSERT INTO products(pid,NAME,price,category_id) VALUES('p008','香奈儿',800,'c003');
INSERT INTO products(pid,NAME,price,category_id) VALUES('p009','相宜本草',200,'c003');
INSERT INTO products(pid,NAME,price,category_id) VALUES('p010','梅明子',200,NULL);


#给分类表初始化数据
INSERT INTO category VALUES('c001','电器');
INSERT INTO category VALUES('c002','服饰');
INSERT INTO category VALUES('c003','化妆品');
INSERT INTO category VALUES('c004','书籍');
```



（3）查询语法：

（3.1）合并结果集：UNION 、 UNION ALL

​	     合并结果集就是把两个select语句的查询结果合并到一起，有两种方式:

```
UNION：去除重复记录，例如：SELECT* FROM t1 UNION SELECT * FROM t2；
UNION ALL：不去除重复记录，例如：SELECT * FROM t1 UNION ALL SELECT * FROM t2
注意：被合并的两个结果：列数、列类型必须相同。
```

（3.2）连接查询：就是求出多个表的乘积，例如t1连接t2，那么查询出的结果就是t1*t2，连接查询会产生笛卡尔积，假设集合A={a,b}，集合B={0,1,2}，则两个集合的笛卡尔积为{(a,0),(a,1),(a,2),(b,0),(b,1),(b,2)}。可以扩展到多个集合的情况。

​	（3.2.1）内连接 [INNER] JOIN  ON 

```
SELECT * FROM emp e INNER JOIN dept d ON e.deptno=d.deptno;
等价于通俗写的语句：
SELECT * FROM emp,dept WHERE emp.deptno=dept.deptno;
注：查询结果必须满足条件。
```

​	（3.2.2）外连接 OUTER JOIN ON

````
包括左外连接、右外连接和全外连接，注：查询出的结果存在不满足条件的可能。
````

​			左外连接 LEFT [OUTER] JOIN:左连接是先查询出左表（即以左表为主），然后查询右表，右表中满足条件的显示出来，不满足条件的显示NULL。例如：emp表中“张三”这条记录中，部门编号为50，而dept表中不存在部门编号为50的记录，所以“张三”这条记录，不能满足e.deptno=d.deptno这条件。但在左连接中，因为emp表是左表，所以左表中的记录都会查询出来，即“张三”这条记录也会查出，但相应的右表部分显示NULL。

```
SELECT * FROM emp e LEFT OUTER JOIN dept d ON e.deptno=d.deptno;
```

​			右外连接 RIGHT [OUTER] JOIN：右连接就是先把右表中所有记录都查询出来，然后左表满足条件的显示，不满足显示NULL。例如在dept表中的40部门并不存在员工，但在右连接中，如果dept表为右表，那么还是会查出40部门，但相应的员工信息为NULL。

```
SELECT * FROM emp e RIGHT OUTER JOIN dept d ON e.deptno=d.deptno;
```

​			全外连接（MySQL不支持）FULL JOIN

 	 （3.2.3）自然连接 NATURAL JOIN

  注（所有连接综述）：连接不限与两张表，连接查询也可以是三张、四张，甚至N张表的连接查询。通常连接查询不可能需要整个笛卡尔积，而只是需要其中一部分，那么这时就需要使用条件来去除不需要的记录。这个条件大多数情况下都是使用主外键关系去除。两张表的连接查询一定有一个主外键关系，三张表的连接查询就一定有两个主外键关系，所以在大家不是很熟悉连接查询时，首先要学会去除无用笛卡尔积，那么就是用主外键关系作为条件来处理。如果两张表的查询，那么至少有一个主外键条件，三张表连接至少有两个主外键条件。

（3.3）子查询

（3.3.1）概念：一个select语句中包含另一个完整的select语句，子查询就是嵌套查询，即SELECT中包含SELECT，如果一条语句中存在两个，或两个以上SELECT，那么就是子查询语句了。

l  子查询出现的位置：

​	a. where后，作为条为被查询的一条件的一部分；

​	b. from后，作表；

l  当子查询出现在where后作为条件时，还可以使用如下关键字：

​	a. any

​	b. all

l  子查询结果集的形式：

​	a. 单行单列（用于条件）

​	b. 单行多列（用于条件）

​	c. 多行单列（用于条件）

​	d. 多行多列（用于表）

（3.3.2）语法示例：

  工资高于JONES的员工(JONES工资需要一条子查询)

```
SELECT * FROM emp WHERE sal > (SELECT sal FROM emp WHERE ename='JONES');
```

  查询与SCOTT同一个部门的员工。( 子查询作为条件,子查询形式为单行单列)

```
SELECT * FROM emp WHERE deptno = (SELECT deptno FROM emp WHERE ename='SCOTT');
```

工资高于30号部门所有人的员工信息(高于所有需要使用all关键字)

```
SELECT * FROM emp WHERE sal > ALL (SELECT sal FROM emp WHERE deptno=30)
```

#### 第二章 JDBC

##### 2.1 JDBC简介

（1）基础知识

​	  JDBC（Java DataBase Connectivity,java数据库连接）是一种用于执行SQL语句的Java API，可以为多种关系数据库提供统一访问，它由一组用Java语言编写的类和接口组成。JDBC提供了一种基准，据此可以构建更高级的工具和接口，使数据库开发人员能够编写数据库应用程序。

​	  JDBC可以在各种平台上使用Java，如Windows，Mac OS和各种版本的UNIX。

JDBC库包括通常与数据库使用相关的下面提到的每个任务的API。

- 连接数据库。
- 创建SQL或MySQL语句。
- 在数据库中执行SQL或MySQL查询。
- 查看和修改生成的记录。

（2）JDBC体系结构

​	  JDBC API支持用于数据库访问的两层和三层处理模型，但通常，JDBC体系结构由两层组成：A. JDBC API：提供了应用程序到JDBC管理器连接 ，JDBC API使用驱动程序管理器和特定于数据库的驱动程序来提供与异构数据库的透明连接。 B. JDBC驱动程序API：支持JDBC管理器到驱动程序连接

（3）JDBC核心组件

（3.1）DriverManager:此类管理数据库驱动程序列表。使用通信子协议将来自java应用程序的连接请求与适当的数据库驱动程序匹配。

（3.2）Driver:此接口处理与数据库服务器的通信，我们很少会直接与Driver对象进行交互。而是使用DriverManager对象来管理这种类型的对象。

（3.3）Connection:该接口具有用于联系数据库的所有方法。连接对象表示通信上下文，即，与数据库的所有通信仅通过连接对象。

（3.4）Statement:使用从此接口创建的对象将SQL语句提交到数据库。除了执行存储过程之外，一些派生接口还接受参数。

（3.5）ResultSet:在使用Statement对象执行SQL查询后，这些对象保存从数据库检索的数据。它作为一个迭代器，允许我们移动其数据。

（3.6）SQLException:此类处理数据库应用程序中发生的任何错误

##### 2.2  JDBC的使用

（1）使用步骤：

（1.1）导入JDBC驱动包：下载包含数据库编程所需的JDBC的jar包，在项目下创建lib目录，把该jdbc jar包放入此目录中并添加到build path中。

（1.2）注册JDBC驱动程序：要求您初始化驱动程序，以便您可以打开与数据库的通信通道。共两种注册方式，第一种方式（推荐写法）：Class.forName()，第二种方式：是使用静态DriverManager.registerDriver（）方法，第二种方式存在以下两个弊端：1>驱动程序注册两次2>java程序依赖mysql驱动包

（1.3）打开连接：需要使用*DriverManager.getConnection（）*方法创建一个Connection对象，该对象表示与数据库的物理连接，具体分为以下两步实现：

 	  （1.3.1）数据库URL配置加载驱动程序后，可以使用**DriverManager.getConnection（）**方法建立连接。为了方便参考，让我列出三个重载的DriverManager.getConnection()方法 -

- getConnection（String url）
- getConnection（String url，Properties prop）
- getConnection（String url，String user，String password）

| RDBMS  | JDBC驱动程序名称                      | 网址格式                                     |
| ------ | ------------------------------- | ---------------------------------------- |
| MySQL  | com.mysql.jdbc.Driver           | **jdbc：mysql：//**hostname:3306 / databaseName |
| ORACLE | oracle.jdbc.driver.OracleDriver | **jdbc：oracle：thin：@** hostname：port Number：databaseName |
| DB2    | COM.ibm.db2.jdbc.net.DB2Driver  | **jdbc：db2：**hostname：port Number / databaseName |
| SYBASE | com.sybase.jdbc.SybDriver       | **jdbc：sybase：Tds：** hostname：port Number / databaseName |

​	  （1.3.2）创建数据库连接对象

```
String URL = "jdbc:mysql://localhost:3306/EMP";
String USER = "root";
String PASS = "root"
Connection conn = DriverManager.getConnection(URL, USER, PASS);
```

（1.4）执行查询：一旦获得了连接，我们可以与数据库进行交互。JDBC Statement和PreparedStatement接口定义了使您能够发送SQL命令并从数据库接收数据的方法和属性。

| 接口                      | 使用                                       |
| ----------------------- | ---------------------------------------- |
| Statement               | 用于对数据库进行通用访问。在运行时使用静态SQL语句时很有用。Statement接口不能接受参数。 |
| PreparedStatement(推荐使用) | 当您计划多次使用SQL语句时使用。PreparedStatement接口在运行时接受输入参数。 |

（1.4.1）Statement：创建语句对象，在使用Statement对象执行SQL语句之前，需要使用Connection对象的createStatement（）方法创建一个，如下例所示：

​			Statement stmt = conn.createStatement( );

​	创建Statement对象后，可以使用它来执行一个SQL语句，其中有三个执行方法之一。

- **boolean execute（String SQL）**：如果可以检索到ResultSet对象，则返回一个布尔值true; 否则返回false。使用此方法执行SQL DDL语句或需要使用真正的动态SQL时。

- **int executeUpdate（String SQL）**：返回受SQL语句执行影响的行数。使用此方法执行预期会影响多个行的SQL语句，例如INSERT，UPDATE或DELETE语句。

- **ResultSet executeQuery（String SQL）**：返回一个ResultSet对象。当您希望获得结果集时，请使用此方法，就像使用SELECT语句一样。

  ​	关闭Statement对象：就像我们关闭一个Connection对象以保存数据库资源一样，由于同样的原因，还应该关闭Statement对象。一个简单的调用close（）方法将执行该作业。如果先关闭Connection对象，它也会关闭Statement对象。但是，应始终显式关闭Statement对象，以确保正确清理。 stmt.close();

  ​	ResultSet：SELECT语句是从数据库中选择行并在结果集中查看行的标准方法。该*java.sql.ResultSet中的*接口表示结果集数据库查询。ResultSet对象维护指向结果集中当前行的游标。术语“结果集”是指包含在ResultSet对象中的行和列数据。如果没有指定任何ResultSet类型，您将自动获得一个TYPE_FORWARD_ONLY。

| 类型                                | 描述                                      |
| --------------------------------- | --------------------------------------- |
| ResultSet.TYPE_FORWARD_ONLY       | 光标只能在结果集中向前移动。                          |
| ResultSet.TYPE_SCROLL_INSENSITIVE | 光标可以向前和向后滚动，结果集对创建结果集后发生的数据库的其他更改不敏感。   |
| ResultSet.TYPE_SCROLL_SENSITIVE。  | 光标可以向前和向后滚动，结果集对创建结果集之后发生的其他数据库所做的更改敏感。 |

（1.4.2）PreparedStatement

​	（1.4.2.1）SQL注入：就是通过把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。具体来说，它是利用现有应用程序，将（恶意的）SQL命令注入到后台数据库引擎执行的能力，它可以通过在Web表单中输入（恶意）SQL语句得到一个存在安全漏洞的网站上的数据库，而不是按照设计者意图去执行SQL语句。比如先前的很多影视网站泄露VIP会员密码大多就是通过WEB表单递交查询字符暴出的，这类表单特别容易受到SQL注入式攻击。

````
/**
*SQL注入演示
*/
public class JdbcDemo2 {
	public static void main(String[] args) {
		Connection connection=null;
		try {
			Class.forName("com.mysql.jdbc.Driver");
			//2获取连接			connection=DriverManager.getConnection("jdbc:mysql://localhost:3306/school", "root", "root");
	
	/***************************
    /*Statement登录,当输入特殊符号命令时会造成全部数据的查询泄露，即SQL注入*/
			//3创建命令
		    Statement  stat1=connection.createStatement();
			//4执行命命令  select * from user where username='zhangsan' and password='123456';
			 ResultSet rs1=stat.executeQuery("select * from user where username='"+username+"' and password='"+pass+"'");
			if(rs.next()){ //有数据
				System.out.println("登录成功");
			}else{
				System.out.println("账号或密码错误");
			}
  							  ********************************/
  
  /*PreparedStatement登录，?表示占位符，执行时?会替换为实际数据，预编译（1）安全，可防注入（2）效率高 */
            //3创建命令  
PreparedStatement	pstat=connection.prepareStatement("select * from user where username=? and password=?");
			//4给pstat设置参数
			pstat.setString(1, "zhangsan");
			pstat.setString(2, "123456");
			//5执行
		    ResultSet rs=pstat.executeQuery();
			if(rs.next()){
				System.out.println("登录成功");
			}else{
				System.out.println("登录失败");
			}
			
		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}finally {
			if(rs!=null){
				try {
					rs.close();
				} catch (SQLException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
			}
			if(pstat!=null){
				try {
					pstat.close();
				} catch (SQLException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
			}
			if(connection!=null){
				try {
					connection.close();
				} catch (SQLException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
			}
		}
	}
}
````

​	（1.4.2.2）PreparedStatement可以很好的解决SQL注入这一问题，*PreparedStatement的*接口扩展了Statement接口，它为您提供了一个通用的Statement对象，它可以动态地提供参数(无需使用create函数创建任务对象连接，即Statement stmt = conn.createStatement( );这一语句在PreparedStatement中不用写)：

```
 String SQL = "Update Employees SET age = ? WHERE id = ?";
 PreparedStatement pstmt=conn.prepareStatement(SQL);
 注：JDBC中的所有参数都由？符号，这被称为参数标记。在执行SQL语句之前，必须为每个参数提供值。
 	在后面的PreparedStatement对象使用中会涉及到setXXX（）方法将值绑定到所述参数，其中XXX代表要绑定到输入参数的值的Java数据类型。如果忘记提供值，将收到一个SQLException。
 	在后面的PreparedStatement对象使用中也会用到参数标记，每个参数标记由其顺序位置引用。第一个标记表示位置1，下一个位置2等等。该方法与Java数组索引不同，从0开始。
```

​	关闭PreparedStatement对象：pstmt.close();

​	（1.4.2.3）PreparedStatement对象有两个明显的优点是：可以动态地提供参数；可以使用输入和输出流来提供参数数据。

（1.5）从结果集中提取数据：需要使用相应的*ResultSet.getXXX（）*方法从结果集中检索数据。

（1.6）关闭数据库连接,释放资源：需要明确地关闭所有数据库资源，而不依赖于JVM的垃圾收集。为确保连接关闭，您可以在代码中提供一个“finally”块。finally块总是执行，不管是否发生异常。要关闭上面打开的连接，你应该调用close（）方法如下 -conn.close();

```
/*
 * 使用JDBC连接数据库，并执行命令
 * 1 导入驱动包
 * 2 注册驱动
 */
public class JdbcDemo2 {
	public static void main(String[] args) {
		Connection connection=null;
		Statement stat=null;
		ResultSet rs=null;
		try {
			//2注册驱动
			//第一种注册方式，将驱动程序的类文件动态加载到内存中，并将其自动注册
			Class.forName("com.mysql.jdbc.Driver");
			//第二种方式，使用静态DriverManager.registerDriver（）方法
			//DriverManager.registerDriver(new Driver());
			//3获取连接
			//url 连接字符串  jdbc:mysql://localhost:3306/school root root
connection=DriverManager.getConnection("jdbc:mysql://localhost:3306/school", "root", "root");			
			//4创建命令（语句）对象
			stat=connection.createStatement();
			
			//执行命令查询
			rs=stat.executeQuery("select ename,empno from emp");
			//5处理结果
			while(rs.next()){
//				 int empno=rs.getInt(1);
//				 String empname=rs.getString(2);
				 int empno=rs.getInt("empno");
				 String empname=rs.getString("ename");
				 System.out.println(empno+"...."+empname);
			}
			
	/*		//附加：执行命令添加(更新，删除，添加程序一样，只需更改sql语句即可)
			int result=stat.executeUpdate("insert into dept(deptno,dname,loc) values(80,'市场部','天津')");
			//5处理结果
			if(result>0){
				System.out.println("添加成功");
			}else{
				System.out.println("添加失败");
			}                               */                                                                 
			
		
		} catch (Exception e) {
			e.printStackTrace();
		}finally { //6关闭数据库连接
			if(rs!=null){
				try {
					rs.close();
				} catch (SQLException e) {
					e.printStackTrace();
				}
			}
			if(stat!=null){
				try {
					stat.close();
				} catch (SQLException e) {
					e.printStackTrace();
				}
			}
			if(connection!=null){
				try {
					connection.close();
				} catch (SQLException e) {
					e.printStackTrace();
				}
			}
		}
	}
}
```

##### 2.3 JDBC批处理和事务

（1）概念:批量处理允许您将相关的SQL语句分组到批处理中，并通过对数据库的一次调用提交它们。当您一次向数据库发送多个SQL语句时，可以减少连接数据库的开销，从而提高性能。

（2）Statement批处理

以下是使用语句对象的批处理的典型步骤序列

- 使用*createStatement（）*方法创建Statement对象。
- 使用*setAutoCommit（）*将auto-commit设置为false ，即关闭JDBC自动提交模式。如果JDBC连接处于自动提交模式，默认情况下，则每个SQL语句在完成后都会提交到数据库。事务使您能够控制是否和何时更改应用于数据库。它将单个SQL语句或一组SQL语句视为一个逻辑单元，如果任何语句失败，则整个事务将失败。要启用手动事务支持，而不是JDBC驱动程序默认使用的*自动提交*模式，请使用Connection对象的**setAutoCommit（）**方法。如果将boolean false传递给setAutoCommit（），则关闭自动提交。我们可以传递一个布尔值true来重新打开它。
- 使用*addBatch（）*方法在创建的语句对象上添加您喜欢的SQL语句到批处理中。
- 在创建的语句对象上使用*executeBatch（）*方法执行所有SQL语句。
- 清空批处理等待下一次批处理。
- 最后，使用*commit（）*方法提交所有更改（conn.commit( );）。否则，要使用数据库回滚更新（conn.rollback( );），当事务执行过程中出错时，程序会自动调用回滚更新方法conn.rollback( );，回滚更新会撤销事务执行过程中的所有更改。

```
/**
 * 向用户表添加100条数据，使用Statement批处理完成(部分程序段)
 */
		Statement stat=connection.createStatement();
			//4.1设置事务不自动提交
			//缺点： 1 每次都要添加sql语句  2 不能避免SQL注入 
			connection.setAutoCommit(false);
			for(int i=1;i<=100;i++){
/*stat.executeUpdate("insert into user(username,password,phone) values('zhangsan"+i+"','123456','18944123132')");*/
		stat.addBatch("insert into user(username,password,phone) values('王五"+i+"','123456','18944123132')");
				if(i%50==0){
					//任务批处理并接收执行情况
					int[] result=stat.executeBatch();
					System.out.println(result.length);
					//清空批处理
					stat.clearBatch();
				}
			}
			//4.2提交
			connection.commit();
```

（3）PrepareStatement批处理

以下是使用语句对象的批处理的典型步骤序列

- 使用占位符创建SQL语句。
- 使用*prepareStatement（）* 方法创建PrepareStatement对象。
- 使用*setAutoCommit（）*将auto-commit设置为false 。
- 使用*addBatch（）*方法在创建的语句对象上添加您喜欢的SQL语句到批处理中。
- 在创建的语句对象上使用*executeBatch（）*方法执行所有SQL语句。
- 清空批处理等待下一次批处理。
- 最后，使用*commit（）*方法提交所有更改。

```
/*
 * 使用PreparedStatement  实现批处理(部分程序)
 */
			//3创建命令对象  ?占位符  ，执行时会输入实际数据
	PreparedStatement pstat=connection.prepareStatement("insert into user(username,password,phone) values(?,?,?)");	
			connection.setAutoCommit(false);
	/*setXXX（）方法将值绑定到所述参数，其中XXX代表要绑定到输入参数的值的Java数据类型。如果忘记提供值，将收到一个SQLException。
 	每个参数标记由其顺序位置引用。第一个标记表示位置1，下一个位置2等等。该方法与Java数组索引不同，从0开始。*/
			for(int i=1;i<=100;i++){
				pstat.setString(1, "王五"+i);
				pstat.setString(2, "6666");
				pstat.setString(3, "18988889999");
				
				//放入到批处理
				pstat.addBatch();
				if(i%50==0){
					//执行批处理
					int[] rs=pstat.executeBatch();
					System.out.println(rs.length);
					//清空批处理
					pstat.clearBatch();
				}
			}		
			//4.2提交
			connection.commit();
```

##### 2.4 JDBC操作二进制

（1）概念：PreparedStatement对象可以使用输入和输出流来提供参数数据。这使您可以将整个文件放入可以保存大值的数据库列，例如Text和BLOB数据类型。

有以下方法可用于流式传输数据 -

- **setAsciiStream（）：**此方法用于提供大的ASCII值。
- **setCharacterStream（）：**此方法用于提供大型UNICODE值。
- **setBinaryStream（）：**此方法用于提供较大的二进制值。

setXXXStream（）方法除了参数占位符之外还需要额外的参数，文件大小。

考虑我们要将XML文件XML_Data.xml上传到数据库表中。

```
这是XML文件的内容 -
<?xml version="1.0" encoding="UTF-8"?>
<Employee>
  <id>100</id>
  <first>张</first>
  <last>三</last>
  <Salary>10000</Salary>
  <Dob>18-08-1978</Dob>
</Employee>
/**
*将XML文件上传到数据库表中
*/
public class JdbcDemo3 {
	public static void main(String[] args) {
		Connection connection=null;
		PreparedStatement pstat=null;
		PreparedStatement pstat2=null;
		PreparedStatement pstat3=null;
		ResultSet rs=null;
		//1注册驱动
		try {
			Class.forName("com.mysql.jdbc.Driver");
			//2获取连接			connection=DriverManager.getConnection("jdbc:mysql://localhost:3306/school", "root", "root");
			//3创建命令对象
			String sql1="drop table if exists xmltable;";
			String sql2="create table xmltable (id int primary key,data text);";
			pstat=connection.prepareStatement(sql1);
			//删除表
			boolean b=pstat.execute();
			//创建表
			boolean b2=pstat.execute(sql2);
			System.out.println("创建表成功");
			
			//4添加数据
			pstat2=connection.prepareStatement("insert into xmltable(id,data) values(?,?)");
			File file=new File("src\\emp.xml");
			FileInputStream fis=new FileInputStream(file);
			pstat2.setInt(1, 10);
			pstat2.setAsciiStream(2, fis, file.length());
			//pstat2.setBinaryStream(2, fis, file.length());
			//pstat2.setCharacterStream(2,new InputStreamReader(fis),file.length());
			int r=pstat2.executeUpdate();
			if(r>0){
				System.out.println("添加成功");
			}
			
			//5读取数据
			pstat3=connection.prepareStatement("select * from xmltable where id=10;");
			rs=pstat3.executeQuery();
			if(rs.next()){
				int id=rs.getInt("id");
				System.out.println(id);
				InputStream is=rs.getAsciiStream("data");
				//读取流
				ByteArrayOutputStream baos=new ByteArrayOutputStream();
				byte[] buf=new byte[1024];
				int len=0;
				while((len=is.read(buf))!=-1){
					baos.write(buf, 0, len);
				}
				System.out.println(baos.toString());
				is.close();
			}
			
			
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if(rs!=null){
				try {
					rs.close();
				} catch (SQLException e) {
					e.printStackTrace();
				}
			}
			if(pstat!=null){
				try {
					pstat.close();
				} catch (SQLException e) {
					e.printStackTrace();
				}
			}
			if(pstat2!=null){
				try {
					pstat2.close();
				} catch (SQLException e) {
					e.printStackTrace();
				}
			}
			
			if(connection!=null){
				try {
					connection.close();
				} catch (SQLException e) {
					e.printStackTrace();
				}
			}
		}	
	}
}
```

##### 2.5 数据库事务

（1）事物的概念：数据库事务(Database Transaction) ，是指作为单个逻辑工作单元执行的一系列操作，要么完全地执行，要么完全地不执行。通俗的说就是：一组要么同时执行成功，要么同时执行失败的SQL语句。是数据库操作的一个执行单元。 事务处理可以确保除非事务性单元内的所有操作都成功完成，否则不会永久更新面向数据的资源。通过将一组相关操作组合为一个要么全部成功要么全部失败的单元，可以简化错误恢复并使应用程序更加可靠。一个逻辑工作单元要成为事务，必须满足所谓的ACID（原子性、一致性、隔离性和持久性）属性。事务是数据库运行中的逻辑工作单位，由DBMS中的事务管理子系统负责事务的处理。

（2）事物的生命周期：事务开始于A.连接到数据库上，并执行一条DML语句insert、update或delete。B.前一个事务结束后，又输入了另一条DML语句；事务结束于A.执行commit或rollback语句。B.执行一条DDL语句，例如create table语句，在这种情况下，会自动执行commit语句。C.执行一条DDL语句，例如grant语句，在这种情况下，会自动执行commit。D.断开与数据库的连接。E.执行了一条DML语句，该语句却失败了，在这种情况中，会为这个无效的DML语句执行rollback语句。

（3）事务的四大特点：ACID

（3.1）Actomicity(原子性)：表示一个事务内的所有操作是一个整体，要么全部成功，要么全部失败

（3.2）Consistency(一致性)：表示一个事务内有一个操作失败时，所有的更改过的数据都必须回滚到修改前状态

（3.3）Isolation(隔离性)：事务查看数据时数据所处的状态，要么是另一并发事务修改它之前的状态，要么是另一事务修改它之后的状态，事务不会查看中间状态的数据。

（3.4）Durability(持久性)：持久性事务完成之后，它对于系统的影响是永久性的。

```
/*
 * 事务四个特性
 * 1 原子性 A
 * 2 一致性 C
 * 3 隔离性 I   事务与事务之间
 * 4 持久性 D
 */
CREATE TABLE account(
	id INT PRIMARY KEY,
	NAME VARCHAR(20) NOT NULL,
	money DOUBLE(10,2)
)

public class JdbcDemo4 {
	public static void main(String[] args) {
		Connection connection=null;
		PreparedStatement pstat1=null;
		PreparedStatement pstat2=null;
		
		//1注册驱动
		try {
			Class.forName("com.mysql.jdbc.Driver");
			//2获取连接	connection=DriverManager.getConnection("jdbc:mysql://localhost:3306/school", "root", "root");
			//3创建命令
			//3.1开启事务 ，设置事务自动提交为false
			connection.setAutoCommit(false);
			pstat1=connection.prepareStatement("update account set money=money-1000 where name='张莎强'");
			pstat1.executeUpdate();
			//当执行下一条语句int c=10/0;时，会自动执行回滚语句
			//int c=10/0;
			pstat2=connection.prepareStatement("update account set money=money+1000 where name='小苍'");
			pstat2.executeUpdate();
			
			System.out.println("转账成功...");
			//3.2提交事务
			connection.commit();
			
		} catch (Exception e) {
			System.out.println("出现异常");
			try {
				connection.rollback();//出现问题，要回滚(撤销事务做过的修改)
				connection.commit();//可加也不不加
			} catch (SQLException e1) {
				e1.printStackTrace();
			}
		}finally {
			if(pstat1!=null){
				try {
					pstat1.close();
				} catch (SQLException e) {
					e.printStackTrace();
				}
			}
			if(pstat2!=null){
				try {
					pstat2.close();
				} catch (SQLException e) {
					e.printStackTrace();
				}
			}
			if(connection!=null){
				try {
					connection.close();
				} catch (SQLException e) {
					e.printStackTrace();
				}
			}
		}
	}
}

```

（3）事务的隔离级别：

​	SQL标准定义了4类隔离级别，包括了一些具体规则，用来限定事务内外的哪些改变是可见的，哪些是不可见的。低级别的隔离级一般支持更高的并发处理，并拥有更低的系统开销。

**Read Uncommitted**（读取未提交内容)

​       在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少。读取未提交的数据，也被称之为脏读（Dirty Read）。

```
	脏读(Drity Read)带来的问题：某个事务已更新一份数据，另一个事务在此时读取了同一份数据，由于某些原因，前一个RollBack了操作，则后一个事务所读取的数据就会是不正确的。
	以下案例中，当张三执行了stat1.executeUpdate("update account set money=money-1000 where name='张三'");语句时，由于李四隔离级别设置是可以读取未提交内容，所以此时虽然张三还没有提交事务，但李四已经读到，于是就会认为张三已经打款，便立刻发货，但张三接下来执行int a=10/0;程序就会报错进行回滚撤销事务改变，打款也就不存在的，李四结果是钱财两空。
 /*
 * 隔离级别的演示
 * 1 脏读（脏读的演示需要设置断点） 
 * 张三
 */
public class JdbcDemo5 {
	public static void main(String[] args) {
		Connection connection=null;
		Statement stat1=null;
		Savepoint savepoint=null;//保存点
		//1注册驱动
		try {
			Class.forName("com.mysql.jdbc.Driver");
			//2获取连接		connection=DriverManager.getConnection("jdbc:mysql://localhost:3306/school", "root", "root");
			//2.1开启事务
			connection.setAutoCommit(false);
			savepoint=connection.setSavepoint("save1");
			//3创建命令
			stat1=connection.createStatement();
			//4执行
			stat1.executeUpdate("update account set money=money-1000 where name='张三'");
		
			int a=10/0;
			stat1.executeUpdate("update account set money=money+1000 where name='李四'");
			connection.commit();
		} catch (Exception e) {
			try {
				connection.rollback(savepoint);
				connection.commit();
			} catch (SQLException e1) {
				e1.printStackTrace();
			}
		}finally {
			if(stat1!=null){
				try {
					stat1.close();
				} catch (SQLException e) {
					e.printStackTrace();
				}
			}
			if(connection!=null){
				try {
					connection.close();
				} catch (SQLException e) {
					e.printStackTrace();
				}
			}
		}
	}
}

/*
 * 隔离级别的演示
 * 1 脏读 
 * 李四
 */
public class JdbcDemo6 {
	public static void main(String[] args) {
		Connection connection=null;
		Statement stat1=null;
		ResultSet rs=null;
		//1注册驱动
		try {
			Class.forName("com.mysql.jdbc.Driver");
			//2获取连接
			connection=DriverManager.getConnection("jdbc:mysql://localhost:3306/school", "root", "root");
			//2.1开启事务
			connection.setAutoCommit(false);
			//2.2修改隔离级别(读未提交的)
			connection.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);
			//3创建命令
			stat1=connection.createStatement();
			//4执行
			rs=stat1.executeQuery("select * from account where name='李四'");
			
			if(rs.next()){
				double money=rs.getDouble("money");
				System.out.println("余额是:"+money);
			}
			
			connection.commit();
		} catch (Exception e) {
			try {
				connection.rollback();
			} catch (SQLException e1) {
				e1.printStackTrace();
			}
			
		}finally {
			if(stat1!=null){
				try {
					stat1.close();
				} catch (SQLException e) {
					e.printStackTrace();
				}
			}
			if(connection!=null){
				try {
					connection.close();
				} catch (SQLException e) {
					e.printStackTrace();
				}
			}
		}
	}
}
```

**Read Committed**（读取提交内容）

​       这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。这种隔离级别
也支持所谓的不可重复读（Nonrepeatable Read），因为同一事务的其他实例在该实例处理其间可能会有新的commit，所以同一select可能返回不同结果。

​	不可重复读(Non-repeatable read):在一个事务的两次查询之中数据不一致，这可能是两次查询过程中间插入了一个事务更新的原有的数据。

**Repeatable Read **可重读

​       这是MySQL的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。不过理论上，这会导致另一个棘手的问题：幻读（Phantom Read）。简单的说，幻读指当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行。InnoDB和Falcon存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control）机制解决了该问题。

​	 幻读(Phantom Read):在一个事务的两次查询中数据笔数不一致，例如有一个事务查询了几列(Row)数据，而另一个事务却在此时插入了新的几列数据，先前的事务在接下来的查询中，就会发现有几列数据是它先前所没有的。

**Serializable** 可串行化
​       这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争。

​       这四种隔离级别采取不同的锁类型来实现，若读取的是同一个数据的话，就容易发生问题。

（4）  Savepoints

​	设置保存点时，可以在事务中定义逻辑回滚点。如果通过保存点发生错误，则可以使用回滚方法来撤消所有更改或仅保存在保存点之后所做的更改。

​	Connection对象有两种新的方法来帮助您管理保存点：

- **setSavepoint（String savepointName）：**定义新的保存点。它还返回一个Savepoint对象。
- **releaseSavepoint（Savepoint savepointName）：**删除保存点。请注意，它需要一个Savepoint对象作为参数。此对象通常是由setSavepoint（）方法生成的保存点。

```
public static void main(String[] args) {
		Connection conn = null;
		Statement stmt = null;
		Savepoint savepoint1 = null;
		try {
			Class.forName("com.mysql.jdbc.Driver");
			conn = DriverManager.getConnection("jdbc:mysql://localhost:3306/school", "root", "root");
			// Assume a valid connection object conn
			conn.setAutoCommit(false);
			stmt = conn.createStatement();

			// set a Savepoint
			String SQL = "INSERT INTO Employees " + "VALUES (106, 20, 'Rita', 'Tez');";
			stmt.executeUpdate(SQL);
			savepoint1 = conn.setSavepoint("Savepoint1");
			// Submit a malformed SQL statement that breaks
			SQL = "INSERT IN Employees " + "VALUES (107, 22, 'Sita', 'Tez')";
			stmt.executeUpdate(SQL);
			// If there is no error, commit the changes.
			conn.commit();
			System.out.println("执行成功");

		} catch (Exception se) {
			// If there is any error.
			try {
				se.printStackTrace();
				conn.rollback(savepoint1);
				conn.commit();
				System.out.println("回滚");
			} catch (SQLException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}
	}
```

#### 第三章  JavaScript

##### 3.1 JavaScript语法

（1）JavaScript一种解释性脚本语言，是一种动态类型、弱类型、基于原型继承的语言，内置支持类型。它的解释器被称为JavaScript引擎，为浏览器的一部分，广泛用于客户端的脚本语言，最早是在HTML（标准通用标记语言下的一个应用）网页上使用，用来给HTML网页增加动态功能。需要注意的是javascript与java毫无关系,完整的JavaScript实现包含三个部分：ECMAScript，文档对象模型（DOM Document Object Model），浏览器对象模型(BOM Browser Object Model)。

（2）helloword和变量声明

   在JavaScript中，任何变量都用var关键字来声明，var是variable的缩写,JavaScript中的关键字不可以作为变量名，就像在Java中你不可以写"int int=1;"一样。

​    JavaScript的关键字和保留字：abstract、else、instanceof、super、boolean、enum、int、switch、break、export、interface、synchronized、byte、extends、let、this、case、false、long、throw、catch、final、native、throws、char、finally、new、transient、class、float、null、true、const、for、package、try、continue、function、private、typeof、debugger、goto、protected、var、default、if、public、void、delete、implements、return、volatile、do、import、short、while、double、in、static、with。

```
<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8" />
		<title>javascrit入门</title>
	</head>
	<body>
		<script type="text/javascript">
			
			/*hello world程序*/
			//alert("hello world");//弹出一个窗口显示helloworld
			//document.write("hello world");//在页面中显示hello world
			
			/*变量：任何变量都用var关键字来声明*/
			//声明变量，var是声明关键字，num是变量名，语句以分号结尾
			var num;
			var s;
			//赋值 ,赋值时决定类型
			num=10;
			s="hello";
			/*声明同时赋值*/
			var name="zhangsan";
			var sal=3000.5;
			
		</script>
	</body>
</html>
```

（3）数据类型

​	由于JavaScript中，任何变量都用var关键字来声明，所以定义的变量的类型只有赋值之后才能确定：var a="1";var a=false;var a=1;

（3.1）基本（原始）类型:number、string、boolean、undefined、null五种,在Java中，当一个变量未被初始化的时候，Java中是null或者基本数据类型的默认值,

在JavaScript中，当一个变量未被初始化的时候，它的值为undefined,可以通过以下语句来演示：var a;    document.write(a);

（3.2）引用（对象）类型：

​	（3.2.1）在Java中需要类定义，然后在实例对象：

```
public class Student{
  public int id;
  public String name;
  public int age;
}
public class Test{
    public static void main(String [] args){
        Student student=new Student();
      	student.id=1;
      	student.name="张三";
      	student.age=18;
    }
}
```

​	在JavaScript中对象可以直接写出来：

```
var student={id:1,name:"张三",age:18};
document.write(student.id);
document.write(student.name);
document.write(student.age);
```

​	事实上，student被赋值为了一个JSON，JSON就是我们在Java基础阶段学过的，全称是JavaScript Object Notation，叫做JavaScript对象标记，也就是说，在JavaScript中，JSON是用于标记一个对象的。

（3.2.2）数组类型：

​	数组就是和我们之前理解的数组概念一致，而在JavaScript中成为Array类型。我们说JSON可以标记一个对象，那么它同样可以标记一个数组，就是Java基础时我们学过的JSONArray。

（4）JavaScript的三种使用方式

​	 第一种方式：在<script>标签中，script可以放在网页中任何位置。

​	第二种方式：使用外部JavaScript文件，把js代码放入单独的文件中  ，这个文件的扩展名.js

​	第三种方式： 放在标签中的事件属性中,常见事件 ,onclick

```
<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title>数据类型</title>
	</head>
	<body>
		<script type="text/javascript">
			var num=10;
			var add="beijing";
			//java中的char类型在JavaScript中属于String类型
			var sex='男';
			var b2=false;
			//undefined 未定义类型
			var p=undefined;// 不赋值就是undefiend;
			//null null类型
			var h=null;
			//验证类型 typeof：返回变量类型
			document.write("num:  "+typeof(num));
			document.write("<br/>");
			document.write("h:"+typeof(null));
			
			document.write("<br/>------引用类型-----<br/>");
			/*javascript的引用类型 对象类型*/
			var obj=new Object();
			var date=new Date();
			var arr=new Array();
			var ss=new String("abc");
			var sal=new Number(30000);
			var bb=new Boolean(true);
			document.write(obj.toString());
			document.write("<br/>");
			document.write(date.toString());
			document.write("<br/>");
	
			//自定义类型
		   	/*class Person{
				private String name;
				private int age;
				//方法
				public void show(){
					System.out.println("name:"+name+"  age:"+age);
				}
			}
			 Person zhangsan=new Person();
			 zhangsan.name="张三";
			 zhangsan.age=20;
			 zhangsan.show();
			*/
			
			function Person(){
				this.name;//name属性
				this.age;//age属性
				this.show=function(){
					document.write("name:"+this.name+" age:"+this.age);
				}	
			}
			var zhangsan=new Person();
			zhangsan.name="张三";
			zhangsan.age=20;
			zhangsan.show();
			
			//动态添加额外的属性和方法
			zhangsan.address="北京";
			zhangsan.eat=function(){
				document.write(this.name+"吃肉...");
			}
			document.write(zhangsan.address);
			zhangsan.eat();
			
			//创建Object,动态添加属性和方法
			var lisi=new Object();
			lisi.name="李四";
			lisi.age=20;
			lisi.address="上海";
			lisi.show=function(){
				document.write("name:"+this.name+" age:"+this.age);
			};
			lisi.show();
			
			//JSON对象
			var wangwu={name:"王五",age:20,address:"广州"};
			document.write(wangwu.name);
			document.write(wangwu.age)
			document.write(wangwu.address);
			
			//数组创建
			var arr=[1,2,3,4];
			document.write("数组长度:"+arr.length);
			document.write(arr);
			var students = [
						{id: 1,name: "张三",age: 18},
						{id: 2,name: "李四",age: 18},
						{id: 3,name: "王五",age: 19}
			];
			document.write(students[0].id);//1
			document.write(students[0].name);//张三
			document.write(students[0].age);//18
			document.write("<br>");//这个是html的换行的意思
			document.write(students[1].id);//2
			document.write(students[1].name);//李四
		</script>
		
		<!--引用外部js文件: 注意 必须写结束标签-->
		<script type="text/javascript" src="js/myjs.js"></script>
		
		<input type="button" value="你点我啊" onclick="alert('你点我干嘛')" />
	</body>
</html>
```

##### 3.2 运算符、分支循环

（1）逻辑运算：与、或、非     &&、||、!

（2）关系运算：==，<,<=,>,>=,!=,===（全等于）

​	注：==比较时会做自动类型转换，尽量相等，===不做任何的改变，完全相等才为true

（3）单目运算：++，--

（4） 双目运算：+、-、\*、/、%、=、+=、-=、/=、\*=、%=

```
<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title>运算符</title>
	</head>
	<body>
		<script type="text/javascript">
			var s="abc";//属于原始类型 
			var s2=new String("abc");//属于引用类型
			document.write("s==s2:"+(s==s2));//s2转成原始类型abc,true
			document.write("<br/>")
			document.write("s===s2"+(s===s2));//false
			
			/*分支结构 if-else*/
			var a=10;
			if(a>=10){//true
				document.write("a>=10");
			}else{
				document.write("a<10");
			}
			// 1 if(条件表达式) 关系运算符  逻辑运算符 
			// 2 if() 直接写变量，不用运算符，如果变量值为undefined,null 表示false，否则true
			// 3 如果变量没有定义,则出现异常。zhangsan.name ,给zhangsan添加name属性，没有赋值
			document.write("<br/>")
			var b;
			var zhangsan=new Object();
			if(zhangsan.name){
				document.write("true");
			}else{
				document.write("false");
			}
			
			/*分支结构 switch*/
			var a=2;
			switch(a){
  				case 1:
    				document.write("值为1");
    				break;
  				case 2:
    				document.write("值为2");
    				break;
  				case 3:
    				document.write("值为3");
   	 				break;
  				default:
     				document.write("值不是3也不是2也不是1");
			}
			
			/*循环：for循环*/
			var a=0;
			for(var i=1;i<=100;i++){
			    a+=i;
			}
			document.write("<br/>")
			document.write(a);
			
            /*循环：while循环*/
            var a=0;
			var i=1;
			while(i<=100){
   				a+=i;
   				i++;
			}
			document.write(a);
			
			/*do-while循环*/
			var a=0;
            var i=1;
            do{
                a+=i;
                i++;
            }while(i<=100);
			document.write(a);
			
			//创建数组，for循环遍历
			var arr=[10,20,30,40];
			for(var i=0;i<arr.length;i++){
				document.write(arr[i]);
				document.write("<br/>")
			}
				
			//创建数组，增强for循环遍历
			var arr=[10,20,30,40];
			for(var i in arr){  //i不是arr中的元素，而是下标
				document.write(arr[i]);
				document.write("<br/>")
			}
			
			//java 数组 集合 list set map
			//javascript 只有一种Array 表示全部
			var map=new Array();
			map['cn']="中国";
			map['us']="美国";
			map['jp']="日本";
			map['kor']="韩国";
			
			for(var k in map){
				document.write(k+"...."+map[k]);
				document.write("<br/>")
			}
		</script>
		
	</body>
</html>
```

##### 3.3 JavaScript深入

（1）函数

（1.1）函数定义：用function关键字来声明，后面是函数名字，参数列表里不写var。整个方法不写返回值类型。

```
!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title>函数</title>
	</head>
	<body>
		
		<!--构造函数(相对于java)//1第一个字母大写 //2属性和方法使用this
			function Person(){ 
				this.name;
				this.age;
				this.show=function(){	
				}
			}	
		-->
		
		<!--普通函数(相等于java的普通方法)-->
		<script type="text/javascript">
			/*定义普通函数,整个方法不写返回值类型*/
			function add(a,b){ //第一个字母小写
				var c=a+b;
				return c;
			}
			//冒泡排序
			function bubbleSort(arr){
				for(var i=0;i<arr.length-1;i++){
					for(var j=0;j<arr.length-i-1;j++){
						if(arr[j]>arr[j+1]){
							var temp=arr[j];
							arr[j]=arr[j+1];
							arr[j+1]=temp;
						}
					}
				}
			}
			
			/*调用函数*/
			var result=add(10,20);
			document.write(result);
			
			var nums=[5,2,100,3,10,8];
			document.write(nums);
			bubbleSort(nums);
			document.write(nums);
		</script>	
	</body>
</html>
```

（1.2）匿名函数

```
var method1=function(){
	document.write("这是一个匿名函数");
}
method1();

/*匿名函数(自执行匿名函数)*/
(function(s){
	document.write("这是一个自执行匿名函数"+s);
})("hahaha");
```

（1.3）弹窗函数

（1.3.1）alert

​	 这是一个只能点击确定的弹窗：alert("你好");alert方法没有返回值，也就是说如果用一个变量去接受返回值，将会得到undefined。无论你点击“确定”还是右上角的那个“X“关闭。

（1.3.2）confirm

​	这是一个你可以点击确定或者取消的弹窗：confirm("你好");confirm方法与alert不同，他的返回值是boolean，当你点击“确定”时，返回true，无论你点击“取消”还是右上角的那个“X“关闭，都返回false。

（1.3.3）prompt

​	这是一个你可以输入文本内容的弹窗：prompt("你爱学习吗？","爱");第一个参数是提示信息，第二个参数是用户输入的默认值。当你点击确定的时候，返回用户输入的内容。当你点击取消或者关闭的时候，返回null。

```
<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title>弹窗函数</title>
	</head>
	<body>
		<script type="text/javascript">
			/*警告（提示）窗口*/
			alert("这是一个警告窗口");
			/**/
			/*确认窗口*/
			var b=confirm("确定要删除吗?");
			if(b){
				document.write("删除成功....")
			}
			document.write(b);
			/*输入 窗口*/
			var color=prompt("请输入您喜欢的颜色?","白色");
			document.write(color);
		</script>
		
	</body>
</html>
```

（2）事件

​        onchange: HTML元素改变，当光标移开onchange控制区域的时候触发事件

​	onclick：点击HTML元素时触发

​	onmouseover:鼠标经过HTML元素时触发

​	onmouseout:鼠标离开HTML元素时触发

​	onkeydown：按下键盘时触发

​	onload：浏览器已完成页面的加载时触发

```
<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title>事件</title>
		
		<style type="text/css">
			<!--用作onmouseover，onmouseout测试区域-->
			#box1{
				width: 200px;
				height: 200px;
				background-color: pink;
			}
		</style>
	
	</head>
	
	<!--等页面加载完成后触发事件开始执行程序，固有时会造成网页延迟问题-->
	<body onload="doLoad()">
		<!--需要增加doChange函数-->
		<input type="text" name="username" onchange="doChange(this)"/>
		
		<!--onclick显示五一快乐，点击后触发事件改变为六一快乐-->
		<h1 onclick="this.innerText='六一快乐'">五一快乐!</h1>
		<h1 onclick="this.style.display='none'">点击消失!</h1>
		<input id="btn1" type="button" value="按钮"  />
		
		<!--onmouseover需要增加over()，out()函数-->
		<div id="box1" onmouseover="over()" onmouseout="out()">	
		</div>
		
		<table width="500" height="200" border="1">
			<tr>
				<td>xxx</td>
				<td>yyy</td>
				<td>zzz</td>
			</tr>
			<tr>
				<td>xxx</td>
				<td>yyy</td>
				<td>zzz</td>
			</tr>
			<tr>
				<td>xxx</td>
				<td>yyy</td>
				<td>zzz</td>
			</tr>
			<tr>
				<td>xxx</td>
				<td>yyy</td>
				<td>zzz</td>
			</tr>
		</table>
		
		<!--不能落下return-->
		<input type="text" name="address" onkeydown="return dokeyDown(this)" />
		
		<script type="text/javascript">
			document.getElementById("btn1").onclick=function(){
				alert("点我干嘛");
			};
			document.getElementById("btn1").onclick=function(){
				alert("点我干嘛2");
			};
		
		
			function doChange(obj){
				<!--弹出obj的值-->
				alert(obj.value);
			}
			
			function over(){
				alert("经过box1");
			}
			function out(){
				alert("离开box1");
			}
			
			function dokeyDown(obj){
				//获取按下的哪个键
				//扩展一点event
				var code=event.keyCode;
				<!--阻止shift键输入-->
				if(event.shiftKey){
					return false;
				}
	<!--限制输入内容为字母和数字以及删除键(8),不能阻止shift+*字符的输入-->
				if((code>=48&&code<=57)||(code>=65&&code<=90)||code==8){
					return true;//表示系统接收数据
				}
				return false;//表示系统不接受,此时对话框中没法输入该字符
			}
			/*onLoad：事件等待页面中所有的资源都加载完毕才执行*/
			function doLoad(){
				//document.write("页面加载完毕....");
				alert("页面加载完毕....");
			}
		</script>
	</body>
</html>
```

（3）正则表达式

（3.1）RegExp 对象

​	正则表达式是描述字符模式的对象，正则表达式用于对字符串模式匹配及检索替换，是对字符串执行模式匹配的强大工具。语法：

​	var patt=new RegExp(pattern,modifiers);

或者更简单的方式:

​	var patt=/pattern/modifiers;

例：var re1 = new RegExp("\\w+");         var re2 = /\w+/;

（3.1.1）修饰符：修饰符用于执行区分大小写和全局匹配

​	i：执行对大小写不敏感的匹配

​	g：执行全局匹配（查找所有匹配而非在找到第一个匹配后停止）

​	m：执行多行匹配

（3.1.2）方括号：用于查找某个范围内的字符	

| 表达式                | 描述                   |
| :----------------- | -------------------- |
| [abc]              | 查找方括号之间的任何字符。        |
| [^abc]             | 查找任何不在方括号之间的字符。      |
| [0-9]              | 查找任何从 0 至 9 的数字。     |
| [a-z]              | 查找任何从小写 a 到小写 z 的字符。 |
| [A-Z]              | 查找任何从大写 A 到大写 Z 的字符。 |
| [A-z]              | 查找任何从大写 A 到小写 z 的字符。 |
| [adgk]             | 查找给定集合内的任何字符。        |
| [^adgk]            | 查找给定集合外的任何字符。        |
| (red\|blue\|green) | 查找任何指定的选项。           |

（3.1.3）元字符（Metacharacter）：是拥有特殊含义的字符：

| 元字符    | 描述                            |
| ------ | ----------------------------- |
| .      | 查找单个字符，除了换行和行结束符。             |
| \w     | 查找单词字符。[a-zA-Z0-9_]           |
| \W     | 查找非单词字符。                      |
| \d     | 查找数字。[0-9]                    |
| \D     | 查找非数字字符。                      |
| \s     | 查找空白字符。                       |
| \S     | 查找非空白字符。                      |
| \b     | 匹配单词边界。                       |
| \B     | 匹配非单词边界。                      |
| \0     | 查找 NULL 字符。                   |
| \n     | 查找换行符。                        |
| \f     | 查找换页符。                        |
| \r     | 查找回车符。                        |
| \t     | 查找制表符。                        |
| \v     | 查找垂直制表符。                      |
| \xxx   | 查找以八进制数 xxx 规定的字符。            |
| \xdd   | 查找以十六进制数 dd 规定的字符。            |
| \uxxxx | 查找以十六进制数 xxxx 规定的 Unicode 字符。 |

（3.1.4）量词

| 量词     | 描述                                       |
| ------ | ---------------------------------------- |
| n+     | 匹配任何包含至少一个 n 的字符串。例如，/a+/ 匹配 "candy" 中的 "a"，"caaaaaaandy" 中所有的 "a"。 |
| n*     | 匹配任何包含零个或多个 n 的字符串。例如，/bo*/ 匹配 "A ghost booooed" 中的 "boooo"，"A bird warbled" 中的 "b"，但是不匹配 "A goat grunted"。 |
| n?     | 匹配任何包含零个或一个 n 的字符串。例如，/e?le?/ 匹配 "angel" 中的 "el"，"angle" 中的 "le"。 |
| n{X}   | 匹配包含 X 个 n 的序列的字符串。例如，/a{2}/ 不匹配 "candy," 中的 "a"，但是匹配 "caandy," 中的两个 "a"，且匹配 "caaandy." 中的前两个 "a"。 |
| n{X,}  | X 是一个正整数。前面的模式 n 连续出现至少 X 次时匹配。例如，/a{2,}/ 不匹配 "candy" 中的 "a"，但是匹配 "caandy" 和 "caaaaaaandy." 中所有的 "a"。 |
| n{X,Y} | X 和 Y 为正整数。前面的模式 n 连续出现至少 X 次，至多 Y 次时匹配。例如，/a{1,3}/ 不匹配 "cndy"，匹配 "candy," 中的 "a"，"caandy," 中的两个 "a"，匹配 "caaaaaaandy" 中的前面三个 "a"。注意，当匹配 "caaaaaaandy" 时，即使原始字符串拥有更多的 "a"，匹配项也是 "aaa"。 |
|        |                                          |
| n$     | 匹配任何结尾为 n 的字符串。                          |
| ^n     | 匹配任何开头为 n 的字符串。                          |
| ?=n    | 匹配任何其后紧接指定字符串 n 的字符串。                    |
| ?!n    | 匹配任何其后没有紧接指定字符串 n 的字符串。                  |

（4）RegExp 对象方法

| 方法       | 描述                          | FF   | IE   |
| -------- | --------------------------- | ---- | ---- |
| compile  | 编译正则表达式。                    | 1    | 4    |
| exec     | 检索字符串中指定的值。返回找到的值，并确定其位置。   | 1    | 4    |
| **test** | 检索字符串中指定的值。返回 true 或 false。 | 1    | 4    |

支持正则表达式的 String 对象的方法：

| 方法         | 描述               | FF   | IE   |
| ---------- | ---------------- | ---- | ---- |
| **search** | 检索与正则表达式相匹配的值。   | 1    | 4    |
| **match**  | 找到一个或多个正则表达式的匹配。 | 1    | 4    |
| replace    | 替换与正则表达式匹配的子串。   | 1    | 4    |
| **split**  | 把字符串分割为字符串数组。    | 1    | 4    |

（5）正则表达式的使用

​	test()方法：test()方法搜索字符串指定的值，根据结果并返回真或假。

​	exec() 方法：exec() 方法检索字符串中的指定值。返回值是被找到的值。如果没有发现匹配，则返回 null。

```
<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title>正则表达式</title>
	</head>
	<body>
		<script type="text/javascript">
			//创建正则表达式对象:电话号码
			var regexp1=new RegExp("^1[3578]\\d{9}$");
			var regexp2=new RegExp("1[3578]\\d{9}","g");
			
			var regexp3=/1[3578]\d{9}/g;
			
			var b=regexp1.test("13987653456");
			var s=regexp3.exec("1398765345612312412318712345678");
				document.write("<br/>")
			document.write(regexp3.lastIndex);
			var s2=regexp3.exec("1398765345612312412318712345678");
			document.write("<br/>")
			document.write(regexp3.lastIndex);
			document.write(b);
			document.write("<br/>")
			document.write(s);
			document.write("<br/>")
			document.write(s2);
			
			//使用字符串对象的方法
			//string
			var content="我爱北京天安门,天安门上太阳升";
			//执行content转成String
			//var r=new RegExp("北京");
			var n=content.search("北京");
			var arr=content.match(/天安门/g);
			document.write("<br/>")
			document.write(n);
			document.write("<br/>")
			document.write(arr);
			
			var content2="I love beijing,I                    Love china";
			var arr2=content2.split(/[ ,]+/g);
			document.write("<br/>")
			for(var i=0;i<arr2.length;i++){
				document.write("<br/>");
				document.write(arr2[i]);
			}	
		</script>
	</body>
</html>
```

##### 3.4 Js的DOM和BOM

（1）DOM

（1.1）DOM概述：

​	通过 HTML DOM,使用 JavaScript访问 HTML 文档的所有元素，当网页被加载时，浏览器会创建页面的文档对象模型（Document Object Model）.通过可编程的对象模型，JavaScript 获得了足够的能力来创建动态的 HTML。

- JavaScript 能够改变页面中的所有 HTML 元素。
- JavaScript 能够改变页面中的所有 HTML 属性。
- JavaScript 能够改变页面中的所有 CSS 样式。
- JavaScript 能够对页面中的所有事件做出反应。

（1.2）查找HTML元素

​	通常，通过 JavaScript，您需要操作 HTML 元素。为了做到这件事情，您必须首先找到该元素。有三种方法来做这件事：

- 通过 id 找到 HTML 元素：var x=document.getElementById("intro");如果找到"intro" 元素，则该方法将以对象（在 x 中）的形式返回该元素。如果未找到该元素，则 x 将包含 null。
- 通过标签名找到 HTML 元素：查找 id="main" 的元素，然后查找 id="main" 元素中的所有 <p> 元素：var x=document.getElementById("main");
  var y=x.getElementsByTagName("p");
- 通过类名找到HTML 元素：通过 getElementsByClassName 函数来查找 class="intro" 的元素：var x=document.getElementsByClassName("intro");

（1.3）改变HTML

​	HTML DOM 允许 JavaScript 改变 HTML 元素的内容。

（1.3.1）改变HTML输出流

​	JavaScript 能够创建动态的 HTML 内容：

​	今天的日期是： Tue Sep 19 2017 16:25:34 GMT+0800 (中国标准时间) 

​	在 JavaScript 中，document.write() 可用于直接向 HTML 输出流写内容。

（1.3.2）改变HTML内容

​	修改 HTML 内容的最简单的方法时使用 innerHTML 属性。需改变 HTML 元素的内容，请使用这个语法：

​		document.getElementById(*id*).innerHTML="*abcd*";

（1.3.3） 改变HTML属性

​	如需改变 HTML 元素的属性，请使用这个语法：

​		document.getElementById(*id*).*attribute=新属性值*

```
<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8" />
		<title>网页标题</title>
	</head>
	<body>
		<div id="box1">
			<h1 id="poemTitle">静夜思</h1>
			<p>作者李白</p>
		</div>
		
		<h2 class="t1">二级标题1</h2>
		<h2 class="t1">二级标题2</h2>
		<h2>二级标题3</h2>
		
		<!--为修改属性测试做准备-->
		<img id="img1" src="img/002.png"  alt=""/><br />
		<input id="username" type="text" name="username" value="zhangsan" /><br/>
		
		<input type="button" onclick="doClick1()" value="点击 getElementById" /><br/>
		<input type="button" onclick="doClick2()" value="点击 getElementsByTagname" /><br/>
		<input type="button" onclick="doClick3()" value="点击 getElementsByClassName" />
		
		<input type="button" onclick="changeImg()" value="改变图片"/><br/>
		<input type="button" onclick="changeText()" value="改变文本框内容"/><br/>
		<script type="text/javascript">
			
			function doClick1(){
				/*获取网页中dom元素有三种方式:*/
				//第一种方式document.getElementById();
				var box1=document.getElementById("box1");
				var poemTitle=document.getElementById("poemTitle");
				//alert(box1);
				//修改古诗的标题
				//使用innerHTML修改内容，标签内容当作实际真正的标签来解析
				//poemTitle.innerHTML="<font color='red'>忆江南</font>";
				//使用innerText修改内容，标签内容当作普通文本来解析，即font color='red'会作为一串字符显示，而不会起到将忆江南变成红色字体的效果。
				poemTitle.innerText="<font color='red'>忆江南</font>";	
			}
			
			function doClick2(){
					//第二种方式通过标签名获取
				var arr=document.getElementsByTagName("h2");
				for(var i in arr){
					alert(arr[i].innerText);
				}	
			}
			
			function doClick3(){
					//第三种方式通过class属性获取
				var arr2=document.getElementsByClassName("t1");
				alert(arr2.length);
			}
            
            function changeImg(){
				document.getElementById("img1").src="img/003.png";
			}
			function changeText(){
				document.getElementById("username").value="lisi";
			}
		</script>
	</body>
</html>
```

（1.4）CSS变化

​	如需改变 HTML 元素的样式，请使用这个语法：

​		document.getElementById(*id*).style.*property*=*新样式*

```
<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title></title>
		<style type="text/css">
			
			.class1{
				font-size: 30px;
				color: red;
			}
			.class2{
				width: 100px;
				height: 100px;
				background-color: cornflowerblue;
			}
		</style>
	</head>
	<body>
		<p id="p1">Hello World!</p>
		<p id="p2">Hello World!</p>
		
		<p id="p3">今天下午提前下班，好happy</p>
		<p id="p4">明天约不约</p>
		
		<!--第一种方式使用style属性-->
		<input type="button" value="修改p1的字体" onclick="changeStyle()"  /><br/>
		<input type="button" value="修改p2的字体" onclick="changeStyle2()"  /><br/>
		<!--第二种方式使用class属性-->
		<input type="button" value="修改p3的样式" onclick="changeStyle3()"  /><br/>
		<input type="button" value="修改p4的样式" onclick="changeStyle4()"  /><br/>
		
		<input type="button" value="移除class属性" onclick="changeStyle5()"  /><br/>
		<script type="text/javascript">
			
			function changeStyle(){
				var p1=document.getElementById("p1");
				p1.style.color="blue";
				p1.style.fontSize="30px";
				p1.style.backgroundColor="gray";
			}
			function changeStyle2(){
				var p2=document.getElementById("p2");
				p2.style.width="200px";
				p2.style.height="100px";
				p2.style.backgroundColor="pink";
				
			}
			
			function changeStyle3(){
				var p3=document.getElementById("p3");
				p3.className+=" class1";
			}
			function changeStyle4(){
				var p4=document.getElementById("p4");
				p4.className+=" class2";
			}
			
			function changeStyle5(){
				var p3=document.getElementById("p3");
				//p3.className=p3.className.replace(" class1","");
				p3.className="";
			}
		</script>
	</body>
</html>

```

（1.5）元素操作

（1.5.1）创建新元素

​	如需向 HTML DOM 添加新元素，您必须首先创建该元素（元素节点），然后向一个已存在的元素追加该元素。

```
<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title></title>
	</head>
	<body>
		<p id="p1">第一个段落</p>
		<p id="p2">第二个段落</p>
		
		<input type="button" value="添加段落" onclick="add()" />
		<input type="button" value="添加图片" onclick="addImage()" />
		
		<script type="text/javascript">
			function add(){
				/*
				//1创建新的<p> 元素
				var np=document.createElement("p");
				//2向 <p> 元素添加文本，必须首先创建文本节点
				var node=document.createTextNode("新建的段落");
				//3然后必须向 <p> 元素追加这个文本节点
				np.appendChild(node);
				*/
				
				
				//1新建一个段落
				var np= document.createElement("p");
				//2设置内容
				np.innerText="新建的段落";
				//alert("xxx");
				//3追加页面
				//document.body.appendChild(np);
				
				//4向一个已有的元素追加这个新元素
				//4.1这段代码找到一个已有的元素
				var p1=document.getElementById("p1");
				//4.2添加到某个元素的前面
				document.body.insertBefore(np,p1);
				//4.1这段代码找到一个已有的元素
				var p2=document.getElementById("p2");
				//4.2添加到某个元素的后面
				p2.appendChild(np);
			}
			
			function addImage(){
				//1创建图片标签
				var newimage=document.createElement("img");
				//2设置属性
				newimage.src="img/002.png";
				newimage.alt="替换内容";
				//3追加
				document.body.appendChild(newimage);
				
			}
			
		</script>
		
	</body>
</html>

```

（1.5.2）删除已有的 HTML 元素

```
<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title></title>
	</head>
	<body>
		<img id="img1" src="img/003.png"  width="50" height="80"/>
		
		<input type="button"  onclick="del()" value="删除"/>
		<script type="text/javascript">
			function del(){
				var img1=document.getElementById("img1");
				
				//直接把自己移除
				//img1.remove();
				
				//使用其 parentNode 属性得到父元素，再把子元素删除
				img1.parentNode.removeChild(img1);	
			}	
		</script>
	</body>
</html>
注意：删除元素的本质操作如下：
	<div id="div1">
    	<p id="p1">这是一个段落。</p>
    	<p id="p2">这是另一个段落。</p>
    </div>
    <script>
    	var parent=document.getElementById("div1");
    	var child=document.getElementById("p1");
    	parent.removeChild(child);
    </script>
    如果能够在不引用父元素的情况下删除某个元素，就太好了。不过很遗憾。DOM 需要清楚您需要删除的元素，以及它的父元素。所以在上述程序中找到了常用的解决方案，即使用其 parentNode 属性来找到父元素。
```

（1.6）DOM事件

​	HTML DOM 允许我们通过触发事件来执行代码，这部分内容与js深入章节中的事件有重合。

```
/**
*事件1 onclick
*/
<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title></title>
	</head>
	<body>
		<h1 onclick="this.innerText='六一快乐'">五一快乐!</h1>
		<h1 onclick="this.style.display='none'">点击消失!</h1>
		
		<input id="btn1" type="button" value="按钮"  />
		
		<script type="text/javascript">
			document.getElementById("btn1").onclick=function(){
				alert("点我干嘛");
			};
			document.getElementById("btn1").onclick=function(){
				alert("点我干嘛2");
			};
		</script>
	</body>
</html>

/**
*事件2 动态添加行
*/
!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title></title>
	</head>
	<body>
		<table id="tab" border="1" width="500" height="300">
			<tr>
				<td>xxx</td>
				<td>yyy</td>
				<td>zzz</td>
			</tr>
				<tr>
				<td>xxx</td>
				<td>yyy</td>
				<td>zzz</td>
			</tr>
				<tr>
				<td>xxx</td>
				<td>yyy</td>
				<td>zzz</td>
			</tr>
		</table>
		
		<input type="button" onclick="addtr()" value="添加行" />
		<input type="button" onclick="deltr()" value="删除行" />
		
		<script type="text/javascript">
			function  addtr(){
//				var tab=document.getElementById("tab");
//				var newtr=document.createElement("tr");
//				var newtd1=document.createElement("td");
//				var newtd2=document.createElement("td");
//				var newtd3=document.createElement("td");
//				
//				newtd1.innerText="hello";
//				newtd2.innerText="hello2";
//				newtd3.innerText="hello3";
//				
//				newtr.appendChild(newtd1);
//				newtr.appendChild(newtd2);
//				newtr.appendChild(newtd3);
//				
//				tab.appendChild(newtr);


				//添加行
				var newtr=tab.insertRow(tab.rows.length);
				//添加列
				var td1=newtr.insertCell();
				var td2=newtr.insertCell();
				var td3=newtr.insertCell();
				td1.innerText="hello";
				td2.innerText="hello2";
				td3.innerText="hello3";
			}
			
			function deltr(){
				var tab=document.getElementById("tab");
				var allrows=tab.rows;
				tab.deleteRow(allrows.length-1);
			}
				
		</script>
	</body>
</html>

/**
*事件3 格鼠标经过换色
*/
<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title>表格鼠标经过换色</title>
		<style type="text/css">
			.tr1{
				background-color: gainsboro;
			}
			.tr2{
				background-color: #6495ED;
			}
		</style>
	</head>
	<body>
		<table width="300" height="200" border="1">
			<tr class="tr1">
				<td>xxx</td>
				<td>yyy</td>
				<td>zzz</td>
			</tr>
			<tr class="tr1">
				<td>xxx</td>
				<td>yyy</td>
				<td>zzz</td>
			</tr>
			<tr class="tr1">
				<td>xxx</td>
				<td>yyy</td>
				<td>zzz</td>
			</tr>
			<tr class="tr1">
				<td>xxx</td>
				<td>yyy</td>
				<td>zzz</td>
			</tr>
			<tr class="tr1">
				<td>xxx</td>
				<td>yyy</td>
				<td>zzz</td>
			</tr>
			<tr class="tr1">
				<td>xxx</td>
				<td>yyy</td>
				<td>zzz</td>
			</tr>
		</table>		
		<script type="text/javascript">
			
			var rows=document.getElementsByTagName("tr");
			for(var i in rows){
				rows[i].onmouseover=function(){
					this.className="tr2";
				};
				rows[i].onmouseout=function(){
					this.className="tr1";
				}
			}
			
		</script>
	</body>
</html>

```

（1.7）EventListener

​	addEventListener() 方法用于向指定元素添加事件：

​		element.addEventListener(event, function, useCapture);

​	第一个参数是事件的类型 (如 "click" 或 "mousedown").  把on去掉，例如使用 "click" 而不是使用 "onclick"。第二个参数是事件触发后调用的函数。第三个参数是个布尔值用于描述事件是冒泡还是捕获。该参数是可选的。

​	addEventListener() 方法允许向同个元素添加多个事件，且不会覆盖已存在的事件：     element.addEventListener("click", myFunction);
​	    element.addEventListener("click", mySecondFunction);

​	可以向同个元素添加不同类型的事件：

​		element.addEventListener("mouseover", myFunction);
​		element.addEventListener("click", mySecondFunction);

​	当你使用 addEventListener() 方法时, JavaScript 从 HTML 标记中分离开来，可读性更强， 在没有控制HTML标记时也可以添加事件监听。

​	removeEventListener() 方法移除由 addEventListener() 方法添加的事件:

​		element.removeEventListener("mousemove", myFunction);

```
<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title>监听</title>
	</head>
	<body>
		<input id="btnClick" type="button" value="点击按钮"  />
		<script type="text/javascript">
			//使用事件属性添加click事件
			document.getElementById("btnClick").onclick=function(){
				alert("第一个消息");
			}
		
			//使用事件监听方式添加click事件
			function doclick1(){
				alert("第一个消息");
			}
			function doclick2(){
				alert("第二个消息");
			}
			document.getElementById("btnClick").addEventListener("click",doclick1);			document.getElementById("btnClick").addEventListener("click",doclick2);
			
			//移除事件监听			//document.getElementById("btnClick").removeEventListener("click",doclick2);
			
		</script>
	</body>
</html>
```

addEventListener() 方法允许你在 HTML DOM 对象添加事件监听，不仅仅是 HTML 元素，还可以是HTML 文档, window 对象或者其他支出的事件对象如: 	

​		xmlHttpRequest 对象

​	当用户重置窗口大小时添加事件监听：

```
window.addEventListener("resize", function(){
    document.getElementById("demo").innerHTML = sometext;
});
```

​	addEventListener() 方法可以更简单的控制事件,事件传递有冒泡与捕获两种方式,事件传递定义了元素事件触发的顺序。 如果你将 <p> 元素插入到 <div> 元素中，用户点击 <p> 元素, 哪个元素的 "click" 事件先被触发呢？

​	在 *冒泡 *中，内部元素的事件会先被触发，然后再触发外部元素，即： <p> 元素的点击事件先触发，然后会触发 <div> 元素的点击事件；在 *捕获 *中，外部元素的事件会先被触发，然后才会触发内部元素的事件，即： <div> 元素的点击事件先触发 ，然后再触发 <p> 元素的点击事件。addEventListener() 方法可以指定 "useCapture" 参数来设置传递类型,默认值为 false, 即冒泡传递，当值为 true 时, 事件使用捕获传递。

```
<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title></title>
		<style type="text/css">
			#box1{
				width: 200px;
				height: 200px;
				background-color: pink;
			}
			#p1{
				width: 100px;
				height: 100px;
				background-color: bisque;
			}
		</style>
	</head>
	<body>
		
		<div id="box1">
			<p id="p1">
				段落
			</p>
			
		</div>
		
		<script type="text/javascript">
			/*document.getElementById("box1").onclick=function(){
				alert("这是一个div");
				
			}
			document.getElementById("p1").onclick=function(){
				alert("这是一个段落");
			}*/
			
			//默认方式 冒泡方式(从内部向外部)
			function divClick(){
				alert("这是一个div");
				
			}
			function pClick(){
				alert("这是一个段落");	
			}
			
			//修改为捕获方式 true			document.getElementById("box1").addEventListener("click",divClick,true);			document.getElementById("p1").addEventListener("click",pClick,true);
			
		</script>
	</body>
</html>
```

（2）JavaScript的BOM

​	浏览器对象模型 (BOM) 使 JavaScript 有能力与浏览器"对话",浏览器对象模型 (BOM):(**B**rowser **O**bject **M**odel)尚无正式标准,由于现代浏览器已经（几乎）实现了 JavaScript 交互性方面的相同方法和属性，因此常被认为是 BOM 的方法和属性。

（2.1）window

​	所有浏览器都支持 window 对象。它表示浏览器窗口，所有 JavaScript 全局对象、函数以及变量均自动成为 window 对象的成员，全局变量是 window 对象的属性，全局函数是 window 对象的方法，甚至 HTML DOM 的 document 也是 window 对象的属性之一：

​		window.document.getElementById("header");

​	等价于document.getElementById("header");

（2.1.1）window的尺寸

有三种方法能够确定浏览器窗口的尺寸。

对于Internet Explorer、Chrome、Firefox、Opera 以及 Safari：

- window.innerHeight - 浏览器窗口的内部高度(不包括滚动条、菜单栏、工具栏)
- window.innerWidth - 浏览器窗口的内部宽度(不包括滚动条、菜单栏、工具栏)

对于 Internet Explorer 8、7、6、5：

- document.documentElement.clientHeight
- document.documentElement.clientWidth

或者

- document.body.clientHeight
- document.body.clientWidth

（2.1.2）Window Screen

​	可用宽度：screen.availWidth 属性返回访问者屏幕的宽度，以像素计，减去界面特性，比如窗口任务栏。

​	可用高度：screen.availHeight 属性返回访问者屏幕的高度，以像素计，减去界面特性，比如窗口任务栏。

```
<!DOCTYPE html>
<html>

	<head>
		<meta charset="UTF-8">
		<title>window对象</title>
	</head>

	<body>

		<input type="button" value="浏览器窗口的高度和宽度" onclick="showWH()" />
		<input type="button" value="整个浏览器窗口的高度和宽度" onclick="showWH2()" />
		<input type="button" value="浏览器窗口的可用高度和可用宽度" onclick="showWH3()" />
		<input type="button" value="打开窗口" onclick="doOpen()" />
		<input type="button" value="关闭窗口" onclick="doClose()" />
		<script type="text/javascript">
			/*	var num=10;//num作为window的属性
						alert(window.num);
						
						function show(){ //作为window的方法
							alert("这是一个函数");
						}
						
						//show();
						window.show();
						
						//window对象
						window.alert("消息框");
						window.confirm("确定要删除吗");
						window.prompt("请输入");*/
					
			/*var i;
			var k=2;
			var j=3;
			var n=i||k||j;
			alert(n);*/

			function showWH() {
				var w = window.innerWidth ||
					document.documentElement.clientWidth ||
					document.body.clientWidth;

				var h = window.innerHeight ||
					document.documentElement.clientHeight ||
					document.body.clientHeight;
					
					alert("宽度："+w+" 高度:"+h);
					
			}
			function showWH2() {
				var w = window.outerWidth;

				var h = window.outerHeight;
					
					alert("整个宽度："+w+" 整个高度:"+h);
					
			}
			function showWH3() {
				var w = window.screen.availWidth;

				var h = window.screen.availHeight;
					
					alert("可用宽度："+w+" 可用高度:"+h);
					
			}
			var win;
			function doOpen(){
				win=window.open("http://www.baidu.com");//使用超链接代替
			}
			function doClose(){
				//win.close();//关闭win
				
				window.close();//把自己关闭了
			}
		</script>
	</body>

</html>
```

（2.1.3）Window Location

​	window.location 对象用于获得当前页面的地址 (URL)，并把浏览器重定向到新的页面。在编写时可以不使用 window 这个前缀。

（2.1.4）Window History

​	window.history 对象包含浏览器的历史。

（2.1.5） Window Navigator

​	window.navigator*对象在编写时可以不使用 window 这个前缀

```
<!DOCTYPE html>
<html>

	<head>
		<meta charset="UTF-8">
		<title>widow对象</title>
	</head>

	<body>
		<input type="button" value="显示地址栏中URL" onclick="doClick()" />
		<input type="button" value="跳转到百度" onclick="doClick2()" />
		<input type="button" value="后退" onclick="doBack()" />
		<input type="button" value="前进" onclick="doForward()" />
		<script type="text/javascript">
			function doClick() {
				alert(window.location); //获取地址
				alert(window.location.href); //获取地址，当前页面的 URL
				document.write(location.href);
				alert(window.location.hostname); //web 主机的域名
				alert(window.location.pathname); //当前页面路径和文件名
				alert(window.location.port); //端口号
				alert(window.location.protocol); //使用的 web 协议
			}

			function doClick2() {
				//window.location.href="http://www.baidu.com";
				//加载新的文档
				window.location.assign("http://www.baidu.com");
			}

			function doBack() {
				//与在浏览器点击后退按钮相同
				window.history.back();
			}

			function doForward() {
				//与在浏览器中点击按钮向前相同
				window.history.forward();
				//window.history.go(0);//-1后退  1 前进 0刷新
			}
		</script>

		<div id="example"></div>
		<script>
			txt = "<p>浏览器代号: " + navigator.appCodeName + "</p>";
			txt += "<p>浏览器名称: " + navigator.appName + "</p>";
			txt += "<p>浏览器版本: " + navigator.appVersion + "</p>";
			txt += "<p>启用Cookies: " + navigator.cookieEnabled + "</p>";
			txt += "<p>硬件平台: " + navigator.platform + "</p>";
			txt += "<p>用户代理: " + navigator.userAgent + "</p>";
			txt += "<p>用户代理语言: " + navigator.systemLanguage + "</p>";
			document.getElementById("example").innerHTML = txt;
		</script>
	</body>

</html>
```

##### 3.5  JavaScript计时

（1）Date对象

````
<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title>Date时间对象</title>
	</head>
	<body>
		<script type="text/javascript">
			var d=new Date();
			document.write(d);
			//时间对象
			//获取年
			document.write("<br/>")
			document.write("年份："+(d.getYear()+1900));
			document.write("<br/>")
			document.write("年份："+d.getFullYear());
			document.write("<br/>");
			document.write("月份:"+(d.getMonth()+1))
			document.write("<br/>");
			document.write("日期:"+d.getDate());
			document.write("<br/>");
			document.write("小时:"+d.getHours());
			document.write("<br/>");
			document.write("分钟:"+d.getMinutes());
			document.write("<br/>");
			document.write("秒:"+d.getSeconds());
				
		</script>
	</body>
</html>
````

（2）JavaScript计时事件

​	setInterval() 间隔指定的毫秒数不停地执行指定的代码

```
<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title>间隔执行</title>
	</head>
	<body>
		
		<div id="myclock"></div>
		
		<input id="btn1" type="button" value="暂停" onclick="stop()" />
		<input id="btn2" type="button" value="开始" onclick="start()" />
		<script type="text/javascript">
			//每间隔1秒执行dowork函数
			var id=window.setInterval("doWork()",1000);
			
			function doWork(){
				//document.write("好好学习，不能睡觉<br/>");
				//console.log("好好学习，不能睡觉<br/>");
				var d=new Date();
				var year=d.getFullYear();
				var month=d.getMonth()+1;
				var day=d.getDate();
				var hour=d.getHours();
				var min=d.getMinutes();
				var sec=d.getSeconds();
				document.getElementById("myclock").innerText=year+"年"+month+"月"+day+"日"+hour+":"+min+":"+sec;
				
			}
			document.getElementById("btn2").disabled=true;
			function stop(){
				
	 //clearInterval() 方法用于停止 setInterval() 方法执行的函数代码
				clearInterval(id);
				document.getElementById("btn2").disabled=false;
				document.getElementById("btn1").disabled=true;
			}
			
			function start(){
				id=window.setInterval("doWork()",1000);
				document.getElementById("btn2").disabled=true;
				document.getElementById("btn1").disabled=false;
			}
			
			
//			while(true){
//				document.write("好好学习，不能睡觉<br/>");
//			}
		</script>
	</body>
</html>
```

（3）延迟执行

​	window.setTimeout("*javascript 函数*",*毫秒数*);

​	第二个参数指示从当前起多少毫秒后执行第一个参数

```
<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title>延迟执行</title>
	</head>
	<body>
		
		<script type="text/javascript">
			myVar=window.setTimeout("doWork()",5000);
			function doWork(){
				alert("好好学习，天天向上");
			}
			//clearTimeout() 方法用于停止执行setTimeout()方法的函数代码
			clearTimeout(myVar);
		</script>
		
	</body>
</html>
```

##### 3.6  JavaScript面试题

```
1、列举Java和JavaScript之间的区别？
Java是一门十分完整、成熟的编程语言。相比之下，JavaScript是一个可以被引入HTML页面的编程语言。这两种语言并不完全相互依赖，而是针对不同的意图而设计的。 Java是一种面向对象编程（OOPS）或结构化编程语言，类似的如C ++或C，而JavaScript是客户端脚本语言，它被称为非结构化编程。
解释JavaScript中定时器的工作？如果有，也可以说明使用定时器的缺点？
定时器用于在设定的时间执行一段代码，或者在给定的时间间隔内重复该代码。这通过使用函数setTimeout，setInterval和clearInterval来完成。
setTimeout（function，delay）函数用于启动在所述延迟之后调用特定功能的定时器。
setInterval（function，delay）函数用于在提到的延迟中重复执行给定的功能，只有在取消时才停止。
clearInterval（id）函数指示定时器停止。
定时器在一个线程内运行，因此事件可能需要排队等待执行。
2、什么是===运算符？
===被称为严格等式运算符，当两个操作数具有相同的值而没有任何类型转换时，该运算符返回true。
3、Void（0）怎么用？
Void（0）用于防止页面刷新，并在调用时传递参数“zero”。
Void（0）用于调用另一种方法而不刷新页面。
4、JavaScript中不同类型的错误有几种？
有三种类型的错误：
Load time errors：该错误发生于加载网页时，例如出现语法错误等状况，称为加载时间错误，并且会动态生成错误。
Run time errors：由于在HTML语言中滥用命令而导致的错误。
Logical Errors：这是由于在具有不同操作的函数上执行了错误逻辑而发生的错误。
```

#### 第四章 DAO模式，连接池,DBUtils实用工具类

##### 4.1 DAO模式

（1）概念：DAO(Database Access Object 数据库访问对象)，为了降低耦合性，提出了DAO封装数据库操作的设计模式。它可以实现业务逻辑与数据库访问相分离。相对来说，数据库是比较稳定的，其中DAO组件依赖于数据库系统，提供数据库访问的接口。隔离了不同的数据库实现。

​	  工具类封装：由于JDBC多个地方都需要使用数据库连接和释放，所以在使用DAO模式时可以把这类功能封装到工具类中DbUtils

（2）DAO模式的组成部分：

​	（2.1） DAO接口（主要 添加 修改 更新 删除方法）

​	（2.2） DAO实现类

​	（2.3） 实体类  （domain、beans、entity、pojo、model）

​		--作用：用在数据访问代码和业务逻辑代码之间通过实体类来传输数据

​		--实体类特征：

​			◦属性一般使用private修饰

​			◦提供public修饰的getter/setter方法

​			◦实体类提供无参构造方法，根据业务提供有参构造

​			◦实现java.io.Serializable接口，支持序列化机制

​		--设计的包名：domain 存放实体类    utils  存放工具类   dao  存放接口

​					  dao.impl  存放实现类

​	（2.4） 工具类：数据库连接和关闭工具

##### 4.2 DAO案例（JDBC）

​	domain 实体类    utils 工具类   dao  接口    dao.impl  实现类

```
/**
 * 数据库工具类封装：utils工具类建在包com.qf.utils下
 * 1 注册驱动（一次）
 * 2 获取连接
 * 3 释放资源
 * 4 执行命令
 */
public class DbUtils {
	private static String driver;//驱动名称  com.mysql.jdbc.Driver
	private static String url;//连接字符串jdbc:mysql://localhost:3306/school;
	private static String username;//root
	private static String password;//123
	
	static{	
		try {
			
/*1注册驱动，通过properties文件加载driver，url，username，password*/
			Properties properties=new Properties();  
	//加载的文件是src下面的文件，实质上应该加载bin下面的文件
	//FileInputStream fis=new FileInputStream("src\\database.properties");
			//1通过类加载器获取流(直接加载bin目录中的文件)
			InputStream is=DbUtils.class.getClassLoader().getResourceAsStream("database.properties");
			properties.load(is);
			is.close();
			
			driver=properties.getProperty("driver");
			url=properties.getProperty("url");
			username=properties.getProperty("user");
			password=properties.getProperty("password");
			
			Class.forName(driver);
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
	
/*获取连接*/
	public static Connection getConnection(){
		try {
			return DriverManager.getConnection(url, username, password);
		} catch (SQLException e) {
			e.printStackTrace();
		}
		return null;
	}
	
/*关闭*/
	public static void closeAll(ResultSet rs,Statement stat,Connection conn){
		if(rs!=null){
			try {
				rs.close();
			} catch (SQLException e) {
				e.printStackTrace();
			}
		}
		if(stat!=null){
			try {
				stat.close();
			} catch (SQLException e) {
				e.printStackTrace();
			}
		}
		if(conn!=null){
			try {
				conn.close();
			} catch (SQLException e) {
				e.printStackTrace();
			}
		}
	}

/*执行命令 添加  删除  修改 */
    //添加sql: insert into emp (....) values( ?,?,?) 
	public static int executeUpdate(String sql, Object... params){		
		Connection conn=null;//1获取连接
		PreparedStatement pstat=null;//2创建命令对象
		try {
			conn=getConnection();
			pstat=conn.prepareStatement(sql);
			for(int i=0;i<params.length;i++){
				pstat.setObject(i+1, params[i]); //pstat.setInt(1,empno)
			}
			return pstat.executeUpdate();//3执行
		} catch (Exception e) {
		}finally {
			closeAll(null, pstat, conn);
		}
		return 0;
	}
}

/**
 * database.properties文件，把数据库连接信息封装到Properties文件中，方便修改
 */
#驱动名称
driver=com.mysql.jdbc.Driver
#连接字符串
url=jdbc:mysql://localhost:3306/school
#用户名
user=root
#密码
password=root

/**
 * 接口：dao类，建在包com.qf.dao下
 * 添加
 * 删除
 * 查询
 * 修改
 */
public interface EmployeeDao {
	 List<Employee> findAll();//1查询所有
	 Employee findByNo(int empno);//根据编号查询员工
	 void update(Employee e);//2更新
	 void delete(int empno);//3删除
	 void add(Employee e); //4添加	
}

/**
 * 实现类：建在包com.qf.dao.impl 下
 */
public class EmployeeDaoImpl implements EmployeeDao{//实现接口
	
	//查询所有
	public List<Employee> findAll() {
		ArrayList<Employee> employees=new ArrayList<Employee>();
		Connection conn=null;//1获取连接
		PreparedStatement pstat=null;
		ResultSet rs=null;
		try {
			conn=DbUtils.getConnection();
			pstat=conn.prepareStatement("select * from emp;");
			rs=pstat.executeQuery();
			while(rs.next()){
				int empno=rs.getInt("empno");
				String ename=rs.getString("ename");
				String job=rs.getString("job");
				int mgr=rs.getInt("mgr");
				Date date=rs.getDate("hiredate");
				double sal=rs.getDouble("sal");
				double comm=rs.getDouble("comm");
				int deptno=rs.getInt("deptno");
				
				Employee employee=new Employee(empno, ename, job, mgr, date, sal, comm, deptno);
				employees.add(employee);
			}
			return employees;
		} catch (Exception e) {
			throw new RuntimeException("查询emp失败");
		} finally {
			DbUtils.closeAll(rs, pstat, conn);
		}
		
	}

	//更新
	public void update(Employee e) {
		Object[] params={e.getEname(),e.getJob(),e.getMgr(),e.getHiredate(),e.getSal(),e.getComm(),e.getDeptno(),e.getEmpno()};
		DbUtils.executeUpdate("update emp set ename=?,job=?,mgr=?,hiredate=?,sal=?,comm=?,deptno=? where empno=?", params);
	}
	
	//删除
	public void delete(int empno) {
		DbUtils.executeUpdate("delete from emp where empno=?", empno);
	}

	//添加
	public void add(Employee e) {
		Object[] params={e.getEmpno(),e.getEname(),e.getJob(),e.getMgr(),e.getHiredate(),e.getSal(),e.getComm(),e.getDeptno()};
		DbUtils.executeUpdate("insert into emp values(?,?,?,?,?,?,?,?)", params);
	}

	//根据员工编号查找
	public Employee findByNo(int empno) {
		Connection conn=null;//1获取连接
		PreparedStatement pstat=null;
		ResultSet rs=null;
		try {
			conn=DbUtils.getConnection();
			pstat=conn.prepareStatement("select * from emp where empno=?;");
			pstat.setInt(1, empno);
			rs=pstat.executeQuery();
			Employee employee=null;
			if(rs.next()){
				String ename=rs.getString("ename");
				String job=rs.getString("job");
				int mgr=rs.getInt("mgr");
				Date date=rs.getDate("hiredate");
				double sal=rs.getDouble("sal");
				double comm=rs.getDouble("comm");
				int deptno=rs.getInt("deptno");
				
				employee=new Employee(empno, ename, job, mgr, date, sal, comm, deptno);
			
			}
			return employee;
		} catch (Exception e) {
			throw new RuntimeException("查询emp失败");
		} finally {
			DbUtils.closeAll(rs, pstat, conn);
		}
	}
}
/**
 * 员工类
 * 实体类domain类：建在com.qf.domain包下
 */
//只有实现Serializable接口，才能支持序列化
public class Employee implements Serializable {
	private static final long serialVersionUID = 373910607014836778L;
	private int empno;
	private String ename;
	private String job;
	private int mgr;
	private Date hiredate;
	private double sal;
	private double comm;
	private int deptno;
	
	public Employee() {
	}
	public Employee(int empno, String ename, String job, int mgr, Date hiredate, double sal, double comm, int deptno) {
		super();
		this.empno = empno;
		this.ename = ename;
		this.job = job;
		this.mgr = mgr;
		this.hiredate = hiredate;
		this.sal = sal;
		this.comm = comm;
		this.deptno = deptno;
	}

	public int getEmpno() {
		return empno;
	}

	public void setEmpno(int empno) {
		this.empno = empno;
	}

	//······此处省略set，get函数设定
	
	public String toString() {
		return "Employee [empno=" + empno + ", ename=" + ename + ", job=" + job + ", mgr=" + mgr + ", hiredate="
				+ hiredate + ", sal=" + sal + ", comm=" + comm + ", deptno=" + deptno + "]";
	}	
}
/**
*Test类
*/
public class Test {
	public static void main(String[] args) {
		System.out.println("-------欢迎进入xxx系统----------");
		System.out.println("请选择操作 : 1 查询  2添加 3更新 4删除");
		Scanner input = new Scanner(System.in);
		int choice = input.nextInt();
		EmployeeDao employeeDao=new EmployeeDaoImpl();
		switch (choice) {
		case 1:
				List<Employee> employees=employeeDao.findAll();
				for (Employee e : employees) {
					System.out.println(e.toString());
				}
			break;
		case 2:
			System.out.println("请输入员工编号");
			int empno=input.nextInt();
			System.out.println("请输入员工姓名");
			String ename=input.next();
			System.out.println("请输入员工工作");
			String job=input.next();
			System.out.println("请输入员工经理编号");
			int mgr=input.nextInt();
			System.out.println("请输入员工入职时间");
			String hiredate=input.next();
			System.out.println("请输入员工工资");
			double sal=input.nextDouble();
			System.out.println("请输入员工奖金");
			double comm=input.nextDouble();
			System.out.println("请输入员工部门");
			int deptno=input.nextInt();
			
			//1封装成一个Employee对象
			SimpleDateFormat sdf=new SimpleDateFormat("yyyy-MM-dd");
			try {
				Employee e=new Employee(empno, ename, job, mgr,sdf.parse(hiredate), sal, comm, deptno);
				employeeDao.add(e);
				System.out.println("添加成功");
			} catch (ParseException e1) {
				e1.printStackTrace();
			}				
			break;
		
		case 3:
			System.out.println("请输入要更新的员工编号:");
			int eno=input.nextInt();
			Employee employee=employeeDao.findByNo(eno);
			if(employee!=null){
				System.out.println("请输入新的名字");
				String newname=input.next();
				employee.setEname(newname);
				//修改数据库
				employeeDao.update(employee);
				System.out.println("修改成功");	
			}else{
				System.out.println("没有要修改的员工");
			}
			
			break;
		case 4:
			System.out.println("请输入要删除的编号");
			int no=input.nextInt();
			employeeDao.delete(no);
			System.out.println("删除成功");
			break;
			
		default:
			break;
		}
	}
}
```



##### 4.3连接池

（1）引入连接池：用户每次请求都需要向数据库获得链接，而数据库创建连接通常需要消耗相对较大的资源，创建时间也较长。假设网站一天10万访问量，数据库服务器就需要创建10万次连接，极大的浪费数据库的资源，并且极易造成数据库服务器内存溢出、拓机。所以引入连接池可以解决该问题。Java为连接池实现提供了一个规范(接口),规范的写法,我们需要实现DataSource接口!

（1.1）自定义连接池

```
/**
 * 自定义连接池
 */
public class MyPool implements DataSource { 
	//定义集合作为池,加上锁以使得线程安全，连接池需要频繁插入删除，故采用LinkedList
	private static List<Connection> connections=Collections.synchronizedList(new LinkedList<Connection>());
	static{
		try {
			Properties properties = new Properties();
			//1通过类加载器获取流(直接加载bin目录中的文件)
			InputStream is = DbUtils.class.getClassLoader().getResourceAsStream("database.properties");
			properties.load(is);
			is.close();
			String driver = properties.getProperty("driver");
			String url = properties.getProperty("url");
			String username = properties.getProperty("user");
			String password = properties.getProperty("password");
			Class.forName(driver);
			
			//获取连接
			for(int i=0;i<5;i++){
				Connection conn=DriverManager.getConnection(url, username, password);
				connections.add(conn);
				System.out.println(conn.hashCode());
			}		
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
	
	public Connection getConnection() throws SQLException {
		if(connections.size()>0){
			Connection connection=connections.remove(0);
			System.out.println("还剩："+connections.size());
			return connection;
		}
		return null;
	}
	
	public void release(Connection conn){
		connections.add(conn);
		System.out.println("------------还剩："+connections.size());
	}
	
	public PrintWriter getLogWriter() throws SQLException {
		return null;
	}

	public void setLogWriter(PrintWriter out) throws SQLException {
		
	}

	public void setLoginTimeout(int seconds) throws SQLException {
		
	}

	public int getLoginTimeout() throws SQLException {
		return 0;
	}

	public Logger getParentLogger() throws SQLFeatureNotSupportedException {
		return null;
	}

	
	public <T> T unwrap(Class<T> iface) throws SQLException {
		return null;
	}

	public boolean isWrapperFor(Class<?> iface) throws SQLException {
		return false;
	}

	public Connection getConnection(String username, String password) throws SQLException {
		return null;
	}
}

/**
*Test
*/
public class TestPool {
	public static void main(String[] args) {
		MyPool myPool=new MyPool();
		for (int i = 0; i < 5; i++) {
			try {
				Connection conn=myPool.getConnection();
				System.out.println(conn.getClass().getName());
				System.out.println("使用:"+conn.hashCode()+"..."+conn.getClass().getName());
				myPool.release(conn);
				
			} catch (SQLException e) {
				e.printStackTrace();
			}
		}
	}
}
```

（2）DBCP连接池

（2.1）概述：DBCP(DataBase connection pool),[数据库连接池]，单独使用dbcp需要2个包(加载到工程新建bin目录下)：commons-dbcp.jar, commons-pool.jar，由于建立数据库连接是一个非常耗时的行为，所以通过连接池预先同数据库建立一些连接，放在内存中，应用程序需要建立数据库连接时直接到连接池中申请一个就行，用完后再放回去。

（2.2）DBCP连接池的使用：创建JavaWeb项目------------->导入相应jar包（mysql驱动包; commons-dbcp.jar;   commons-pool.jar; logging.jar 日志支持）------->硬编码(即在代码中添加配置)或者软编码（即添加配置文件,这样就不需要每次代码中添加配合!）使用DBCP(软硬编码的区别实质就是有无properties文件)

（2.3）DBCP连接池

```
/**
*硬编码使用DBCP
*/
public void testHard() throws SQLException{
		//TODO 硬编码 使用DBCP连接池子
		BasicDataSource source = new BasicDataSource();
		//设置连接的信息  
		source.setDriverClassName("com.mysql.jdbc.Driver");
		source.setUrl("jdbc:mysql://localhost:3306/day2");
		source.setUsername("root");
		source.setPassword("111");
	
		Connection connection = source.getConnection();
		String sql = "select * from student";
		Statement createStatement = connection.createStatement();
		ResultSet executeQuery = createStatement.executeQuery(sql);
		while (executeQuery.next()) {
			System.out.println(executeQuery.getString(2));
		}
		connection.close(); //回收
	}
/**
*软编码使用DBCP
*/
public void testSoft() throws Exception{
		//TODO DBCP软编码连接池子使用
		BasicDataSourceFactory factory = new BasicDataSourceFactory();
		Properties properties = new  Properties();
		//配置文件添加到properties对象中  javase
		InputStream is = Test2.class.getClassLoader().getResourceAsStream("dbcp.properties");
		properties.load(is);
		//生成连接池子  需要配置文件
		DataSource source = factory.createDataSource(properties);
        Connection connection = source.getConnection();
		String sql = "select * from student";
		Statement createStatement = connection.createStatement();
		ResultSet executeQuery = createStatement.executeQuery(sql);
		while (executeQuery.next()) {
			System.out.println(executeQuery.getString(2));
		}
		connection.close(); //回收
	}

/**
*dbcp.properties文件配置初始化（方便修改参数）；该文件放在src下
*/
#连接设置
driverClassName=com.mysql.jdbc.Driver
url=jdbc:mysql://localhost:3306/school
username=root
password=root
#<!-- 初始化连接 -->
initialSize=10
#最大连接数量
maxTotal=50
#<!-- 最大空闲连接 -->
maxIdle=20
#<!-- 最小空闲连接 -->
minIdle=5
#<!-- 超时等待时间以毫秒为单位 6000毫秒/1000等于60秒 -->
maxWaitMillis=5000
```

（3）C3P0连接池

（3.1）概述：C3P0是一个开源的JDBC连接池，它实现了数据源和JNDI绑定，支持JDBC3规范和JDBC2的标准扩展。目前使用它的开源项目有Hibernate，Spring等。

（3.2）c3p0与dbcp区别：

​	     a. dbcp没有自动回收空闲连接的功能；c3p0有自动回收空闲连接功能

​	     b. dbcp需要手动设置配置文件; c3p0不需要手动设置

（3.3）使用步骤：创建项目-->导入jar包（  c3p0-0.9.1.2.jar；mysql驱动包）-->添加配置文件（c3p0是在外部添加配置文件,工具直接进行应用,因为直接引用,所以要求固定的命名和文件位置:位置是添加在src文件夹下，文件名是c3p0-config.xml/c3p0-config.properties）；如果必须要切换命名配置可以在创建c3p0连接池的时候填入命名即可!

（3.4） C3P0连接池

```
public class C3p0Test {
	public static void main(String[] args) {
		//1创建连接池；//默认 bin 找 c3p0-config.xml  c3p0-config.properties
		ComboPooledDataSource pool=new ComboPooledDataSource("myc3p0");
		//2使用
		for(int i=0;i<30;i++){
			try {
				Connection conn=pool.getConnection();
				System.out.println(conn.getClass().getName());
				conn.close();//释放到连接池中
			} catch (SQLException e) {
				e.printStackTrace();
			}
		}
	}
}
```

##### 4.4 Druid连接池

（1）概述：Druid 是阿里贡献的、目前比较流行的高性能的、分布式列存储的OLAP框架(具体来说是MOLAP)。它有如下几个特点：亚秒级查询：druid提供了快速的聚合能力以及亚秒级的OLAP查询能力；实时数据注入：支持流数据的注入，并提供了数据的事件驱动，保证在实时和离线环境下事件的实效性和统一性；可扩展的PB级存储： druid集群可以很方便的扩容到PB的数据量，每秒百万级别的数据注入。即便在加大数据规模的情况下，也能保证时其效性；多环境部署：  druid既可以运行在商业的硬件上，也可以运行在云上。它可以从多种数据系统中注入数据，包括hadoop，spark，kafka，storm和samza等；丰富的社区： druid拥有丰富的社区，供大家学习

（2）步骤：导入jar包-->编写工具类-->测试

##### 4.5 Druid连接池案例

```
/*
 * 使用druid连接池
 */
public class DruidTest {
	public static void main(String[] args) {
		//1创建连接池
		DruidDataSource dataSource=new DruidDataSource();
		//2调用方法设置
		dataSource.setDriverClassName("com.mysql.jdbc.Driver");
		dataSource.setUrl("jdbc:mysql://localhost:3306/school");
		dataSource.setUsername("root");
		dataSource.setPassword("root");
		//3其他设置
		//3.1初始大小,池子数
		dataSource.setInitialSize(10);
		dataSource.setMaxActive(30);
		dataSource.setMinIdle(5);
		dataSource.setMaxWait(10000);
		
		//4使用
		for(int i=0;i<30;i++){
			try {
				Connection con=dataSource.getConnection();
				System.out.println(con.getClass().getName());
				con.close();
			} catch (SQLException e) {
				e.printStackTrace();
			}
		}	
	}
}

/*
 * 添加properties文件后使用druid连接池
 */
public class DruidTest2 {
	public static void main(String[] args) {
		//1创建连接池
		DruidDataSource dataSource=new DruidDataSource();
		
		try {
			Properties properties=new Properties();
			InputStream is=DruidTest2.class.getClassLoader().getResourceAsStream("database.properties");
			properties.load(is);
			is.close();
			dataSource.setDriverClassName(properties.getProperty("driverClassName"));
			dataSource.setUrl(properties.getProperty("url"));
			dataSource.setUsername(properties.getProperty("username"));
			dataSource.setPassword(properties.getProperty("password"));
					dataSource.setInitialSize(Integer.parseInt(properties.getProperty("initialSize")));
			dataSource.setMaxActive(Integer.parseInt(properties.getProperty("maxActive")));
					
		} catch (IOException e1) {
			e1.printStackTrace();
		}
	    
		//4使用
		for(int i=0;i<30;i++){
			try {
				Connection con=dataSource.getConnection();
				System.out.println(con.getClass().getName());
				con.close();
			} catch (SQLException e) {
				e.printStackTrace();
			}	
		}	
	}
}
/*
 * database.properties文件，添加属性配置
 */
driverClassName=com.mysql.jdbc.Driver
url=jdbc:mysql://localhost:3306/school
username=root
password=root

initialSize=10
maxActive=30
minIdle=5
maxWait=10000
```

##### 4.6 DBUtils使用

（1）概述：Commons DbUtils是[Apache](https://baike.baidu.com/item/Apache/8512995)组织提供的一个对[JDBC](https://baike.baidu.com/item/JDBC)进行简单封装的开源工具类库，使用它能够简化[JDBC](https://baike.baidu.com/item/JDBC)应用程序的开发，同时也不会影响程序的性能。

（2）优点：DBUtils是java编程中的数据库操作实用工具，小巧简单实用，

​	a.对于数据表的读操作，可以把结果转换成List，Array，Set等java集合，便于程序员操作。

​	b.对于数据表的写操作，也变得很简单（只需写sql语句）。

（3）DBUtils包括主要类：

​	 	DbUtils类：启动类

​		ResultSetHandler接口：转换类型接口

​		--ArrayHandler类：实现类，把记录转化成数组

​		--BeanHandler类：实现类,把记录转成对象。

​		--BeanListHandler类：实现类，把记录转化成List，使记录为JavaBean类型的对象

QueryRunner类：执行SQL语句的类

（4）使用准备：创建项目-->导入jar包 工具类 配置文件( commons-dbutils-1.6.jar;druid连接池; database.properties配置文件; druid工具类；mysql jar包)

##### 4.7 DBUtil案例

```

/**
 * 使用DbUtils工具包
 */
public class Demo1 {
	public static void main(String[] args) {	
		//1创建QueryRunner
		QueryRunner queryRunner=new QueryRunner(DruidUtils.getDataSource());
		
		try {
			System.out.println("-----------------ArrayHandler----------------");
			//2查询一条数据 把数据变成一个数组
			Object[] objects=queryRunner.query("select * from emp where empno=1234",new ArrayHandler());
		
			for (Object o : objects) {
				System.out.println(o);
			}
			System.out.println("--------------------ArrayListHandler--------------------");
			//3查询多个条数据
			List<Object[]> list=queryRunner.query("select * from emp", new ArrayListHandler());
			for (Object[] objects2 : list) {
				System.out.println(Arrays.toString(objects2));
			}
			//4查询员工的所有名字，把所有名字放入数组
			System.out.println("-------------------ColumnListHandler-------------------");
			List<String> nameslist=queryRunner.query("select * from emp;", new ColumnListHandler<String>(2));
			for (String string : nameslist) {
				System.out.println(string);
			}
			//5查询一条数据，把输入放入map集合，用字段名作为key，数据作为value
			System.out.println("-------------------MapHandler-------------------");
			Map<String, Object> map=queryRunner.query("select * from emp where empno=1234", new MapHandler());
			for(Map.Entry<String, Object>  entry: map.entrySet()){
				System.out.println(entry.getKey()+"....."+entry.getValue());
			}
			
			//6 查询数据个数
			System.out.println("------------------ScalarHandler----------------------");
			
			Long integer=queryRunner.query("select count(*) from emp", new ScalarHandler<Long>());
			System.out.println(integer);
			
			//7查询一条记录，把数据封装成Employee对象 重点
			System.out.println("-----------------------BeanHandler-----------------------");
			Employee employee=queryRunner.query("select * from emp where empno=1234", new BeanHandler<Employee>(Employee.class));
			System.out.println(employee.toString());
			
			//8查询全部数据，把数据封装成对象并且放入集合中
			System.out.println("-----------------------BeanListHandler-----------------------");
			List<Employee> employees=queryRunner.query("select * from emp", new BeanListHandler<Employee>(Employee.class));
			for (Employee employee2 : employees) {
				System.out.println(employee2.toString());
			}
			
			int result=queryRunner.update("delete from emp where empno=?",1234);
	
			if(result>0){
				System.out.println("删除成功");
			}	
		} catch (SQLException e) {
			e.printStackTrace();
		}
	}
}

/**
 * DruidUtils类建立
 */
public class DruidUtils {
	
	private static DruidDataSource dataSource;
	static{
		//1加载集合
		try {
			Properties properties=new Properties();
			InputStream is=DruidUtils.class.getClassLoader().getResourceAsStream("database.properties");
			properties.load(is);
			is.close();
			dataSource=(DruidDataSource) DruidDataSourceFactory.createDataSource(properties);
		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
	}
	
	public static Connection getConnection(){
		try {
			return dataSource.getConnection();
		} catch (SQLException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return null;
	}
	
	public static DataSource getDataSource(){
		return dataSource;
	}

	public static void closeAll(ResultSet rs,Statement stat,Connection connection){
		if(rs!=null){
			try {
				rs.close();
			} catch (SQLException e) {
				e.printStackTrace();
			}
		}
		if(stat!=null){
			try {
				stat.close();
			} catch (SQLException e) {
				e.printStackTrace();
			}
		}
		if(connection!=null){
			try {
				connection.close();
			} catch (SQLException e) {
				e.printStackTrace();
			}
		}	
	}
}
/**
 * 员工类
 * 实体类
 */
public class Employee implements Serializable {
	private static final long serialVersionUID = 373910607014836778L;
	private int empno;
	private String ename;
	private String job;
	private int mgr;
	private Date hiredate;
	private double sal;
	private double comm;
	private int deptno;
	
	public Employee() {
		
	}

	public Employee(int empno, String ename, String job, int mgr, Date hiredate, double sal, double comm, int deptno) {
		super();
		this.empno = empno;
		this.ename = ename;
		this.job = job;
		this.mgr = mgr;
		this.hiredate = hiredate;
		this.sal = sal;
		this.comm = comm;
		this.deptno = deptno;
	}

	public int getEmpno() {
		return empno;
	}

	public void setEmpno(int empno) {
		this.empno = empno;
	}

	//此处省略·····set，get函数
	
	public String toString() {
		return "Employee [empno=" + empno + ", ename=" + ename + ", job=" + job + ", mgr=" + mgr + ", hiredate="
				+ hiredate + ", sal=" + sal + ", comm=" + comm + ", deptno=" + deptno + "]";
	}	
}
/**
* properties文件
*/
driverClassName=com.mysql.jdbc.Driver
url=jdbc:mysql://localhost:3306/school
username=root
password=root

initialSize=10
maxActive=30
minIdle=5
maxWait=10000
```

#### 第五章 HTML

##### 5.1 html简介

html文件在Java项目中操作时，一般建于WebContent文件下

（1）概述：html全称：Hyper Text Markup Language(超文本标记语言)
超级文本标记语言是标准通用标记语言下的一个应用，也是一种规范，一种标准，它通过标记符号来标记要显示的网页中的各个部分。网页文件本身是一种文本文件，通过在文本文件中添加标记符，可以告诉浏览器如何显示其中的内容（如：文字如何处理，画面如何安排，图片如何显示等）。浏览器按顺序阅读网页文件，然后根据标记符解释和显示其标记的内容，对书写出错的标记将不指出其错误，且不停止其解释执行过程，编制者只能通过显示效果来分析出错原因和出错部位。但需要注意的是，对于不同的浏览器，对同一标记符可能会有不完全相同的解释，因而可能会有不同的显示效果   

（2）特点：超级文本标记语言文档制作不是很复杂，但功能强大，支持不同数据格式的文件嵌入，这也是万维网（WWW）盛行的原因之一，其主要特点如下：
简易性：超级文本标记语言版本升级采用超集方式，从而更加灵活方便。
可扩展性：超级文本标记语言的广泛应用带来了加强功能，增加标识符等要求，超级文本标记语言采取子类元素的方式，为系统扩展带来保证。
平台无关性：虽然个人计算机大行其道，但使用MAC等其他机器的大有人在，超级文本标记语言可以使用在广泛的平台上，这也是万维网（WWW）盛行的另一个原因。
通用性：另外，HTML是网络的通用语言,一种简单、通用的全置标记语言。它允许网页制作人建立文本与图片相结合的复杂页面，这些页面可以被网上任何其他人浏览到，无论使用的是什么类型的电脑或浏览器。 

##### 5.2 html语法规则与标签

（1）html结构：包括head  body；每个标签通常都有属性，属性可以直接在定义标签时添加，格式:属性＝‘属性值’(多个属性之间空格隔开)，多个属性空格加分号加空格隔开：<body bgcolor="blue" ; background="img/002.png">；标签不区分大小写,建议小写。

（2）标签：

（2.1）结构标签（文件标签）     

```
<!DOCTYPE html>
<html>：根标签
  <head>
    <!--设置页面的字符集编码 -->
    <meta charset="utf-8" />
    <!--设置页面的标题 -->
    <title>我的第一个网页</title>：页面的标题	
  </head>
  <body bgcolor="blue" ; background="img/002.png">：内容+背景色+背景图片;注意空格
    <!--需要展示的信息-->
    <font color="red">欢迎访问我的网站!!!!</font>：文本加文本颜色设置为红
  </body>
</html>

注：
	颜色的表示方式：                        
    	第一种方式：red green blue	             
    	第二种方式：#000000  #ffffff  #325687   #377405
    <font></font> 的属性： 
    	size:设置字体大小 color:设置蚊子颜色 face:设置字体 
```

（2.2）排版标签

```
<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title>排版标签</title>
	</head>
	
	<body>
		<!--(注释标签)注释内容-->
		<!--(换行标签)<br/>-->
		春晓<br/>
		春眠不觉晓<br/>
		处处闻啼鸟<br/>
		夜来风雨声<br/>
		花落知多少<br/>
		<!--(段落标签paragraph)<p>文本文字</p> 表示一段内容，自动换行，默认有间距
			(段落排列属性)align:对齐方式  left靠左  center居中 right靠右
		-->
		<p align="center">静夜思</p>
	    <!--（水平线horizon）<hr/> （长度width可以用像素或者百分比表示）
	     (水平线属性)长度width:10% 宽度size：10px 粗细color 颜色 align 对齐方式-->
			<hr  width="90%" size="5" color="bisque" align="center"/>
		<p align="center">床前明月光</p>
		<p align="center">疑是地上霜</p>
		<p align="center">举头望明月</p>
		<p align="center">低头思故乡</p>
	</body>

</html>
```

   （2.3）块标签(容器)和文字标签(标题标签)

```
<!DOCTYPE html>
<html>
	
	<head>
		<meta charset="UTF-8">
		<title>块标签(容器)和文字标签(标题标签)</title>
	</head>
	
	<body>
		
		<!--div的使用  实现网页的布局   独立占一行-->
		<div style="height: 200px; border: 1px solid red;">头部内容
			<!--span 范围标签  和其他行在一行显示-->
			<span>
				<font color="red" size="5" face="黑体">欢迎来到我的小屋</font>
			</span>
			<span>有问题及时反馈</span>
		</div>
		<div style="height: 500px; border: 1px solid red;">网页主要内容</div>
		<div style="height: 100px; border: 1px solid red;">底部内容</div>
		
		
		<!--标题标签-->
		<h1>一级标题</h1>
		<h2>二级标题</h2>
		<h3>三级标题</h3>
		<h4>四级标题</h4>
		<h5>五级标题</h5>
		<h6>六级标题</h6>
		<!--语义化-->
		<h2>登鹳雀楼</h2>
		<p>白日依山尽</p>
		<p>黄河入海流</p>
		<p>欲穷千里目</p>
		<p>更上一层楼</p>	
	</body>

</html>
```

（2.4）列表标签(清单标签)

```
<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title>列表标签</title>
	</head>
	
	<body>
		<h1>无序列表</h1>
		<!--(unorder list 无序列表) <ul></ul> 
			(列表项)<li></li> 
			(属性)(type属性三个值)：circle空心圆，disc 实心圆(默认) square方框 
		-->
		<ul type="square">
			<li>苹果</li>
			<li>三星</li>
			<li>小米</li>
			<li>华为</li>
		</ul>
		
		<h1>有序列表</h1>
		<!--（order list 有序列表）<ol></ol> 
			 (列表项)<li></li>
			 (属性)(type属性)：1  a  A  i  I （数字、字母、罗马数字）	
		-->
		<ol type="1">
			<li>苹果</li>
			<li>菠萝</li>
			<li>香蕉</li>
			<li>榴莲</li>		
		</ol>
		
		<h1>定义列表</h1>
		<!--   <dl></dl>  defination  list 
			   <dt></dt>  defination title 
			   <dd></dd>defination description
		-->
		<dl>
			<dt>苹果</dt>
			<dd>苹果是一种水果，富含维生素C，美容养颜，吃了长寿....</dd>
		</dl>
		
		<!--嵌套ul-->
		<h1>嵌套列表</h1>
		<ul>
			<li>咖啡</li>
			<li>茶
				<ul>
					<li>红茶</li>
					<li>绿茶
						<ul>
							<li>中国茶</li>
							<li>非洲茶</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>牛奶</li>
</ul>
	</body>
</html>
```

（2.5） 图片标签

```
<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title>图片标签</title>
	</head>
	
	<body>
		<!--图片标签  <img/>自关闭标签  
			 属性  src：图片地址
			       路径 ：相对路径   同一个网站中使用相对路径  img/002.jpg 
			              绝对路径   不同网站直接用绝对路径 
			                   	 d：/aaa/bb/001.jpg
			                   	 http://www.baidu.com/file/001.jpg
			       alt:替换文本,即图片无法显示的话会显示alt内容
			       title：悬停文本(指鼠标放到该位置会有改变)
			       width:宽度
			       height:高度
			       align: 和旁边文本的对齐方式  top 顶部对齐  middle居中对齐  bottom底部
				   border：边框
		-->
		<img src="img/002.png" alt="图片xxx" title="悬停文字" width="100" align="middle" border="2" hspace="10"/>我在图片后面
	</body>
</html>
```

（2.6） 链接标签：超链接可以是一个字，一个词，或者一组词，也可以是一幅图像，您可以点击这些内容来跳转到新的文档或者当前文档中的某个部分。

```
<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title>连接标签</title>
	</head>
	
	<body>
		<!--连接标签：<a><a/>实现页面之间的跳转
		属性：  href:连接的地址(跳转到外网需要添加协议)
			   target: _black 新建一个页面窗口
			   		   _selt 使用自身窗口
			   		   _parent 使用父窗口 
			   		   _top   使用顶部窗口
		-->
		<a href="http://www.baidu.com" target="_blank">去百度</a>
		<a href="http://www.12306.cn" target="_self">去哪儿</a>
		<a href="aaa.html">去aaa</a>
		<a href="bbb.html">去bbb</a>
		
		<a href="http://www.baidu.com">
			<img src="img/003.png" />
		</a>
	</body>
</html>
```

（2.7）表格标签：表格由 <table> 标签来定义。每个表格均有若干行（由 <tr> 标签定义），每行被分割为若干单元格（由 <td> 标签定义）。数据单元格可以包含文本、图片、列表、段落、表单、水平线、表格等等。

```
<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title>表格标签</title>
	</head>
	
	<body>
		<!--表格标签
			<table></table>   表格
				属性  width  宽度  height  高度
				  	  align： 表格的对齐方式 left center right
			 标签：<tr></tr> 行     <td></td> 列 （先定义行，再定义列）
			      属性 align  内容的水平对齐方式  left center right
			             valign 内容的垂直对齐方式   top  middle bottom	
		-->
		
		<!--两行两列-->
		<table border="1" width="300" height="200" align="center">
			<tr>
				<td align="center" valign="middle">第一行第一列</td>
				<td>第一行第二列</td>
			</tr>
			<tr>
				<td>第二行第一列</td>
				<td>第二行第二列</td>
			</tr>
		</table>
		
		<!--表头-->
		<tr>
				<th>学号</th>
				<th>姓名</th>
		</tr>
		
		<h1>跨列 colspan </h1>
		<table border="1" width="300" height="200">
			<tr>
				<td colspan="2" align="center">学生成绩</td>		
			</tr>
			<tr>
				<td>语文</td>
				<td>90</td>
			</tr>
			<tr>
				<td>数学</td>
				<td>100</td>
			</tr>
		</table>
		
		<h1>跨行 rowspan </h1>
		<table border="1" width="300" height="200">
			<tr>
				<td rowspan="2" ></td>
				<td></td>
				<td></td>
			</tr>
			<tr>
				
				<td></td>
				<td></td>
			</tr>
			<tr>
				<td rowspan="2"></td>
				<td></td>
				<td></td>
			</tr>
			<tr>
				<!--不用再定义跨行，再定义就出错了-->
				<td></td>
				<td></td>
			</tr>
		</table>
	</body>
</html>
```

（2.7）文本格式化标签：

```
<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title>文本格式化标签</title>
	</head>
	
	<body>
		正常内容
		<b>粗体文本</b>
		<big>大号字体</big>
		<em>斜体内容</em>
		<i>斜体内容</i>
		<strong>强调内容</strong>
		<sub>下标字</sub>
		<sup>上标字</sup> 5<sup>2</sup>
		<ins>插入内容</ins>
		<del>删除内容</del>	
	</body>

</html>
```

（2.8）表单标签：用于搜集不同类型的用户输入

（2.8.1）form标签

​	标签：<form></form>

​	属性：action表示动作，值为服务器的地址，把表单的数据提交到该地址上处理

​		    method:请求方式：get 和post

​		    enctype:表示是表单提交的类型

​		   		    默认值：application/x-www-form-urlencoded  普通表单

​		                    multipart/form-data  多部分表单(一般用于文件上传)

​	 get:1.提交的数据会放在URL之后，以?分割URL和传输数据，参数之间以&相连 path?name="张三"&password="123456"

​	        2.不安全

​		3.效率高

​         	4.get请求大小有限制，不同浏览器有不同，但是大约是2KB

 		使用情况：一般情况用于查询数据。

​	post:1.把提交的数据放在HTTP包的Body中

​		 2.安全可靠些

​		 3.效率低

​		 4.post请求大小理论上无限。

  		使用情况：一般用于插入删除修改等操作

（2.8.2）input标签

type: 以下为type可能要取的值： text 普通文本;         password  密码框   密文或者掩码 ;   radio 表示是单选，name必须一致表示同一组中只能选中一个( checked ="checked" 表示选中);                     checkbox  表示多选 ，name必须一致，表示同一组中可以选多个，返回值是个数组( checked ="checked" 表示选中)      file ：表示上传控件

以上具有输入性质的必须要有name属性,一开始写value表示是默认值(以后获取输入框的内容要根据name来取)	 

 以下按钮不具有输入性质，不需要name属性，但是按钮上的文字提示使用value属性

submit   提交                    reset   重置          image   图片按钮

以上所有input的属性： width 设置宽度，height 设置高度  border 设置边框、

hidden  表示隐藏域，该框的内容服务器需要，但是不想让用户知道(不想清楚的显示在界面上)

（2.8.3）select 元素:下拉列表

​	select标签表示多选,用option表示下拉列表项，用selected"表示选中该项

（2.8.4） textarea元素:(文本域)需要指定输入的区域位置大小： <textarea cols="100" rows="5">  表示5行100列的区域可以输入内容，该元素没有value属性

（2.8.5）案例书写：

```
<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title>用户注册</title>
	</head>
	
	<body>
		<h2>用户注册</h2>
		<form action="" method="post" enctype="multipart/form-data">
			昵称:<input type="text" name="username" /><br/>
			密码:<input type="password" name="pwd" /><br/>
			性别:<input type="radio" name="sex" value="男" checked="checked" />男
			<input type="radio" name="sex" value="女" />女<br/>
			爱好:<input type="checkbox" name="hobby" value="跑步" />跑步
				 <input type="checkbox" name="hobby" value="看电影" />看电影
				 <input type="checkbox" name="hobby" value="写代码" />编码<br />
			头像:<input type="file" name="touxiang" />	<br />
			
			城市:<select name="city">
					<option value="beijing">北京</option>
				<option value="shanghai">上海</option>
				<option value="hangzhou" selected="selected">杭州</option>
			</select><br />
			
			个人介绍:
			<textarea name="introduce" cols="20" rows="10" style="vertical-align: top;">本人男,年龄18,专业java,xxxxxxx		
			</textarea>
				 
			<input type="hidden" value="1234" name="empno" />
			<br/><input type="submit" value="注册" /><input type="reset" value="重置" />
				<input type="image" src="img/anniu.png" align="middle" />
		</form>
	</body>
</html>
```

（2.9）html框架标签：

​	通过使用框架，你可以在同一个浏览器窗口中显示不止一个页面。每份HTML文档称为一个框架，并且每个框架都独立于其他的框架。
​	使用框架的坏处：开发人员必须同时跟踪更多的HTML文档；很难打印整张页面

（2.9.1）frameset框架结构标签：定义如何将窗口分割为框架；  每个 frameset 定义了一系列行或列，rows/columns 的值规定了每行或每列占据屏幕的面积

（2.9.2）frame框架标签：frame 标签定义了放置在每个框架中的 HTML 文档。

（2.9.3）基本的注意事项：

```
1. 不能将 <body></body> 标签与 <frameset></frameset> 标签同时使用
2. 假如一个框架有可见边框，用户可以拖动边框来改变它的大小。为了避免这种情况发生，可以在   <frame> 标签中加入：noresize="noresize"。
```

（2.9.4）案例书写

```
<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title>首页</title>
	</head>
	
	<!--frameset框架集-->
将页面分为三个大部分,分别占150px,100px,*px(表示整个页面减去其余两个像素值);有边框
	<frameset rows="150,*,100" frameborder="yes">
		<!--顶部-->
		<frame src="1.html" name="top" noresize="noresize"/>
		<!--中间-->
		<frameset cols="20%,*">
			<frame src="2.html" name="left" />
			<frame src="3.html" name="right" />
		</frameset>
		<!--底部-->
		<frame src="4.html" name="bottom" noresize="noresize" />
	</frameset>
</html>

<!--用户登录-->
<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title>用户登录</title>
	</head>
	<body>
		<!--表单-->
		<form action="" method="post">
			用户名:<input type="text" name="username" /><br/>
			密码:<input type="password" name="pwd" /><br/>
			<input type="submit" value="提交" />			
		</form>
	</body>
</html>
```

（2.10）html的其它标签和特殊字符：

```
<!--其它标签-->
<!--该网页的关键字-->
<meta http-equiv="keywords" content="keyword1,keyword2,keyword3">
<!--该网页的描述-->
<meta http-equiv="description" content="this is my page">
<!--该网页的编码-->
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<!-- href：引入css文件的地址-->
<link rel="stylesheet" type="text/css" href="./styles.css">
<!--src：js的文件地址-->
<script type="text/javascript" src=""></script>

<!--特殊字符-->
&lt; 小于号  
&gt; 大于号
&amp; 与字符
&quot; 引号 
&reg; 己注册
&copy; 版权
&trade; 商标
&nbsp; 空格	
```

#### 第六章 CSS

##### 6.1 CSS简介

（1）概述：CSS (层叠样式表，英文全称：Cascading Style Sheets)是一种用来表现HTML（标准通用标记语言的一个应用）或XML（标准通用标记语言的一个子集）等文件样式的计算机语言。CSS不仅可以静态地修饰网页，还可以配合各种脚本语言动态地对网页各元素进行格式化
多个样式可以层层覆盖叠加，如果不同的css样式对同一html标签进行修饰，样式有冲突的应用优先级高的，不冲突的共同作用

（2）作用：

​	修饰美化html网页。

​	外部样式表可以提高代码复用性从而提高工作效率。

​	html内容与样式表现分离，便于后期维护。

（3）特点：

```
丰富的样式定义
	CSS提供了丰富的文档样式外观，以及设置文本和背景属性的能力；允许为任何元素创建边框，以及元素边框与其他元素间的距离，以及元素边框与元素内容间的距离；允许随意改变文本的大小写方式、修饰方式以及其他页面效果。

易于使用和修改
	CSS可以将样式定义在HTML元素的style属性中，也可以将其定义在HTML文档的header部分，也可以将样式声明在一个专门的CSS文件中，以供HTML页面引用。总之，CSS样式表可以将所有的样式声明统一存放，进行统一管理。
另外，可以将相同样式的元素进行归类，使用同一个样式进行定义，也可以将某个样式应用到所有同名的HTML标签中，也可以将一个CSS样式指定到某个页面元素中。如果要修改样式，我们只需要在样式列表中找到相应的样式声明进行修改。

多页面应用
	CSS样式表可以单独存放在一个CSS文件中，这样我们就可以在多个页面中使用同一个CSS样式表。CSS样式表理论上不属于任何页面文件，在任何页面文件中都可以将其引用。这样就可以实现多个页面风格的统一。

层叠
	简单的说，层叠就是对一个元素多次设置同一个样式，这将使用最后一次设置的属性值。例如对一个站点中的多个页面使用了同一套CSS样式表，而某些页面中的某些元素想使用其他样式，就可以针对这些样式单独定义一个样式表应用到页面中。这些后来定义的样式将对前面的样式设置进行重写，在浏览器中看到的将是最后面设置的样式效果。

页面压缩
	在使用HTML定义页面效果的网站中，往往需要大量或重复的表格和font元素形成各种规格的文字样式，这样做的后果就是会产生大量的HTML标签，从而使页面文件的大小增加。而将样式的声明单独放到CSS样式表中，可以大大的减小页面的体积，这样在加载页面时使用的时间也会大大的减少。另外，CSS样式表的复用更大程序的缩减了页面的体积，减少下载的时间。
```

（4）CSS语法规则：

​	  CSS 规则由两个主要的部分构成：选择器，以及一条或多条声明.

​               a. 选择器通常是您需要改变样式的 HTML 元素。

​               b. 每条声明由一个属性和一个值组成。

​	 基础语法：选择器｛属性：值;属性:值….. ｝（使用花括号来包围声明）

​	 例：h1{color:red; font-size:14px;}

```
  注意事项：
        a.如果值为若干单词，则要给值加引号；font-family: "黑体" "华文彩云" "微软雅黑" "arial";
        b.多个声明之间使用分号;分开；
        c.css对大小不敏感，如果涉及到与html文档一起使用时，class与id名称对大小写敏感
```

##### 6.2 CSS导入方式

（1）概述：

```
<!--CSS使用方式 有三种 	
			第一种：内联样式：直接写在标签中,  只适合单独设置不能复用
			第二种：内部样式：写在head标签中,添加style标签，可以也页面中多个元素同时设置，可重用
			第三种: 外部样式: css规则放在一个单独文件中,.css，需要引用css文件才起作用，可以实现多个网页使用同一个样式，可重用
			（可重用是指在head之外标签内只要标签相同可以引用css格式）
		-->

<!--css文件：mycss1-->
p{
	color: red;
	font-size: 25px;
}

<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title>css导入方式</title>
		
		<!--第一种：内部方式-->
		<style type="text/css">
			div{
				color: blue;
				font-family: "微软雅黑";
			}
		</style>
		
		<!--第二种: 外部样式（又分为链接式和导入式两种）
			引用外部样式表（单独css文件）
			href：引用的地址
			type：类型 text/css
			rel: 引用的是一个外部样式表		
		-->
		<!--链接式-->
	<!--	<link rel="stylesheet" href="css/mycss1.css" type="text/css" />-->
		<!--导入式-->
		<style type="text/css">
			@import url("css/mycss1.css");
		</style>
	
	</head>
	<body>	
		
		<!--第三种内联样式(内嵌方式)不是定义在标签头，故只作用本句-->
		<div style="font-size: 30px; color: green; background-color: gray;">
			欢迎访问我的网站
		</div>
		<div>
			<!--引用标签头定义的蓝色字体css（div）-->
			第二个div
		</div>
		
		<p>
			<!-引用mycss1的格式p-->
			我爱北京
		</p>
		<p>
			我爱中国
		</p>
	</body>
</html>

备注：link和@import区别：
		   1.link所有浏览器都支持，@import某些版本低的IE不支持
           2.@import是等待html加载完成才加载，link解析到这个语句，就加载
           3.@import不支持js动态修改
优先级：内联样式>内部样式>外部样式，就近原则。
```

##### 6.3  CSS选择器

​	主要用于选择需要添加样式的html元素

（1）基本选择器

（1.1）元素（标签）选择器（作用于所有同标签且未再定义css的语句）

  	  在head中使用style标签引入在其中声明元素选择器:html标签{属性:属性值}，

（1.2）id选择器

​	  给需要修改样式的html元素添加id属性标识，在head中使用style标签引入在其中声明id选择器: #id值{属性:属性值}

（1.3）class选择器

​	 给需要修改样式的html元素添加class属性标识，在head中使用style标签引入在其中声明class选择器:  .class名{属性:属性值}，

```
<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title>基本选择器</title>
		<style type="text/css">
			/*标签选择器*/
			div{
				font-size: 20px;
			}
			/*id选择器*/
			#s1{
				color: red;
			}
			#s2{
				color: blue;
			}
			/*使用类选择*/
			.class1{	
				color: brown;
			}
			.class2{
				font-family: "华文彩云";
			}			
		</style>
	</head>
	<body>
		<!--基本选择器
			1标签选择器  div  p   span
			2id选择器
			3class选择器
			
		-->
		<div id="s1">hello everyone!!!</div>
		<div id="s2">hello everyone!!!</div>
		<div id="s3">hello everyone!!!</div>
		
		<p class="class1">java是世界上最好的语言</p>
		<p class="class1">我爱java,我爱编程</p>
		<h1 class="class1">java开发</h1>
		<h2 class="class1 class2">html开发</h2>
	</body>
</html>
 
 备注:以上基本选择器的优先级从高到低:id ,class ,元素
```

（2）属性选择器	

  根据元素的属性及属性值来选择元素。在head中使用style标签引入在其中声明, 格式为:html标签[属性=‘属性值']{css属性:css属性值;}或者html标签[属性]{css属性:css属性值;}， 

```
<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title>属性选择器</title>
		<style type="text/css">
			input[type='text'] {
				background-color: pink;
			}
			
			input[type='password'] {
				background-color: bisque;
			}
			
			font[size] {
				color: green;
			}
			a[href]{
				color: red;
			}
		</style>
	</head>

	<body>

		<form name="login" action="#" method="get">
			<font size="3">用户名：</font>
			<input type="text" name="username" value="zhangsan"></input>
			</br>
			密码： <input type="password" name="password" value="123456"></input>
			</br>
			<input type="submit" value="登录"></input>
		</form>
		
		<a href="http:www.baidu.com">打开百度</a>
	</body>

</html>
```

（3）伪元素选择器

 	主要是针对a标签

​	语法：静止状态 a:link{css属性}       悬浮状态 a:hover{css属性}    

​	 触发状态 a:active{css属性}         完成状态  a:visited{css属性}

```
<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title>伪元素选择器</title>
		<style type="text/css">
			/* link visited hover active*/
			/*a:link{
				color: black;
			}
			a:visited{
				color: blue;
			}
			a:hover{
				font-size: 20px;
			}
			a:active{
				color: green;
			}*/
			/*四种状态*/
			a{
				color: black;
				font-size: 20px;
				<!--文字修饰为无（可以下划线等等）-->
				text-decoration: none;
			}
			a:hover{
				text-decoration: underline;
			}
			
			li:first-child{
				color: blue;
				font-size: 20px;
			}
			li:last-child{
				color: green;
				font-size: 30px;
			}
			
		</style>
	</head>
	<body>
		<a href="http://www.baidu.com">打开百度</a>
		<a href="http://www.163.com">打开163</a>
		
		<ul>
			<li>苹果</li>
			<li>小米</li>
			<li>华为</li>
			<li>中兴</li>
		</ul>
		
	</body>
</html>
```

（4）层级选择器

 	父级选择器，子级选择器….,

​	后代选择器

​	div p{...}  表示div中的p标签，所有的p,后代

​	div span{....} 表示div中的span标签，包括所有的span，后代

子代选择器

​	div>span{....} 表示 div中有一个span， span是子代

​	相邻兄弟  +

​	通用兄弟 ~

```
<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8" />
		<title>层次选择器</title>
		<style type="text/css">
			/*空格表示后代*/
			#div1 span{
				color: red;
				font-size: 20px;
			}
			/*>表示子代*/
			.div2>span{
				color: blue;
				font-size: 25px;
			}
			
			/*+ 相邻兄弟,h1下面相邻的p变化*/
			h1+p{
				color: blue;
			}
			/*~通用兄弟，h1下面所有的p变化*/
			h1~p{
				background-color: aquamarine;
			}
			
		</style>
	</head>
	<body>
		 <div id="div1">
			<div class="div11">
				<span>span1-1</span>
			</div>
			<div class="div12">
				<span>span1-2</span>
			</div>			
			<span>子代span</span>
		 </div>
		
		<div class="div2">
			<div id="div22">
				<span>span2-1</span>
			</div>
			<div id="div23">
				<span>span2-2</span>
			</div>
			<span>子代span2</span>
		</div>
		<p>作者:李白</p>
		<h1>静夜思</h1>
		<p>窗前明月光</p>
		<p>疑是地上霜</p>
		<div>举头望明月</div>
	</body>
</html>
```

##### 6.4  CSS属性

（1）文字和文本属性

```
<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title>文字和文本属性</title>
		<style type="text/css">
			
			<!--文字属性-->
			div{
				font-size: 20px;
				<!--设置文字的字体-->
				font-family: arial;
				<!--规定斜体字,常见的值：normal - 文本正常显示 
						italic - 文本斜体显示 字体斜体   
						oblique - 文本倾斜显示 变形斜体
				-->
				font-style: oblique;
				<!--设置文本的粗细,100 ~ 900 为字体指定了 9 级加粗度
						100 对应最细的字体变形，900 对应最粗的字体变形  
						数字 400 等价于 normal，而 700 等价于 bold
				-->
				font-weight: bold;
				word-spacing: 10px;
			}
			
			<!--文本属性-->
			p{
				color: cadetblue;
				<!--缩进元素中文本的首行
				1》text-indent:5em;表示此段落第一行缩进5个字符的宽度
			2》text-indent:20%:表示此段落第一行缩进父容器宽度的百分之二十
				-->
				text-indent: 2em;
				<!--none:会关闭原本应用到一个元素上的所有装饰
					underline: 添加下划线
					overline:在文本的顶端画一个上划线
					line-through:在文本中间画一个贯穿线								blink:让文本闪烁
				-->
				text-decoration:underline;
				<!--字符之间的间隔-->
				word-spacing:5px;
				<!--单词或者字母之间的间隔-->
				letter-spacing: 5px;
				<!--行距25px-32px-->
				line-height: 30px;
			}
			<!--h1:一级标签-->
			h1{
				<!--对齐方式:left(左对齐)right(右对齐)center(居中)-->
				text-align: right;
			}
			
		</style>
	</head>
	<body>
		
		<div>
			This is web page; 
			This is a site;
		</div>
		
		<p>
			段落内容段落内容段落内容段落内容段落内容段落内容段落内容段落内容段落内容段落内容段落内容段落内容段落内容段落内容段落内容段落内容段落内容段
		</p>
		<h1>静夜思</h1>
	</body>
</html>

备注：
	  斜体（italic）是对每个字母的结构有一些小改动，来反映变化的外观。
	  倾斜（oblique）文本则是正常竖直文本的一个倾斜版本。
通常情况下，italic 和 oblique 文本在 web 浏览器中看上去完全一样
```

（2）背景属性

```
<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title>背景属性</title>
		<style type="text/css">
			
			body{
				background-color: gainsboro;
			}
			div{
				border:1px solid red;
				height: 300px;
				background-image: url(img/001.png);
				<!--repeat-y:只在垂直方向都平铺
                 	repeat-x:只在水平方向都平铺
                 	repeat:在水平垂直方向都平铺
                 	no-repeat:任何方向都不平铺
                 -->
				background-repeat: no-repeat;
				
				<!--background-position: 改变图像在背景中的位置。top、bottom、left、right 和 center -->
				
			}
		</style>
	</head>
	<body>
		
		<div></div>
	</body>
</html>
```

（3）列表属性

```
<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title>列表属性</title>
		<style type="text/css">
			ul{
				/*list-style-type: none;
				<!--用图像表示标志-->
				list-style-image: url(img/001.png);
				<!--确定标志出现在列表项内容之外还是内容内部 -->
				list-style-position: outside;*/
				/*list-style: inside url(img/001.png) ;*/
				list-style-type:lower-roman;
			}
		
		</style>
	</head>
	<body>
		<ul>
			<li>苹果</li>
			<li>葡萄</li>
			<li>西瓜</li>
			<li>番茄</li>
		</ul>
	</body>
</html>
```

（4）尺寸显示轮廓属性

```
<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title>尺寸显示</title>
		<style type="text/css">
			#d1{
				background-color: pink;
				height: 150px;
				width: 800px;
				/*margin: 0 auto;*/
				<!--none 不显示
					block:块级显示
					inline:行级显示
				-->
				display: block;
	<!--绘制于元素周围线，位于边框边缘的外围，起到突出元素的作用-->
		<!--solid(实线)/dotted(虚线)/dashed(虚线，虚线的每段较长)/double(框为空心)-->
				outline-style:double;
				<!--设置轮廓的颜色-->
				outline-color: blue;
				<!--设置轮廓的宽度-->
				outline-width: 20px;*/
			}
			#d2{
				background-color: #5F9EA0;
				height: 300px;
			}
			#d3{
				background-color: #FFE4C4;
				height: 100px;
			}
			
		</style>
	</head>
	<body>
		<div id="d1">页面头部</div>
		<div id="d2"></div>
		<div id="d3"></div>
	</body>
</html>
```

（5）浮动属性

​	浮动的框可以向左或向右移动，直到它的外边缘碰到包含框或另一个浮动框的边框为止。由于浮动框不在文档的普通流中，所以文档的普通流中的块框表现得就像浮动框不存在一样。

​	空间设想浮动画面：三个同样大小的框（都没有设置浮动）并列排在屏幕的左边缘（一竖排），从上到下分别是框1，框2，框3，框1的宽度（水平）即使比屏幕宽度小很多，它也会单独占一排，框2或者框3是无法排到框1右边的（如果想三个框并排显示只能将三个框全设置浮动），此时设置框1左浮动，框2会自动上移，置于框1下面被覆盖，而框2中的文字不会移动，仍然留在之前的位置；如果框1设置浮动后，不想让框2上移，可以使用clear属性，这样就会使框2不移动，从而避免了文字不移动框移动造成的版面混乱问题；如果三个框全部设置左浮动，则三个框会并排显示在一排中，当屏幕宽度不足以容纳三个框并排时，后面的框会自动向下移动，如果三个框不一样大，框1高度（垂直）比框2框3都大时，框2,框3在屏幕宽度不够的情况下也不会下移，可以理解为被卡主了。

​	clear 属性：规定元素的哪一侧不允许其他浮动元素。属性值包括：left 在左侧不允许浮动元素          right在右侧不允许浮动元素         both 在左右两侧均不允许浮动元素      none 默认值，允许浮动元素出现在两侧        inherit规定应该从父元素继承 clear 属性的值

````
<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title>浮动属性</title>
		<style type="text/css">
			div{
				width: 150px;
				height: 150px;
			}
			#first{
				background-color: pink;
				height: 200px;
				float: left;
			}
			#second{
				background-color: #7FFFD4;
				float: left;
			}
			#third{
				background-color: antiquewhite;
				/*clear  left right both*/ 
			/*	clear: both;*/
				float: left;
			}
		</style>
	</head>
	<body>
		<div id="first">
			第一个div
		</div>
		<div id="second">
			第二个divxxxx
			</div>
		<div id="third">
			第三个div
		</div>		
	</body>
</html>
````

（6）定位属性

（6.1）静态定位（默认定位方式）static，不用设置。

（6.2）相对定位(relative)

元素框偏移某个距离。元素仍保持其未定位前的形状，它原本所占的空间仍保留

（6.3）绝对定位(absolute)

 	元素框从文档流完全删除，并相对于其包含块定位。包含块可能是文档中的另一个元素或者是初始包含块。元素原先在正常文档流中所占的空间会关闭，就好像元素原来不存在一样。元素定位后生成一个块级框，而不论原来它在正常流中生成何种类型的框.通过绝对定位，元素可以放置到页面上的任何位置。位置依据是父元素不是静态的元素,如果没有找到不是静态定位，依据就是浏览器窗口，当定位依据是浏览器窗口的时候，不管视图怎么上下翻页移动，绝对定位的框位置不会移动。

（6.4）固定定位(fixed)

​	元素框的表现类似于将 position 设置为 fixed，不过其包含块是视窗本身，不管视图怎么上下翻页移动，固定定位的框位置不会移动，即固定定位的位置依据是浏览器窗口，这种定位在看视图时，其位置不会改变。

```
<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title>定位</title>
		<style type="text/css">
			div{
				width: 100px;
				height: 100px;
			}
			#div1{
				background-color: pink;
				/*相对定位: 相对于本身本应所在位置进行移动*/
				position: relative;
				left: 20px;
				top: 20px;
				<!--设置堆叠的优先级，优先级高的置于优先级低的前面-->
				z-index: -1;
			}
			#div2{
				background-color: aqua;
				z-index: 0;
			}
			#div4{
				background-color: brown;
				width: 50px;
				height: 100px;
				/*绝对定位  位置依据是父元素不是静态的元素,如果没有找到不是静态定位，依据就是浏览器窗口*/
				position: absolute;
				left: 20px;
				top: 50%;	
			}
			
			#div5{
				background-color: brown;
				width: 50px;
				height: 100px;
				/*固定定位  固定一个位置，依据就是浏览器窗口*/
				position: fixed;
				right: 20px;
				top: 50%;
			}
		</style>
	</head>
	<body>
		<div id="div1">忆江南</div>
		<div id="div2">江南好啊</div>
		
		<div id="div4">
			五一快到了,准备去哪儿...
		</div>
		
		<div id="div5">
			六一快到了,准备去哪儿...
		</div>
		
		<p>内容</p>
		<p>内容</p>
		<p>内容</p>
		<p>内容</p>
		<p>内容</p>
		<p>内容</p>
		
		<p>内容</p>
		<p>内容</p>
		<p>内容</p>
		
		<p>内容</p>
		<p>内容</p>
		<p>内容</p>
		
		
		
		<p>内容</p>
		<p>内容</p>
		
		<p>内容</p>
		<p>内容</p>
		<p>内容</p>
		
		<p>内容</p>
		<p>内容</p>
		
		<p>内容</p>
		<p>内容</p>
		<p>内容</p>
		<p>内容</p>
		<p>内容</p>
		
		<p>内容</p>
		<p>内容</p>
		<p>内容</p><p>内容</p>
		<p>内容</p>
		
		<p>内容</p>
		<p>内容</p>
		<p>内容</p>
	</body>
</html>
```

（7）CSS盒子模型

​	  模型空间想象：类似于电视机，最内一个矩形显示屏用于放元素，有高和宽两个属性，矩形外侧套一个大矩形，该大矩形有内边框和外边框，内边框到内矩形的距离称为内边距，内边框到外边框的距离称为外边距。

```
<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title>盒子模型</title>
		<style type="text/css">
			#box{
				width: 200px;
				height: 200px;
				background-color: #FFC0CB;
				
				<!--边框属性:
						边框样式border-style:solid(实线)double(空心线)
								dashed(虚线组成的边框)
								dotted(圆点组成的边框)
						border-color:边框颜色
						border-width:边框宽度	
						简写：
				-->
				border: 2px dotted blue;
				
				<!--内边距属性（top right bottom left）-->
/*padding-left:10px; padding-right:10px; padding-top:10px; 
 padding-bottom:10px; 等同于 padding: 10px;
 padding-left:10px; padding-right:10px; padding-top:5px; 
 padding-bottom:5px; 等同于 padding: 10px 10px 5px 5px;还等同于
 padding: 10px 5px;（第一个数值代表左右距离，第二个数值代表上下距离）*/
				padding: 10px;
				
				<!--外边距属性（top right bottom left）（用法同上）-->
				margin-right: 10px;
				
				float: left;
			}
			#box2{
				width: 200px;
				height: 200px;
				background-color: cadetblue;
				margin-left: 10px;
				float: left;
			}
		</style>
	</head>
	<body>
		
		<div id="box">
			内容
		</div>
		<div id="box2">
			第二个box2
		</div>
	</body>
</html>
```

（8） CSS3扩展属性

```
<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title>css3扩展属性</title>
		<style type="text/css">
			#box1{
			    <!--操场形状-->
				width: 150px;
				height: 50px;
				background-color: pink;
				<!--圆角属性-->
				border-radius: 20px;
				<!--为指定元素使用背景图像-->
				background-image:url(img/001.jpg)
			}
			#box2{
				<!--圆形形状-->
				width: 100px;
				height: 100px;
				background-color:#7FFFD4;
				border-radius:50%;
			}
			#box3{
				<!--半圆形状-->
				width: 200px;
				height: 100px;
				background-color:#7FFFD4;
				border-radius:0  0 100px 100px;
			}
			#box4{
				<!--四分之一圆形形状-->
				width: 200px;
				height: 200px;
				background-color:#7FFFD4;
				border-radius:200px 0 0 0;
			}
			#box5{
				width: 150px;
				height: 50px;
				background-color:coral;
				border-radius: 10px;
				<!--用于向方框添加阴影-->
				box-shadow: 10px 10px 10px #5F9EA0;
				<!--向文本应用阴影-->
				text-shadow: 5px 5px 5px #ffff00;
				text-align: center;
				line-height: 50px;
			}
		</style>
	</head>
	
	<!--background-repeat:设置平铺拉伸-->
	<body style="text-align: center;
		background:url(img/001.jpg);
		background-size: 200px 300px;
		background-repeat: no-repeat;">
		
		<div id="box1">
			
		</div>
		<div id="box2">
			
		</div>
		<div id="box3">
			
		</div>
		<div id="box4">
			
		</div>
		
		<div id="box5">哈哈哈</div>
	</body>
</html>
```

##### 6.5 css面试题

```
1、CSS 中类 (classes) 和 ID 的区别
对于CSS而言，id和class都是选择器，唯一不同的地方在于权重不同。

对于html而言，id和class都是dom元素的属性值。不同的地方在于id属性的值是唯一的，而class属性值可以重复。

id还一个老特性是锚点功能，当浏览器地址栏有一个#xxx，页面会自动滚动到id=xxx的元素上面。

2、请问 “resetting” 和 “normalizing” CSS 之间的区别？你会如何选择，为什么？
Normalize.css 是一个可定制的 CSS 文件，使浏览器呈现的所有元素，更一致和符合现代标准；是在现代浏览器环境下对于CSS reset的替代。 它正是针对只需要统一的元素样式。该项目依赖于研究浏览器默认元素风格之间的差异，精确定位需要重置的样式。

normalizing： 
保护有用的浏览器默认样式而不是完全去掉它们 
一般化的样式：为大部分HTML元素提供 
修复浏览器自身的bug并保证各浏览器的一致性 
优化CSS可用性：用一些小技巧 
解释代码：用注释和详细的文档来

Normalize.css 保护了有价值的默认值： 
Reset通过为几乎所有的元素施加默认样式，强行使得元素有相同的视觉效果。相比之下，Normalize.css保持了许多默认的浏览器样式。这就意味着你不用再为所有公共的排版元素重新设置样式。当一个元素在不同的浏览器中有不同的默认值时，Normalize.css会力求让这些样式保持一致并尽可能与现代标准相符合。

3、请解释浮动 (Floats) 及其工作原理。
float被归类于CSS 定位属性（Positioning） 
描述：规定框是否应该浮动。 
定义和用法：float 属性定义元素在哪个方向浮动。以往这个属性总应用于图像，使文本围绕在图像周围，不过在 CSS 中，任何元素都可以浮动。浮动元素会生成一个块级框，而不论它本身是何种元素。 
由于浮动框不在文档的普通流中，所以文档的普通流中的块框表现得就像浮动框不存在一样。

4、描述z-index和叠加上下文是如何形成的。
z-index 属性设置元素的堆叠顺序。拥有更高堆叠顺序的元素总是会处于堆叠顺序较低的元素的前面。 
注释：元素可拥有负的 z-index 属性值。 
注释：Z-index 仅能在定位元素上奏效（例如 position:absolute;）！

而凡是拥有层叠上下文的元素，将离用户最近，也就是越靠在Z轴前面。默认情况下只有根元素HTML会产生一个层叠上下文，并且元素一旦使用了一些属性也将会产生一个层叠上下文，如我们常用的定位属性。如两个层叠上下文相遇时，总是后一个层叠前一个，除非使用z-index来改变。

详情见： 
http://www.cnblogs.com/pssp/p/5948356.html

5、列举不同的清除浮动的技巧，并指出它们各自适用的使用场景。
1、对父级设置适合CSS高度 
2、clear:both清除浮动，但是需要新增一个空的div 
3、父级div定义 overflow:hidden 
4、父级div也一起浮动 
5、父级div定义 display:table

6、请描述伪元素 (pseudo-elements) 及其用途。
伪元素例如： 
:first-line / :first-letter / :befort / :after 
详情参见链接： 
http://www.w3school.com.cn/css/css_pseudo_elements.asp

7、请解释 inline 和 inline-block 的区别？
display:block 
block元素会独占一行，多个block元素会各自新起一行。默认情况下，block元素宽度自动填满其父元素宽度。 
block元素可以设置width,height属性。块级元素即使设置了宽度,仍然是独占一行。 
block元素可以设置margin和padding属性。
display:inline 
inline元素不会独占一行，多个相邻的行内元素会排列在同一行里，直到一行排列不下，才会新换一行，其宽度随元素的内容而变化。 
inline元素设置width,height属性无效。 
inline元素的margin和padding属性，水平方向的padding-left, padding-right, margin-left, margin-right都产生边距效果；但竖直方向的padding-top, padding-bottom, margin-top, margin-bottom不会产生边距效果。
display:inline-block 
简单来说就是将对象呈现为inline对象，但是对象的内容作为block对象呈现。之后的内联对象会被排列在同一行内。比如我们可以给一个link（a元素）inline-block属性值，使其既具有block的宽度高度特性又具有inline的同行特性。
8、你用过媒体查询，或针对移动端的布局/CSS 吗？
@media 
详见：http://www.runoob.com/cssref/css3-pr-mediaquery.html

9、如果设计中使用了非标准的字体，你该如何去实现？

@font-face 
详见：http://www.w3school.com.cn/css3/css3_font.asp

10、请解释 relative、fixed、absolute 和 static 元素的区别
static（静态定位）：默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声明）。
relative（相对定位）：生成相对定位的元素，通过top,bottom,left,right的设置相对于其正常（原先本身）位置进行定位。可通过z-index进行层次分级。 
定位为relative的元素脱离正常的文本流中，但其在文本流中的位置依然存在。 
relative定位的层总是相对于其最近的父元素，无论其父元素是何种定位方式
absolute（绝对定位）：生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。可通过z-index进行层次分级。 
定位为absolute的层脱离正常文本流，但与relative的区别是其在正常流中的位置不再存在。 
对于absolute定位的层总是相对于其最近的定义为absolute或relative的父层，而这个父层并不一定是其直接父层。
fixed（固定定位）：生成绝对定位的元素，相对于浏览器窗口进行定位。元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。可通过z-index进行层次分级。
注：使用static 定位或无position定位的元素z-index属性是无效的。

11、请罗列出你所知道的 display 属性的全部值
常见的包括： 
none、block、inline、inline-block、list-item、run-in、table、inline-table、table-row-group、table-header-group、table-footer-group、table-row、table-column-group、table-column、table-cell、table-caption、inherit

12、请解释你对盒模型的理解，以及如何在 CSS 中告诉浏览器使用不同的盒模型来渲染你的布局。
盒子模型分为两类：W3C标准盒子模型和IE盒子模型。这两者的关键差别就在于： 
W3C盒子模型——属性高（height）和属性宽（width）这两个值不包含 填充（padding）和边框（border） 
IE盒子模型——属性高（height）和属性宽（width）这两个值包含 填充（padding）和边框（border） 
我们在编写页面代码的时候应该尽量使用标准的W3C盒子模型（需要在页面中声明DOCTYPE类型）。

css中可使用hack或者wrapper。【CSS hack是通过在CSS样式中加入一些特殊的符号，让不同的浏览器识别不同的符号（什么样的浏览器识别什么样的符号是有标准的，CSS hack就是让你记住这个标准），以达到应用不同的CSS样式的目的】

13、请解释 * { box-sizing: border-box; } 的作用, 并且说明使用它有什么好处？
大致就是说，在盒模型中，元素的高和宽包括了边框和内边距，详见： 
http://www.w3school.com.cn/cssref/pr_box-sizing.asp

14、你熟悉 SVG 样式的书写吗？
SVG为可缩放矢量图形，详见： 
http://www.w3school.com.cn/svg/index.asp

15、CSS 中字母 ‘C’ 的意思是叠层 (Cascading)。请问在确定样式的过程中优先级是如何决定的 (请举例)？如何有效使用此系统？
样式的优先级 
多重样式（Multiple Styles）：如果外部样式、内部样式和内联样式同时应用于同一个元素，就是使多重样式的情况。 
一般情况下，优先级如下： 
（外部样式）External style sheet <（内部样式）Internal style sheet <（内联样式）Inline style 
有个例外的情况，就是如果外部样式放在内部样式的后面，则外部样式将覆盖内部样式。

选择器的优先权： 
1. 内联样式表的权值最高 1000； 
2. ID 选择器的权值为 100 
3. Class 类选择器的权值为 10 
4. HTML 标签选择器的权值为 1

CSS 优先级法则： 
1. 选择器都有一个权值，权值越大越优先； 
2. 当权值相等时，后出现的样式表设置要优于先出现的样式表设置； 
3. 创作者的规则高于浏览者：即网页编写者设置的CSS 样式的优先权高于浏览器所设置的样式； 
4. 继承的CSS 样式不如后来指定的CSS 样式； 
5. 在同一组属性设置中标有“!important”规则的优先级最大；

16、为什么响应式设计 (responsive design) 和自适应设计 (adaptive design) 不同？
自适应是为了解决如何在不同大小的设备上呈现同样的网页（网页的主题和内容不改变） 
响应式的概念覆盖了自适应，而且涵盖的内容更多。 
自适应暴露的一个问题，如果屏幕太小，即使网页能够根据屏幕大小进行适配，但是会感觉在小屏幕上查看内容太过拥挤。响应式正是针对这个问题衍生出的概念。它可以自动识别屏幕宽度、并做出相应调整的网页设计、布局和展示的内容可能会有所改变。

17、在书写高效 CSS 时会有哪些问题需要考虑？
（1）避免使用全局样式 
既然是全局的定义，那么他会吧所有标签都处理一遍，增加了浏览器解析的时间。有些标签其实没有必要处理。 
允许一个元素去继承它的祖先，或者使用一个class去应用复杂的元素。 
（2）将规则写的越精确越好 
偏向使用class ，id，少使用tag 
另外定义class时使用一些有代表意义的单词，比如在模块化开发的过程中，一般用mod-xxx，很利于维护，代码也很漂亮， 
（3）移除一些无用的限定 
下面的这些限定是多余的 
1.id选择器被class 或者tag选择器限定，也就是不要在id前面添加任何限定符，包括class tag 或者其他的选择符。 
2.class被tag选择器进行限定（如果一个class只被用于一个tag，这也是很好的实践） 
（4）避免使用后代选择器，特别是包含了一些无用的祖先元素 
eg：body ul li a{…} 制定了一个无用的body限定，因为所有的元素都是在body中。 
（5）使用class选择器取代后代选择器，CSS 的层级选择器不要超过3个 
eg：如果你需要两个不同的样式（一个无序列表，一个有序列表） 
不要使用下面的样式 
ul li {color:blue} ol li {color:red} 
应该这样的使用 .unordered-list-item {color: blue;} .ordered-list-item {color: red;} 
如果你一定要用后代选择器，建议你使用子选择器 
（6）display与visibility的差异 
他们用于设置或检索是否显示对象。display隐藏对象不保留物理空间，visibility为隐藏对象保留占据的物理空间。当浏览器渲染被占据的物理空间时，会有所消耗资源。所以不赞成用visibility:hidden; 
（7）border:none;与border:0;的区别 
有些同学肯定没注意过这两个代码的区别，在HTML显示肯定是一样的，但是从基本上来说他们不一样 用border:0虽然现实上和none没什么区别，但是它会保留color、style 这两个属性。所以不赞成用border:0; 
（8）不宜过小的背景图片平铺 
（9）代码缩写

18、使用 CSS 预处理器的优缺点有哪些？
缺点：简单来说CSS预处理器语言较CSS玩法变得更高级了，但同时降低了自己对最终代码的控制力。更致命的是提高了门槛，首先是上手门槛，其次是维护门槛，再来是团队整体水平和规范的门槛。这也造成了初学学习成本的昂贵。另外，预编译CSS步骤的加入，让我们开发工作流中多了一个环节，调试也变得更麻烦了。 
优点：用一种专门的编程语言，为CSS增加了一些编程的特性，将CSS作为目标生成文件，然后开发者就只要使用这种语言进行编码工作。通俗的说，CSS预处理器用一种专门的编程语言，进行Web页面样式设计，然后再编译成正常的CSS文件，以供项目使用。CSS预处理器为CSS增加一些编程的特性，无需考虑浏览器的兼容性问题，例如你可以在CSS中使用变量、简单的逻辑程序、函数等等在编程语言中的一些基本特性，可以让你的CSS更加简洁、适应性更强、可读性更佳，更易于代码的维护等诸多好处。
```

#### 第七章 Web项目结构和Tomcat配置

##### 7.1  Web简介、eclipse-ee

（1）B/S 与C/S模式

```
B/S:Browser/Server或浏览器/服务器模式
优点是用户使用简单只要有浏览器和网络即可，不用频繁更新，一个浏览器可以访问多个服务器
缺点是性能稍微降低，安全性稍微降低
常见的程序：淘宝网、京东网等

C/S:Client/Server或客户端/服务器模式
C/S的优点是能充分发挥客户端PC的处理能力,减轻服务器压力
缺点是对用户的电脑配置要求较高，升级更新麻烦
常见的CS程序：LOL、穿越火线、QQ
```

（2）web服务器

```
Web服务器是运行及发布Web应用的容器，只有将开发的Web项目放置到该容器中，才能使网络中的所有用户通过浏览器进行访问。开发Java Web应用所采用的服务器主要是与JSP/Servlet兼容的Web服务器，比较常用的有Tomcat、Resin、JBoss、WebSphere 和 WebLogic 等

Tomcat 服务器
　　目前最为流行的Tomcat服务器是Apache-Jarkarta开源项目中的一个子项目，是一个小型、轻量级的支持JSP和Servlet 技术的Web服务器，也是初学者学习开发JSP应用的首选
　　
Resin 服务器
　　Resin是Caucho公司的产品，是一个非常流行的支持Servlet和JSP的服务器，速度非常快。Resin本身包含了一个支持HTML的Web服务器，这使它不仅可以显示动态内容，而且显示静态内容的能力也毫不逊色，因此许多网站都是使用Resin服务器构建
　　
JBoss服务器
　　JBoss是一个种遵从JavaEE规范的、开放源代码的、纯Java的EJB服务器，对于J2EE有很好的支持。JBoss采用JML API实现软件模块的集成与管理，其核心服务又是提供EJB服务器，不包含Servlet和JSP的Web容器，不过它可以和Tomcat完美结合
　　
WebSphere 服务器
　　WebSphere是IBM公司的产品，可进一步细分为 WebSphere Performance Pack、Cache Manager 和WebSphere Application Server等系列，其中WebSphere Application Server 是基于Java 的应用环境，可以运行于 Sun Solaris、Windows NT 等多种操作系统平台，用于建立、部署和管理Internet和Intranet Web应用程序。

WebLogic 服务器
　　WebLogic 是BEA公司的产品（现在已经被Oracle收购），可进一步细分为 WebLogic Server、WebLogic Enterprise 和 WebLogic Portal 等系列，其中 WebLogic Server 的功能特别强大。WebLogic 支持企业级的、多层次的和完全分布式的Web应用，并且服务器的配置简单、界面友好。对于那些正在寻求能够提供Java平台所拥有的一切应用服务器的用户来说，WebLogic是一个十分理想的选择
　　
自定义web服务器
public class MyServer {
	public static void main(String[] args) {
		try {
			//1创建侦听套接字
			ServerSocket listener=new ServerSocket(10086);
			//2接收客户端请求
			System.out.println("客户端已启动....");
			Socket socket=listener.accept();
			//3获取输出流
			OutputStream os=socket.getOutputStream();
			
			//4创建FileInputStream
			FileInputStream fis=new FileInputStream("d:\\mywork\\hello.html");
			
			byte[] buf=new byte[1024*4];
			int len=0;
			while((len=fis.read(buf))!=-1) {
				os.write(buf,0,len);
				os.flush();
			}
			//5关闭
			fis.close();
			os.close();
			socket.close();
			listener.close();
			
			System.out.println("服务器执行完毕...");
				
		} catch (IOException e) {
			e.printStackTrace();
		}
	}
}
```

（3）eclipes-ee

（3.1）eclipes升级版（eclipese-ee）配置:本版本与之前安装的eclipse用法相同，配置唯一的不同点在于，本版本配置字符码和快捷键辅助工具时需要同时配置XML,HTML,CSS,JSP等。

（3.2）当使用eclipese-ee软件自带浏览器进行服务器连接时，http：后面的双斜杠必须写上，该浏览器对格式要求非常严格。

（3.3）Windows-->show view-->other-->java-->Package Explorer（在使用Web项目时一般都选用该窗口视图）

（3.4）右键项目--》properties--》Targeted Runtimes-->选中8.0--》完成更改版本

##### 7.2 Tomcat

（1）安装注意事项：不建议放在中文路径下;   tomcat安装需要配置JAVA_HOME环境变量; 进入到解压的目录下找到bin\startup.bat双击启动，再打开浏览器输入http：localhost：8080，点击回车看是否能打开tomcat网页，能打开则说明安装成功

（2）Tomcat目录的介绍：

```
1、bin：该目录下存放的是二进制可执行文件，如果是安装版，那么这个目录下会有两个exe文件：tomcat9.exe、tomcat9w.exe，前者是在控制台下启动Tomcat，后者是弹出UGI窗口启动Tomcat；如果是解压版，那么会有startup.bat和shutdown.bat文件，startup.bat用来启动Tomcat，但需要JDK的配置，shutdawn.bat用来停止Tomcat；

2、conf：这是一个非常非常重要的目录，这个目录下有四个最为重要的文件：
server.xml：配置整个服务器信息。例如修改端口号，添加虚拟主机等；
tomcatusers.xml：存储tomcat用户的文件，这里保存的是tomcat的用户名及密码，以及用户的角色信息。可以按着该文件中的注释信息添加tomcat用户，然后就可以在Tomcat主页中进入Tomcat Manager页面了；
web.xml：部署描述符文件，这个文件中注册了很多MIME类型，即文档类型。这些MIME类型是客户端与服务器之间说明文档类型的，如用户请求一个html网页，那么服务器还会告诉客户端浏览器响应的文档是text/html类型的，这就是一个MIME类型。客户端浏览器通过这个MIME类型就知道如何处理它了。当然是在浏览器中显示这个html文件了。但如果服务器响应的是一个exe文件，那么浏览器就不可能显示它，而是应该弹出下载窗口才对。MIME就是用来说明文档的内容是什么类型的！
context.xml：对所有应用的统一配置，通常我们不会去配置它。

3、lib：Tomcat的类库，里面是一大堆jar文件。如果需要添加Tomcat依赖的jar文件，可以把它放到这个目录中，当然也可以把应用依赖的jar文件放到这个目录中，这个目录中的jar所有项目都可以共享之，但这样你的应用放到其他Tomcat下时就不能再共享这个目录下的Jar包了，所以建议只把Tomcat需要的Jar包放到这个目录下；

4、logs：这个目录中都是日志文件，记录了Tomcat启动和关闭的信息，如果启动Tomcat时有错误，那么异常也会记录在日志文件中。

5、temp：存放Tomcat的临时文件，这个目录下的东西可以在停止Tomcat后删除！

6、webapps：存放web项目的目录，其中每个文件夹都是一个项目；如果这个目录下已经存在了目录，那么都是tomcat自带的项目。其中ROOT是一个特殊的项目，在地址栏中没有给出项目目录时，对应的就是ROOT项目。http://localhost:8080/examples，进入示例项目。其中examples就是项目名，即文件夹的名字。

7、work：运行时生成的文件，最终运行的文件都在这里。通过webapps中的项目生成的！可以把这个目录下的内容删除，再次运行时会生再次生成work目录。当客户端用户访问一个JSP文件时，Tomcat会通过JSP生成Java文件，然后再编译Java文件生成class文件，生成的java和class文件都会存放到这个目录下。

8、LICENSE：许可证。

9、NOTICE：说明文件。
```

（3）在Eclipse中集成Tomcat服务器

​	  打开Eclipse的window-->Preferences—>Server-->runtime environment-->add-->对应的本机Tomcat版本号(本机使用的是8.0)-->finish--->选择eclipse右边菜单栏中的server（像三个小灯笼，两边朝下，中间朝上）—>空白处右键new—>server—>Finish-->右键新加的服务器点击open打开了overview窗口--->Server Locations勾选第二个Use Tomcat·······--->再往下的Deploy paths 改为webapps-->选中新建的服务器右键start即可启动

##### 7.3  JavaWEB项目创建及结构

（1） javaWeb项目创建:之前创建项目时是创建java空间，现在需要将java空间改选为Dynamic Web Project即可。

（2） javaweb项目结构讲解：

​	   src: java代码

​	   JRE System Library: java环境

​	   Apache Tomcat v8.0: Tomcat环境

​	   build 存放class文件

​	   WebContent 存放静态资源：网页,css,javascript

​	   META-INT存放元数据信息

​	   WEB-INT Web信息web,xml

​	    lib  存放jar包

​	    Java web工程下的webapp或WebContent就是工程的发布文件夹，发布时会把该文件夹发布到tomcat的webapps里。

​	    开发时classes文件存放路径：buildpath：在eclipse中项目的右键build path-source中指定工程中class文件的编译路径，一般为：test/build/classes。（test是工程名）

​	  发布时classes文件存放路径：发布到tomcat时（在eclipse里启动tomcat），src文件夹里的java文件经过编译后，会把.class文件放在WEB-INF文件夹里的classes文件夹中。

​	  有一些配置文件需要放到WEB-INF的classes文件夹下，所以，通常的做法是手动在工程的WEB-INF文件夹下建立classes文件夹。如果不在工程的WEB-INF下手动建立classes，发布到tomcat时tomcat里的WEB-INF中也会有classes文件夹。

（3） Web项目应用jar包:开发人员只需要把需要的jar包copy到项目下WebCountent下的WEB-INF/lib中即可,项目执行时会自动建立路径，与之前的java项目不同（之前需要右键手动添加）。

（4）web工程导出的时候要选择导出类型为war包

（5）web.xml：如果创建项目时没有web.xml，可以**右键项目，点击java EE Tools 其中点击Genertate Deployment Descriptor Stub** ,这样WEB-INF就会添加上web.xml了

```
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://xmlns.jcp.org/xml/ns/javaee" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd" version="3.1">

<!--Web 应用描述：给出于此相关的说明性文本-->
<desciption>Tomcat Example servlets and JSP pages.</desciption>
 
 <!--Web 应用名称：提供GUI工具可能会用来标记这个特定的Web应用的一个名称-->
  <display-name>firstweb</display-name>
  
  <!--项目首页配置-->
  <welcome-file-list>
    <welcome-file>index.html</welcome-file>
    <welcome-file>index.htm</welcome-file>
    <welcome-file>index.jsp</welcome-file>
    <welcome-file>default.html</welcome-file>
    <welcome-file>default.htm</welcome-file>
    <welcome-file>default.jsp</welcome-file>
  </welcome-file-list>
</web-app>
```

#### 第八章 Servlet

##### 8.1 Servlet概述和常见错误

（1）什么是servlet

```
Servlet（Server Applet）是Java Servlet的简称，称为小服务程序或服务连接器，用Java编写的服务器端程序，主要功能在于交互式地浏览和修改数据，生成动态Web内容.
servlet运行于支持Java的应用服务器中。从实现上讲，Servlet可以响应任何类型的请求，但绝大多数情况下Servlet只用来扩展基于HTTP协议的Web服务器。
Servlet编程需要使用到javax.servlet  和 javax.servlet.http两个包下面的类和接口，在所有的类和接口中，javax.servlet.servlet 接口最为重要。所有的servlet程序都必须实现该接口或者继承实现了该接口的类。
javax.servlet.ServletConfig;
javax.servlet.ServletException;
javax.servlet.http.HttpServlet;
javax.servlet.http.HttpServletRequest;
javax.servlet.http.HttpServletResponse;
javax.servlet.http.HttpSession;
javax.servlet.http.Cookie;
```

（2）常见错误解决方法

```
HTTP Status 404   找不到
解决方法：查看Tomcat的webapps目录下找到当前项目在WEB-INF下的classes内能否找到刚刚的class文件
如果有，重新启动Tomcat
如果没有，在Eclipse中选择Project-->clean让Eclipse清空缓存并重新构建项目，再次运行
```

##### 8.2 HTTP协议

（1）HTTP协议概念与特点

```
超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议,是一个基于请求与响应模式的、无状态的、应用层的协议，常基于TCP的连接方式

HTTP协议的主要特点如下：
1.支持客户/服务器模式。
2.简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。
3.灵活：HTTP允许传输任意类型的数据对象。传输的类型由Content-Type加以标记。
4.无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。
5.无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。
```

（2）Http协议的通信

```
HTTP通信机制是在一次完整的HTTP通信过程中，Web浏览器与Web服务器之间将完成下列7个步骤：
1、 建立TCP连接
在HTTP工作开始之前，Web浏览器首先要通过网络与Web服务器建立连接，该连接是通过TCP来完成的，该协议与IP协议共同构建Internet，即著名的TCP/IP协议族，因此Internet又被称作是TCP/IP网络。HTTP是比TCP更高层次的应用层协议，根据规则，只有低层协议建立之后才能进行更低层协议的连接。因此，首先要建立TCP连接，一般TCP连接的端口号是80
2、 浏览器向Web服务器发送请求命令
一旦建立了TCP连接，Web浏览器就会向Web服务器发送请求命令
例如：GET/sample/hello.html HTTP/1.1
3、 浏览器发送请求头信息
浏览器发送其请求命令之后，还要以头信息的形式向Web服务器发送一些别的信息，之后浏览器发送了一空白行来通知服务器，它已经结束了该头信息的发送。
4、 Web服务器应答
客户机向服务器发出请求后，服务器会客户机回送应答，
HTTP/1.1 200 OK
应答的第一部分是协议的版本号和应答状态码
5、 Web服务器发送应答头信息
正如客户端会随同请求发送关于自身的信息一样，服务器也会随同应答向用户发送关于它自己的数据及被请求的文档。
6、 Web服务器向浏览器发送数据
Web服务器向浏览器发送头信息后，它会发送一个空白行来表示头信息的发送到此为结束，接着，它就以Content-Type应答头信息所描述的格式发送用户所请求的实际数据
7、 Web服务器关闭TCP连接
一般情况下，一旦Web服务器向浏览器发送了请求数据，它就要关闭TCP连接，然后如果浏览器或者服务器在其头信息加入了这行代码
Connection:keep-alive
TCP连接在发送后将仍然保持打开状态，于是，浏览器可以继续通过相同的连接发送请求。保持连接节省了为每个请求建立新连接所需的时间，还节约了网络带宽
```

（3）数据格式

​	  HTTP请求格式

```
当浏览器向Web服务器发出请求时，它向服务器传递了一个数据块，也就是请求信息(请求报文)，HTTP请求信息由4部分组成：
l 请求行：请求方法/地址 URI协议/版本
2 请求头(Request Header)
3 空行（请求方法是get的时候不存在3和4）
4 请求正文
下面是一个HTTP请求的例子：
GET/hello HTTP/1.1
Accept:text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8
Accept-Language:zh-CN,zh;q=0.8,en-GB;q=0.6,en;q=0.4
Connection:Keep-Alive
Host:localhost：name=zhangsan
User-Agent:Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/59.0.3071.115 Safari/537.36
Accept-Encoding:gzip, deflate, br

HTTP请求的例子的解释：
1、请求方法URI协议/版本
请求的第一行是“方法URL议/版本”：GET/hello HTTP/1.1
以上代码中“GET”代表请求方法，“/hello”表示URI，“HTTP/1.1代表协议和协议的版本。
根据HTTP标准，HTTP请求可以使用多种请求方法。例如：HTTP1.1支持7种请求方法：GET、POST、HEAD、OPTIONS、PUT、DELETE和TARCE。在Internet应用中，最常用的方法是GET和POST。
URL完整地指定了要访问的网络资源，通常只要给出相对于服务器的根目录的相对目录即可，因此总是以“/”开头，最后，协议版本声明了通信过程中使用HTTP的版本。
2、请求头(Request Header)
请求头包含许多有关的客户端环境和请求正文的有用信息。例如，请求头可以声明浏览器所用的语言，请求正文的长度等。
Accept:text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8
Accept-Language:zh-CN,zh;q=0.8,en-GB;q=0.6,en;q=0.4
Connection:Keep-Alive
Host:localhost
User-Agent:Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/59.0.3071.115 Safari/537.36
Accept-Encoding:gzip, deflate, br
3、请求正文
请求头和请求正文之间是一个空行，这个行非常重要，它表示请求头已经结束，接下来的是请求正文。请求正文中可以包含客户提交的查询字符串信息：
name=zhangsan
```

##### 8.3 Servlet使用

（1）servlet的基本使用

```
打开eclipse--ee版-->建立dynamic Web Project-->添加Tomcat服务器-->将新建的Web项目加载到新建的服务器中-->在新建的Web项目下的src文件夹下创建package-->选中刚刚创建的包，右键-->New-->Servlet（此时系统会自动创建Servlet程序文件）-->发布右键-->Run As-->Run On Server-->浏览器输入网址访问：http://localhost:8080/项目名称/请求地址
```

（1.1）系统会自动创建Servlet程序文件

```java
//注解 /MyServlet1就是浏览器请求的地址 http://localhost:8080/day11web1/MyServlet1
@WebServlet("/MyServlet1")
public class MyServlet1 extends HttpServlet {
	private static final long serialVersionUID = 1L;  
    public MyServlet1() {
        super();
    }
//doGet方法:接收get请求 ,request请求对象 ,response响应对象
	protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		response.getWriter().append("Served at: ").append(request.getContextPath());
		response.getWriter().append("<br/>hello world this is my servlet");
	}

//doPost方法：接收post请求, request请求对象，response响应对象
	protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		doGet(request, response);
	}
}
```

（2）Servlet核心接口和类

（2.1）Servlet接口

​	    在ServletAPI中最重要的是Servlet接口，所有Servlet都会直接或间接的与该接口发生联系，或是直接实现该接口，或间接继承自实现了该接口的类。

```java
该接口包括以下五个方法：
	//销毁，程序结束了,垃圾回收器回收
	public void destroy() {
	}

	//获取Servlet配置
	public ServletConfig getServletConfig() {
	}

	//获取Servlet基本信息: 版权，作者
	public String getServletInfo() {
	}

	//初始化方法,创建Servlet时执行
	public void init(ServletConfig config){      
	}

	//服务方法,当浏览器请求此servlet时执行
	public void service(ServletRequest request, ServletResponse response) {	
	}
注：（1）第一次访问时，服务器会创建Servlet对象，并调用init方法，再调用service方法
    （2）第二次再访问时，Servlet对象已经存在，不再创建，执行service方法
    （3）当服务器停止，会释放Servlet，调用destroy方法。
```

（2.2）GenericServlet抽象类：它对Servlet接口中的部分方法（init和destroy）添加了实现，使得开发时只需要考虑针对service方法的业务实现即可。

（2.3）HttpServlet类

```
HttpServlet类是继承GenericServlet的基础上进一步的扩展，
扩展方法：
public void init(ServletConfig config)，
public void init()。他们有如下的关系： init（ServletConfig config）方法由tomcat自动调用，它读取web工程下的web.xml，将读取的信息打包传给此参数，此方法的参数同时将接收的信息传递给GenericServlet类中的成员变量config，同时调用init()。以后程序员想重写init方法可以选择init（ServletConfig config）或者init()，但是选择init（ServletConfig config）势必会覆盖此方法已实现的内容，没有为config变量赋值，此后若是调用getServletConfig（）方法返回config时会产生空指针异常的，所以想重写init（ServletConfig config）方法，必须在方法体中第一句写上 super.init（config），为了防止程序员忘记重写super.init（config）方法sun公司自动为用户生成一个public void init()的方法
```

（3）Servlet的两种创建方式

（3.1）Servlet的第一种创建方式：继承HttpServlet(推荐)

```
public class Servlet4 extends HttpServlet {
	private static final long serialVersionUID = 1L;
    public Servlet4() {
        super();
    }
	protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {		response.getWriter().append("hahahahaha").append(request.getContextPath());
	}
	protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		doGet(request, response);
	}
}
```

（3.2）Servlet创建的第二种方式：实现接口Servlet

```
public class HelloServlet2 implements Servlet{
	public void destroy() {
	}
	public ServletConfig getServletConfig() {
		return null;
	}
	public String getServletInfo() {
		return null;
	}
	public void init(ServletConfig arg0) throws ServletException {
	}
	public void service(ServletRequest request, ServletResponse response) throws ServletException, IOException {
		System.out.println("OK");
		response.setContentType("text/html;charset=UTF-8");
		response.getWriter().println("我是第二种创建方式");
	}
}
```

（4）Servlet的两种配置方式

（4.1）第一种注解式配置 Servlet3.0及以后 ：

```
@WebServlet("/hello")
public class HelloServlet extends HttpServlet {
}
```

（4.2）第二种web.xml配置 Servlet所有版本都支持：

```
public class HelloServlet extends HttpServlet {
}
<!--单独再添加web.xml文件-->
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://xmlns.jcp.org/xml/ns/javaee" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd" version="3.1">
  <display-name>Web_Day11</display-name>
  <!--Servlet的第二种配置  -->
  <!--Servlet配置  -->
  <servlet>
  <!--名称  -->
    <servlet-name>hello2</servlet-name>
    <!--Servlet的全称类名  -->
    <servlet-class>com.qf.web.servlet.HelloServlet</servlet-class>
    <!--启动的优先级，数字越小越先起作用  -->
    <load-on-startup>1</load-on-startup>
  </servlet>
  <!--映射配置  -->
  <servlet-mapping>
  <!--名称  -->
    <servlet-name>hello2</servlet-name>
    <!--资源的匹配规则：精确匹配  -->
    <url-pattern>/hello2</url-pattern>
  </servlet-mapping>
  <welcome-file-list>
    <welcome-file>login.html</welcome-file>
  </welcome-file-list>
</web-app>
注：容器在进行url-pattern比对的时候是遵循一定的匹配原则的
	url-pattern定义匹配规则，取值说明：
	精确匹配     /具体的名称		只有url路径是具体的名称的时候才会触发Servlet
	后缀匹配     *.xxx			只要是以xxx结尾的就匹配触发Servlet
	通配符匹配   /* 			    匹配所有请求，包含服务器的所有资源
```

（5）生命周期的四个阶段

```
阶段一、实例化（调用构造方法）
实例化阶段是Servlet生命周期中的第一步，由Servlet容器调用Servlet的构造器创建一个具体的Servlet对象的过程。而这个创建的时机可以是在容器收到针对这个组件的请求之后，即用了才创建；也可以在容器启动之后立刻创建实例，而不管此时Servlet是否使用的上。使用如下代码可以设置Servlet是否在服务器启动时就执行创建

阶段二、初始化（init方法）
Servlet在被加载实例化之后，必须要初始化它。在初始化阶段，init（）方法会被调用。这个方法在javax.servlet.Servlet接口中定义。其中，方法以一个ServletConfig类型的对象作为参数。ServletConfig对象由Servlet引擎负责创建，从中可以读取到事先在web.xml文件中通过<init-param>节点配置的多个name-value名值对。ServletConfig对象还可以让Servlet接受一个ServletContext对象。
一般情况下，init方法不需要编写，因GenericServlet已经提供了init方法的实现，并且提供了getServletConfig方法来获得ServletConfig对象。
注：init方法只被执行一次

阶段三、就绪/服务
Servlet被初始化以后就处于能够响应请求的就绪状态。每个对Servlet的请求由一个ServletRequest对象代表，Servlet给客户端的响应由一个ServletResponse对象代表。当客户端有一个请求时，容器就会将请求与响应对象转给Servlet，以参数的形式传给service方法。service方法由javax.servlet.Servlet定义，由具体的Servlet实现
HttpServlet将service方法拆分了。doGet和doPost

阶段四、销毁
Servlet容器在销毁Servlet对象时会调用destroy方法来释放资源。通常情况下Servlet容器停止或者重新启动都会引起销毁Servlet对象的动作，但除此之外，Servlet容器也有自身管理Servlet对象的准则，整个生命周期并不需要人为进行干预
```

（6）获取请求参数（html为例）和处理中文参数的方法

（6.1）为什么表单中会产生中文乱码：产生乱码，就是因为服务器和客户端沟通的编码不一致造成的，因此解决的办法是：在客户端和服务器之间设置一个统一的编码，之后就按照此编码进行数据的传输和接收

（6.1.1）GET中文乱码：在Tomcat7及以下客户端以UTF-8的编码传输数据到服务器端，而服务器端的request对象使用的是ISO8859-1这个字符编码来接收数据，服务器和客户端沟通的编码不一致因此才会产生中文乱码的。解决办法：在接收到数据后，先获取request对象以ISO8859-1字符编码接收到的原始数据的字节数组，然后通过字节数组以指定的编码构建字符串，解决乱码问题。Tomcat8的版本中GET基本就不会乱码了，因为服务器对url的编码格式可以进行自动转换

（6.1.2）POST乱码：由于客户端是以UTF-8字符编码将表单数据传输到服务器端的，因此服务器也需要设置以UTF-8字符编码进行接收，要想完成此操作，服务器可以直接使用从ServletRequest接口继承而来的"setCharacterEncoding(charset)"方法进行统一的编码设置。

（6.1.3）页面返回乱码原因：浏览器识别不到返回的中文是什么编码格式，就会默认使用GB2312,如果返回的是UTF-8格式的那么在浏览器上就会显示乱码的问题，通过response.setContentType("text/html;charset=UTF-8");    response.setCharacterEncoding("UTF-8");

语句可以解决该问题。

```
/*获取请求参数（html为例）和处理中文参数*/
html页面：
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>欢迎页面</title>
</head>
<body>
<h1>欢迎你</h1>
<div>
<!--请求方式默认为get-->
<form action="/项目名/HelloServlet" method="post">
<label>姓名：</label><input name="name"><br/>
<label>年龄：</label><input  name="age"><br/>
<input type="submit" value="提交">
</form>
</div>
</body>
</html>

Servlet代码：
@WebServlet("/HelloServlet")
public class HelloServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	
	protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		//获取表单提交的姓名
		String name=request.getParameter("name");
		//解决get中文乱码问题
		name=new String(name.getBytes("ISO8859-1"),"UTF-8");
		//获取年龄
		String age=request.getParameter("age");
		//服务端输出打印
		System.out.println(request.getRemoteAddr()+"发来信息：姓名："+name+"---->年龄："+age);
	}

	protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		//解决post乱码问题，设置请求参数的编码格式--对GET无效
        request.setCharacterEncoding("UTF-8");
		//获取表单提交的信息
		String name=request.getParameter("msg");
		//服务端输出打印
		System.out.println(request.getRemoteAddr()+"发来信息："+msg);
	}
}
```

（7）Servlet线程安全问题

（7.1）线程安全问题：因为每次请求都会创建一个线程，如果多人同时请求，那么就会存在多个线程操作同一个Servlet对象，那么如果在对应的方法中操作了成员变量，就有可能产生线程安全的问题。

（7.2）如何保证线程安全：

​	      A、synchronized：将存在线程安全问题的代码放到同步代码块中
​	      B、实现SingleThreadModel接口:servlet实现singleThreadModel接口后，每个线程都会创建servlet实例，这样每个客户端请求就不存在共享资源的问题，但是servlet响应客户端请求的效率太低，所以已经淘汰。
​	      C、尽可能只使用局部变量

#### 第九章 过滤器和监听器

##### 9.1 Web过滤器 

（1）什么是过滤器

```
	Filter也称之为过滤器，WEB开发人员通过Filter技术，对web服务器管理的所有web资源：例如Jsp, Servlet, 静态图片文件或静态 html 文件等进行拦截，从而实现一些特殊的功能。例如实现URL级别的权限访问控制、过滤敏感词汇、压缩响应信息等一些高级功能。
　　Servlet API中提供了一个Filter接口，开发web应用时，如果编写的Java类实现了这个接口，则把这个java类称之为过滤器Filter。通过Filter技术，开发人员可以实现用户在访问某个目标资源之前，对访问的请求和响应进行拦截
```

（2）过滤器的编写：编写java类实现Filter接口-->重写doFilter方法-->设置拦截的url

```
/**
 * Servlet Filter implementation class MyFilter1
 */
//@WebFilter(value="/*",initParams= {@WebInitParam(name = "version", value = "2.0")}) //设置过滤的路径/*过滤所有的请求

public class MyFilter1 implements Filter {
    public MyFilter1() {
    }
	public void destroy() {
		System.out.println("过滤器销毁了.......");
	}
	public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
		System.out.println("开始过滤1");
		//资源放行
		chain.doFilter(request, response);//index.html
		System.out.println("过滤完成1");	
	}
	public void init(FilterConfig fConfig) throws ServletException {
		System.out.println("初始化过滤器");
	}
}
```

（3）过滤器的配置与初始化

（3.1）注解式配置与初始化

​	在自定义的Filter类上使用注解@WebFilter(“/*”)

```
@WebFilter(value="/*",initParams= {@WebInitParam(name = "version", value = "1.0")})
public class FirstFilter implements Filter {
	public FirstFilter() {
	}
	public void destroy() {
		System.out.println("destroy销毁……");
	}
	public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
			throws IOException, ServletException {
		System.out.println("doFilter……过滤");
		// 是否继续---访问下一个
		//放行
		chain.doFilter(request, response);
	}
	//初始化
	public void init(FilterConfig fConfig) throws ServletException {
		System.out.println("init……初始化");
		System.out.println("初始化参数：版本号："+fConfig.getInitParameter("version"));
	}
}
```

（3.2）xml配置及初始化

​	在web.xml中进行过滤器的配置及初始化：

```
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://xmlns.jcp.org/xml/ns/javaee" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd" version="3.1">
  <display-name>Web_Day</display-name>
  
  <!--过滤器的xml配置  -->
  <filter>
    <filter-name>myfilter</filter-name>
    <filter-class>com.qf.web.filter.SecondFilter</filter-class>
     <!--过滤器的初始化参数  -->
    <init-param>
      <param-name>version</param-name>
      <param-value>1.0</param-value>
    </init-param>
  </filter>
  <filter-mapping>
    <filter-name>myfilter</filter-name>
    <url-pattern>/*</url-pattern>
  </filter-mapping>
  <welcome-file-list>
    <welcome-file>index.html</welcome-file>
  </welcome-file-list>
</web-app>
```

（4）过滤器链

````
	通常客户端对服务器请求之后，服务器调用Servlet之前会执行一组过滤器（多个过滤器）,那么这组过滤器就称为一条过滤器链。
	每个过滤器实现某个特定的功能，一个过滤器检测多个Servlet。（匹配几个，检测几个）。
````

（5）过滤器的优先级

```
	如果是xml配置，一组过滤器中的执行顺序与<filter-mapping>的配置顺序有关，那个过滤器的<filter-mapping>在前，先执行哪个。
	当第一个Filter的doFilter方法被调用时，web服务器会创建一个代表Filter链的FilterChain对象传递给该方法。在doFilter方法中，开发人员如果调用了FilterChain对象的doFilter方法，则web服务器会检查FilterChain对象中是否还有filter，如果有，则调用第2个filter，如果没有，则调用目标资源
	如果为注解配置的话，是按照类名的字符串顺序进行起作用的。
```

（6）过滤器的优点：

​	  可以实现 Web 应用程序中的预处理和后期处理逻辑

（7）过滤器处理浏览器缓存案例：

​	浏览器缓存与服务器的会话：浏览器第一访问服务器，服务器会返回200代码，内容会从服务器发送到浏览器；浏览再次访问服务器，服务器会返回302代码，提示浏览器看自己缓存，缓存里有该内容，所以会话还是会经过服务器但是服务器不会给浏览器传递实际内容，只回复一个代码302。

​	重启浏览器再访问服务器上述内容时，第一次访问就不再经过服务器，浏览器会自动返回给自己200代码，提示浏览器有该内容的缓存，当继续访问时，就会重新经过服务器，服务器会返回302代码，与之前302代码的叙述就一样了。

```
/**
 * 不读取浏览器缓存Servlet Filter implementation class   	NoCacheFilter
 */
@WebFilter("*.html")
public class NoCacheFilter implements Filter {
    public NoCacheFilter() {
    }
	public void destroy() {
	}
	
	public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
		//父类强转子类，目的是为了使用子类的方法
		HttpServletRequest req=(HttpServletRequest) request;
		HttpServletResponse resp=(HttpServletResponse) response;	
		//控制浏览器缓存（没有缓存,其实控制第一次访问不走浏览器缓存），要注意理解控制缓存的意思，控制缓存只是让浏览器在访问的时候不去访问浏览器缓存，但是并不能阻止浏览器缓存
		//设置时间期限为到期
		resp.setDateHeader("Expires", -1);
		resp.setHeader("Cache-Control", "no-cache");
		resp.setHeader("Pragma", "no-cache");
		System.out.println("xxxx");
		//资源放行
		chain.doFilter(request, response);
	}
	public void init(FilterConfig fConfig) throws ServletException {
	}
}

/**
 * 读取浏览器缓存Servlet Filter implementation class CacheFilter
 */
@WebFilter("*.jpg")
public class CacheFilter implements Filter {
    public CacheFilter() {
    }
	public void destroy() {
	}
	public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
		HttpServletRequest req=(HttpServletRequest) request;
		HttpServletResponse resp=(HttpServletResponse) response;
		
		//resp.setDateHeader("Expires", System.currentTimeMillis()+200000);
		//由于不同的浏览器对于缓存设置识别不一致，故提供又一写法
		 resp.setHeader("Cache-Control", "max-age=20000");
		System.out.println("yyyy");
		chain.doFilter(request, response);
	}
	public void init(FilterConfig fConfig) throws ServletException {
	}
}
```

##### 9.1.1 全站压缩

​	全站压缩（Servlet响应内容的压缩）

​	全站压缩就是将服务器的响应结果（即在服务器向浏览器发送数据环节上施加效果）给压缩为gzip的格式，以便达到浏览器和服务器传输，设置消息头让浏览器自动解压。

​	压缩过程实际是服务器数据先原样写到内存流，然后内存流经过过滤器进行压缩。

​	全站压缩实际上只能对服务器响应的文字内容进行压缩，图片压缩不明显，只缩小很小一部分，对于其他类型文件不能压缩，也许是老王实力有限，程序有局限性，而实质上全站压缩是对所有数据都可以进行压缩。

```
/**
 * 当对响应内容进行压缩时，内容不走装饰类中getWriter方法，此时 内容就无法写到内存流中，故建立此服务器，强行调用getWriter方法Servlet implementation class MyServlet，故压缩响应的文字内容时要访问此服务器myservlet
 */
@WebServlet("/myservlet")
public class MyServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
    
    public MyServlet() {
        super();
    }

	protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		//1乱码
		request.setCharacterEncoding("utf-8");		response.setContentType("text/html;charset=utf-8");
		//2写，写到了内存流中
		PrintWriter out=response.getWriter();
		out.write("历史长河奔流不息，真理的光芒穿越时空。 　　1818年5月5日，一代伟人马克思诞生。 　　200年后，世界东方。高擎马克思主义的精神火炬，在习近平新时代中国特色社会主义思想指引下，中国共产党正领导亿万人民书写人类发展史上新的奇迹。 　　“历史和人民选择马克思主义是完全正确的，中国共产党把马克思主义写在自己的旗帜上是完全正确的，坚持马克思主义基本原理同中国具体实际相结合、不断推进马克思主义中国化时代化是完全正确的！” 　　习近平总书记向世人庄严宣示——“前进道路上，我们要继续高扬马克思主义伟大旗帜，让马克思、恩格斯设想的人类社会美好前景不断在中国大地上生动展现出来！” 　　为人民谋幸福，为民族谋复兴，为世界谋大同。真理的光芒，将照耀我们，不忘初心，继续前行！ 　　今天，新华社推出纪念马克思诞辰200周年特别策划《真理的光芒》。");		
	}
	protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		doGet(request, response);
	}
}

/**
 * 乱码过滤器，解压缩过程中乱码问题
 */
@WebFilter("/CharacterEncodingFilter")
public class CharacterEncodingFilter implements Filter {
    public CharacterEncodingFilter() {
    }
	public void destroy() 
	}
	public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {	
		//乱码
		request.setCharacterEncoding("utf-8");
		response.setCharacterEncoding("utf-8");
		chain.doFilter(request, response);
	}
	public void init(FilterConfig fConfig) throws ServletException {
	}
}

/**
 * 压缩过滤器Servlet Filter implementation class GzipFilter
 */
@WebFilter("/myservlet")
public class GzipFilter implements Filter {
    public GzipFilter() {
    }
	public void destroy() {
	}
	public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
		//压缩前
		//1需要装饰response对象，故需要创建装饰类
		HttpServletRequest req=(HttpServletRequest) request;
		GzipResponse resp=new GzipResponse((HttpServletResponse)response);
		chain.doFilter(req, resp);
		
		//压缩：是对服务器向浏览器发送的数据进行操作
		ByteArrayOutputStream baos=resp.getBaos();
		System.out.println("压缩前数据大小:"+baos.size());
		ByteArrayOutputStream newbaos=new ByteArrayOutputStream();//保存压缩的数据
		//压缩类
		GZIPOutputStream gzip=new GZIPOutputStream(newbaos);
		//压缩操作
		gzip.write(baos.toByteArray());
		gzip.flush();
		gzip.close();
		System.out.println("压缩后数据大小:"+newbaos.size());
		//把压缩后的数据给浏览器
		//告诉浏览器数据是压缩的
		resp.setHeader("Content-Encoding", "gzip");
		resp.getOutputStream().write(newbaos.toByteArray())	
	}
	public void init(FilterConfig fConfig) throws ServletException {
	}
}

/**
*建立装饰类，目的是为了装饰response，因为response执行写操作会直接写到浏览器上，无法完成压缩操作，要把它装饰一下把数据写到内存流中
*/
public class GzipResponse extends HttpServletResponseWrapper{

	private ByteArrayOutputStream baos;
	private PrintWriter pw;
	
	public GzipResponse(HttpServletResponse response) {
		super(response);
		baos=new ByteArrayOutputStream();
	}
	public PrintWriter getWriter() throws IOException {
		pw=new PrintWriter(baos,true);
		System.out.println("xxxx");
		return pw;
	}
	public ByteArrayOutputStream getBaos() {
		if(pw!=null) {
			pw.flush();//把PrintWriter有缓存，
		}
		return baos;
	}
}

/**
 * 压缩图片Servlet Filter implementation class ImageFilter
 */
@WebFilter("*.jpg")
public class ImageFilter implements Filter {
    public ImageFilter() {
    }
	public void destroy() {
	}
	public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
		HttpServletRequest req=(HttpServletRequest) request;
		HttpServletResponse resp=(HttpServletResponse) response;
		//得到请求的路径
		String uri = req.getRequestURI();
		String path=uri.substring(req.getContextPath().length()+1);
		//自己读取文件
		String realpath=req.getServletContext().getRealPath(path);
		FileInputStream fis=new FileInputStream(realpath);
		ByteArrayOutputStream baos=new ByteArrayOutputStream();
		byte[] buf=new byte[1024*4];
		int len=0;
		while((len=fis.read(buf))!=-1) {
			baos.write(buf, 0, len);
		}
		System.out.println("压缩前："+baos.size());
		//压缩
		ByteArrayOutputStream newbaos=new ByteArrayOutputStream();
		GZIPOutputStream gzip=new GZIPOutputStream(newbaos);
		gzip.write(baos.toByteArray());
		gzip.flush();
		gzip.close();
		System.out.println("压缩后："+newbaos.size());
		
		resp.setHeader("Content-Encoding", "gzip");	resp.getOutputStream().write(newbaos.toByteArray());

	}
	public void init(FilterConfig fConfig) throws ServletException {
	}
}
```

##### 9.2  过滤器案例

（1）自动登录，涉及session，cookie，过滤器，html

```
/**
*创建实体类,包com.qf.domain
*/
public class User {
	private String username;
	private String password;
	public User() {
	}
	public User(String username, String password) {
		super();
		this.username = username;
		this.password = password;
	}
	
	/*get,set函数*/

	public String toString() {
		return "User [username=" + username + ", password=" + password + "]";
	}	
}

/**
*登录界面html,文件夹WebContent下
*/
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>用户登录</title>
</head>
<body>
	<h2>用户登录</h2>
	<form action="/day14web2/loginservlet" method="post">
		用户名:<input type="text" name="username"/><br/>
		密码:<input type="password" name="password"><br/>
		<input type="submit" value="登录"/>
		
	</form>
</body>
</html>

/**
 * 服务器接收登录信息，包com.qf.servlet下Servlet implementation class LoginServlet
 */
@WebServlet("/loginservlet")
public class LoginServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
    public LoginServlet() {
        super();
    }
	protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		//1乱码
		request.setCharacterEncoding("utf-8");
		response.setContentType("text/html;charset=utf-8");
		//2接收数据
		String username = request.getParameter("username");
		String password=request.getParameter("password");
		//3判断			if(username.equals("admin")&&password.equals("123456")) {
			//登录成功
			HttpSession session = request.getSession();
			User user=new User(username, password);
			//session存了用户
			session.setAttribute("user", user);
			//给浏览器cookie
			Cookie cookie=new Cookie("userinfo", username+"#"+password);
			cookie.setMaxAge(60*60*24*7);
			cookie.setPath("/");
			cookie.setHttpOnly(true);
			response.addCookie(cookie);			response.sendRedirect(request.getContextPath()+"/index.html");
			return;
		}		response.sendRedirect(request.getContextPath()+"/login.html");
	}
	protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		doGet(request, response);
	}
}

/**
*首页界面html,文件夹WebContent下
*/
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>首页</title>
</head>
<body>
	网站首页
</body>
</html>

/**
 * 自动登录过滤器Servlet Filter implementation class AutoLoginFilter
 */
@WebFilter("/login.html")
public class AutoLoginFilter implements Filter {
    public AutoLoginFilter() {
    }
	public void destroy() {
	}
	public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
		//1 登录过，session中存在用户
		HttpServletRequest req=(HttpServletRequest) request;
		HttpServletResponse resp=(HttpServletResponse) response;
		
		HttpSession session = req.getSession();
		User user = (User) session.getAttribute("user");
		if(user!=null) {			req.getRequestDispatcher("/index.html").forward(request, response);
			return;
		}else {
			//读取浏览器发送的cookie
			Cookie[] cookies = req.getCookies();
			if(cookies!=null) {
				for (Cookie cookie : cookies) {
					if(cookie.getName().equals("userinfo")) {
						String userinfo = cookie.getValue();
						String[] userinfos = userinfo.split("#");
						if(userinfos[0].equals("admin")&&userinfos[1].equals("123456")) {
							req.getRequestDispatcher("/index.html").forward(request, response);
							return;
						}
					}
				}	
			}	
		}
		//放行
		chain.doFilter(request, response);
	}
	public void init(FilterConfig fConfig) throws ServletException {
	}
}

/**
 * 不读取浏览器缓存Servlet Filter implementation class   	NoCacheFilter，此段代码原理解释详见Web过滤器浏览缓存控制部分内容
 *添加这一过滤器原因在于：在登录一次之后，第二次重新访问登录页面（注意重新访问和刷新的区别）时，浏览器可能不走服务器直接找自己的缓存（200代码），这时就会到达登录页面从而不能实现自动登录，当然刷新一下之后就可以直接自动登录了，为解决这一问题特意添加此段代码
 */
@WebFilter(value= {"*.html","*.jsp"})
public class NoCacheFilter implements Filter {
    public NoCacheFilter() {
    }
	public void destroy() {
	}
	public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
		HttpServletRequest req=(HttpServletRequest) request;
		HttpServletResponse resp=(HttpServletResponse) response;
		resp.setDateHeader("Expires", -1);
		resp.setHeader("Cache-Control", "no-cache");
		resp.setHeader("Pragma", "no-cache");
		chain.doFilter(request, response);
	}
	public void init(FilterConfig fConfig) throws ServletException {
	}
}
```

##### 9.3  监听器使用案例

​	总论：

​	监听器创建时不必创建listener类，直接创建普通类然后根据要求实现不同的监听接口或者监听类即可。

​	监听器配置：

```
/**
*在web.xml中进行配置
*/
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://xmlns.jcp.org/xml/ns/javaee" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd" version="3.1">
  <display-name>day15web1</display-name>
  <welcome-file-list>
    <welcome-file>index.html</welcome-file>
    <welcome-file>index.htm</welcome-file>
    <welcome-file>index.jsp</welcome-file>
    <welcome-file>default.html</welcome-file>
    <welcome-file>default.htm</welcome-file>
    <welcome-file>default.jsp</welcome-file>
  </welcome-file-list>
  <!-- <listener>
    <listener-class>com.qf.listener.MyServletContextListener</listener-class>
  </listener> -->
  <session-config>
    <session-timeout>1</session-timeout>
  </session-config>
</web-app>

/**
*注解式配置
*/
Servlet3.0之后新增的，使用注解@WebListener进行监听器的注册
```

​	用于监听的服务器文件1:简单的增删改除

```
/**
 * myservlet1:Servlet implementation class MyServlet1
 */
@WebServlet("/myservlet1")
public class MyServlet1 extends HttpServlet {
	private static final long serialVersionUID = 1L;
    public MyServlet1() {
        super();
    }
	protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		ServletContext application = request.getServletContext();
		//添加
		application.setAttribute("username", "张三");
		application.setAttribute("age", 20);
		//移除
		application.removeAttribute("age");
		//替换
		application.setAttribute("username", "李四");
		//获取session
		HttpSession session = request.getSession();
		
	/*	User user=new User();
		user.setUsername("xxx");
		user.setPassword("123");
		session.setAttribute("user", user);*/
		
		//session.removeAttribute("user");
		request.setAttribute("address", "beijing");
		request.removeAttribute("address");
	}

	
	protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		doGet(request, response);
	}
}
```

​	用于监听的服务器文件2:统计上线人数

```
/**
*创建实体类作为监听对象
*/
public class User implements HttpSessionBindingListener{
	private String username;
	private String password;
	private String email;
	public User() {
	}
	public User(String username, String password, String email) {
		super();
		this.username = username;
		this.password = password;
		this.email = email;
	}
	
	/*set``````get函数*/
	
	public String toString() {
		return "User [username=" + username + ", password=" + password + ", email=" + email + "]";
	}
	public void valueBound(HttpSessionBindingEvent event) {
		System.out.println("向session添加了"+event.getName()+"....."+event.getValue());
		//获取ServetContext
		ServletContext application = event.getSession().getServletContext();
		Integer count = (Integer) application.getAttribute("count");
		if(count==null) {
			count=1;
		}else {
			count++;
		}
		application.setAttribute("count",count);
	}
	//把user对象从sesssion移除
	public void valueUnbound(HttpSessionBindingEvent event) {
		System.out.println("从session移除了"+event.getName()+"....."+event.getValue());
		
		ServletContext application = event.getSession().getServletContext();
		Integer count = (Integer) application.getAttribute("count");
		count--;
		application.setAttribute("count",count);
	}	
}

/**
 * myservlet2:Servlet implementation class MyServlet2
 */
@WebServlet("/myservlet2")
public class MyServlet2 extends HttpServlet {
	private static final long serialVersionUID = 1L;
    public MyServlet2() {
        super();
    }
	protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		//乱码
		request.setCharacterEncoding("utf-8");
		response.setContentType("text/html;charset=utf-8");
		PrintWriter out=response.getWriter();
		ServletContext application = request.getServletContext();
		Integer count = (Integer) application.getAttribute("count");
		if(count==null) {
			out.write("当前在线用户：0");
		}else {
			out.write("当前在线用户："+count);
		}
	}
	protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		doGet(request, response);
	}
}
```

（1）监听器简介

​	监听器用于监听web应用中某些对象、信息的创建、销毁、增加，修改，删除等动作的发生，然后作出相应的响应处理。当范围对象的状态发生变化的时候，服务器自动调用监听器对象中的方法。常用于统计在线人数和在线用户，系统加载时进行信息初始化，统计网站的访问量等等

（1.1）监听器类型

（1.1.1）监听ServletContext的变化

 	a.监听生命周期 ServletContextListener接口

​	    初始化：contextInitialized    销毁：contextDestroyed

​	b.监听属性内容变化ServletContextAttributeListener接口

​	     添加,移除,修改

```
/**
 * Servlet上下文监听器
 * 事件（初始化、销毁）                         
 */
//@WebListener
public class MyServletContextListener implements ServletContextListener{
	public void contextInitialized(ServletContextEvent sce) {
		System.out.println("servletContext初始化了..."+sce.getServletContext().hashCode());
	}
	public void contextDestroyed(ServletContextEvent sce) {
		System.out.println("servletContext销毁了..."+sce.getServletContext().hashCode());	
	}
}

/**
 * 监听ServletContext上下文中的属性的变化
 */
//@WebListener
public class MyServletContextAttributeListerner implements ServletContextAttributeListener {
	public void attributeAdded(ServletContextAttributeEvent scae) {
		System.out.println("上下文中添加了"+scae.getName()+"....."+scae.getValue());
	}

	public void attributeRemoved(ServletContextAttributeEvent scae) {
		System.out.println("上下文中移除了"+scae.getName()+"....."+scae.getValue());
	}

	public void attributeReplaced(ServletContextAttributeEvent scae) {		
		System.out.println("上下文中替换了"+scae.getName()+"....."+scae.getValue());
	}
}
```

（1.1.2）监听HttpSession变化

​	a.监听生命周期 HttpSessionListener

​	    sessionCreated：监听Session对象的创建

​	    sessionDestroyed：监听Session对象的销毁

​	b.监听属性内容变化 HttpSessionAttributeListener

​	    attributeAdded：监听属性的添加

​	    attributeRemoved：监听属性的移除

​	    attributeReplaced：监听属性的修改

​	c.监听HttpSession的钝化和活化	  

​			HttpSessionActivationListener

​		监听Session内部存储对象的钝化-存储

​			sessionWillPassivate

​		监听Session内部存储对象的活化---读取

​			sessionDidActivate

​		对应类需要实现序列化接口Serializable

​	d.监听对象的添加和移除HttpSessionBindingListener

​		监听对象的绑定     valueBound

​	        监听对象的解除绑定 valueUnbound

```
/**
*监听HttpSession的生命周期
*/
//@WebListener
public class MySessionListerner implements HttpSessionListener{
	public void sessionCreated(HttpSessionEvent se) {
		System.out.println("session创建了...."+se.getSession().hashCode());
	}
	public void sessionDestroyed(HttpSessionEvent se) {
		System.out.println("session销毁了......"+se.getSession().hashCode());
	}
	//Session中属性内容的添加
	public void attributeAdded(HttpSessionBindingEvent event)  { 
    }
    //Session中属性内容的移除
    public void attributeRemoved(HttpSessionBindingEvent event)  { 
    }
    //Session中属性内容的修改
    public void attributeReplaced(HttpSessionBindingEvent event)  { 
    }
    //监听HttpSession的id的变化，Servlet3.1新特性
	public void sessionIdChanged(HttpSessionEvent event, String oldSessionId) {		
	}
}

/*
 * Session管理器
 */
@WebListener
public class SessionManagerListener implements HttpSessionListener,ServletContextListener {

	//定时器
	private Timer timer;
	private Object lock=new Object();
	private List<HttpSession> sessions=new LinkedList<HttpSession>();
	
	public void contextInitialized(ServletContextEvent sce) {
		//初始化上下文
		//启动定时器
		timer=new Timer();
		timer.schedule(new MyTimerTask(), 0, 60*1000);
		sce.getServletContext().setAttribute("sessions", sessions);
		System.out.println("定时器执行了.....");	
	}

	public void contextDestroyed(ServletContextEvent sce) {	
		//timer.cancel();//取消定时器
		//System.out.println("定时器取消了...");
	}

	public void sessionCreated(HttpSessionEvent se) {
		synchronized (lock) {
			System.out.println("添加了一个session"+se.getSession().hashCode());
			sessions.add(se.getSession());
		}	
	}

	public void sessionDestroyed(HttpSessionEvent se) {
		System.out.println("session销毁了"+se.getSession().hashCode());	
	}
	
	private  class MyTimerTask extends TimerTask{
		public void run() {//1分钟执行一次
			Iterator<HttpSession> iterator = sessions.iterator();
			synchronized (lock) {
				while(iterator.hasNext()) {
					HttpSession session=iterator.next();
					if(System.currentTimeMillis()-session.getLastAccessedTime()>(60*1000)) {
						session.invalidate();//失效
						iterator.remove();//把元素移除
					}
				}
			}	
		}
	}
}
```

1.1.3 监听ServletRequest的变化

​	a.监听生命周期 ServletRequestListener

​	    requestInitialized：监听request对象的初始化

​	    requestDestroyed：监听request对象的销毁

​	b.监听属性内容变化 ServletRequestAttributeListener

​	    attributeAdded：监听属性的添加

​	    attributeRemoved：监听属性的移除

​	    attributeReplaced：监听属性的修改

```
/**
*监听ServletRequest初始化与销毁
*/
//@WebListener
public class MyServletRequestListener implements ServletRequestListener {
	public void requestDestroyed(ServletRequestEvent sre) {
		//异步监听---完成
		 public void onComplete(AsyncEvent event) throws java.io.IOException { 
    }
		//异步监听---错误
		public void onError(AsyncEvent event) throws java.io.IOException { 
    }
    	//异步监听---启动
    	 public void onStartAsync(AsyncEvent event) throws java.io.IOException { 
    }
    	//异步监听---超时
    	public void onTimeout(AsyncEvent event) throws java.io.IOException { 
        
    }
		System.out.println("请求销毁了...."+sre.getServletRequest().hashCode());
	}
	public void requestInitialized(ServletRequestEvent sre) {
		System.out.println("请求初始化了...."+sre.getServletRequest().hashCode());
	}
}

/**
*监听ServletRequest属性变化
*/
//@WebListener
public class MyServletRequestAttributeListener implements ServletRequestAttributeListener{
	public void attributeAdded(ServletRequestAttributeEvent srae) {
		System.out.println("request对象中添加数据:"+srae.getName()+"..."+srae.getValue());
	}
	public void attributeRemoved(ServletRequestAttributeEvent srae) {
		System.out.println("request对象中移除数据:"+srae.getName()+"..."+srae.getValue());
	}
	public void attributeReplaced(ServletRequestAttributeEvent srae) {		
	}
}
```



#### 第十章 JSP、EL、JSTL 

##### 10.1  JSP(pageContext)

（1）JSP是什么

```
 	全称： Java Server Pages,java服务器页面。和Servlet一样，是sun公司定义的一种动态网页开发技术。
    特点：基于html模版，可以在html模版嵌入java代码和jsp中的标签。
备注：html静态页面。
     CSS:修饰美化html页面。
     JavaScript:动态修改html页面和css样式。
     Servlet：运行在服务器上的java程序。适合编写java代码，写网页困难,适合业务处理
     jsp:适合编写动态内容，不适合写java代码，主要用于显示页面
     jsp文件一般建立在WebContent文件夹下。
```

（2）JSP特点和优势

```
	特点：
	1 jsp性能好，可以在html页面中动态嵌入元素
    2 服务器调用的是已经编译好的JSP文件
    3 JSP基于Java Servlet Api,有很多强大企业的支持。
    4 JSP可以与处理业务逻辑的Servlet一起使用，该模式被Java Servlet模版引擎所支持。
    优势：
    1 与纯 Servlet 相比：JSP可以很方便的编写或者修改HTML网页而不用去面对大量的println语句
    2 与JavaScript相比：虽然JavaScript可以在客户端动态生成HTML，但是很难与服务器交互，因此不能提供复杂的服务，比如访问数据库和图像处理等等。
    3 与静态HTML相比：静态HTML不包含动态信息
```

（3）JSP语法

​	当项目加载到Tomcat后并执行完一次访问后，会在tomcat文件夹下worker文件夹下n级目录下有一个本项目的文件夹，打开文件夹里面会有一个java文件，打开该文件可以看到浏览器执行jsp文件的原理代码，再结合Tomcat源码即可进一步了解工作原理。Tomcat源码是一个压缩文件单独存在的，我已存到云盘。

（3.1）JSP语法格式

​	JSP页面中可以包含任意量的Java语句、变量、方法或表达式、(html、css、javascript)静态内容

```
/**
*第一个jsp页面
*/
<!--格式1 指令，页面设置信息-->
<%@ page import="java.util.Date"%>
<!--contentType页面类型-->
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>

<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html;    
	charset="utf-8">
<title>第一个jsp页面</title>
</head>
<body>
	欢迎使用jsp技术
	<!--格式2 脚本:java代码执行完后删除，在浏览器源码中不体现-->
	<%
		//声明变量
		int number=10;
		Date now=new Date();
		//输出
		out.println(number+"<br/>");
		out.println(now.toLocaleString()+"<br/>");
		//for循环
		for(int i=0;i<10;i++){
			out.println("好好学习，天天向上<br/>");
		}
		String name="小张";
		int age=20;
	%>
	
	<!--格式3脚本表达式,等价于输出语句,不能以分号结束-->
	<%=name %><br/>
	<%=age %><br/>
	
	<!--格式4 声明（了解）-->

	<%!
		<格式4.1 声明中方法>
		public void show(){
			String address="北京昌平";
			System.out.println(address);	
		}
		//把小写字符串变成 首 字母大写
		public String letterToUpper(String s){
		//substring(1)表示从第一个字符后分割
			String result=Character.toUpperCase(s.charAt(0))+s.substring(1);
			return result;
		}
	%>
	
	<%
		show();
		String s=letterToUpper("hello");
		out.print(s);
	%>
	
	<%--jsp注释 在浏览器中看不见的 安全省流量--%>
	<!-- 网页注释 不安全，耗流量 --> 
</body>
</html>
```

（3.2） JSP指令

​	告诉JSP引擎如何jsp文件中的内容
​               语法： <%@ 指令名称 属性名称1＝“属性值1” 属性名称2＝“属性值2” 。。。。。%>
​               示例：<%@ page language=*"java"* contentType="text/html; charset=UTF-8"  pageEncoding=*"UTF-8"*%>

（3.3）page指令

​	作用：用于定义JSP页面的各种属性

​	session:是否会自动创建session对象，默认值为true;

​	buffer:JSP中有java.servlet.jsp.JspWriter输出字符流。设置输出数据的缓存大小。默认8kb.

​	errorPage:如果页面中有错误，跳转到指定的资源 

​	errorPage="/uri" 如果写“/”则代表当前应用的目录下，绝对路径。  如果不写“/”则代表相对路径

​	isErrorPage:是否创建throwable对象。默认是false

​	contentType:等同于response.setContentType(“text/html”；charset=utf-8);服务器发送客户端的内容编码

​	pageEncoding: Jsp文件本身的编码

​	isELIgnored: 是否支持EL表达式。 默认是false,支持表达式;是true表示不支持表达式，${1+1};false输出结果2   true按照原样输出  

```
/**
*error jsp页面：用于报错时的跳转页面
*/
<%@ page language="java" contentType="text/html; charset=UTF-8"
	<!--isErrorPage用于标志本页面是错误页面-->
    pageEncoding="UTF-8" isErrorPage="true"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>
	这是一个错误页面
</body>
</html>

/**
*第二个jsp页面
*/
<%@page import="java.util.ArrayList"%>
<%@page import="java.util.List"%>
<%@ page language="java" contentType="text/html; charset=UTF-8"
	<!--errorPage设置有错误就跳转至error.jsp"-->
    pageEncoding="UTF-8" errorPage="/error.jsp" isELIgnore="false"%>
<!DOCTYPE html">
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>

<%
	/* List<String> name=new ArrayList<String>();
	name.add("xxx"); */
	out.println("hello,你好");//输出到缓冲区中，并没有放入response中，所以“hello,你好”要比“啊哈”显示的晚
	response.getWriter().write("啊哈哈哈哈");//写入response中
	
	//int i=10/0;//用于报错跳转使用
	
	/* out和 response.getWriter()的区别
		1 out的类型JspWriter, response.getWriter()是PrintWriter类型
		2 out输出的内容会放入缓存中，并没有直接放入response中，response.getWriter()会直接放入responsez中
		3 servlet中常使用getWriter(), jsp常使用out对象
	*/	
%>
	${1+1}
</body>
</html>
```

（3.4）include指令

（3.4.1）静态包含：把其它资源包含到当前页面中  <%@ include file="header.jsp" %>,此时tomcat不会加载header.jsp文件,即不会产生header.java文件，但是当前页面源码中会出现header.jsp被包含的资源代码，也就是说静态包含相当于把别人的作业抄到自己作业本上一样。

​	动态包含：把其它资源包含到当前页面中 <jsp:include page=“header.jsp"></jsp:include>，此时tomcat加载header.jsp文件,产生header.java文件，即动态包含相当于把别人的作业直接交上去一样。

​	两者的区别：翻译的时间段不同(可在tomcat工作目录下查看)

​			静态包含：在翻译时就把两个文件进行合并

​			动态包含：不会合并文件，当代码执行到include时，才包含另一个文件的内容           

​	静态包含常用，因为他的效率更高。

````
/**
*footer.jsp，用于被include的资源
*/
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<div id="footer">
		关于千锋 | 联系我们 | 企业合作 | 招贤纳士 | 报名咨询 | 教学视频 | 学员论坛 | RSS订阅|站长统计
Copyright 2011-2015 北京千锋互联科技有限公司 京ICP备12003911号-3 京公网安备11010802011455号
</div>

/**
*index.jsp，演示include
*/
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>千锋首页</title>
</head>
<body>
	欢迎访问千锋xxxxxx
	<!--静态包含，此时tomcat不会加载footer文件-->
	<%-- <%@include file="/footer.jsp" %> --%>
	<!--动态包含 -->
	<%-- <jsp:include page="/footer.jsp"></jsp:include> --%>
	<%
		<!-- pageContext提供了动态包含的简易方法-->
		pageContext.include("/footer.jsp");
	%>
</body>
</html>
````

（3.5）taglib指令

```
作用：在JSP页面中导入JSTL标签库。替换jsp中的java代码片段。
<%@ taglib uri="http://java.sun.com/jsp/jstl/core"prefix="c" %> 
```

（4） JSP的6个动作标签

​	使用标签的形式表示一段java代码，例如：

```
 	jsp:include 动态包含
	jsp:forward请求转发
	jsp:param 请求设置参数
	jsp:useBean 创建一个对象
	jsp:setProperty给指定的对象属性赋值
	jsp:getProperty取出指定的对象属值
```

（4.1）请求转发设置参数演示

```
/**
*forword1用于传递参数，转发实现页面跳转
*/
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>forward1页面</title>
</head>
<body>
	第一个页面
<%-- 	<%	request.getRequestDispatcher("/forward2.jsp").forward(request, response);
	%> --%>
	
	<!-- jsp动作标签代替上述转发代码  jsp:forward-->
	<jsp:forward page="/forward2.jsp">
		<jsp:param value="zhangsan" name="username"/>
	</jsp:forward>
	
	<!-- pageContext提供了转发的简易方法-->
	pageContext.forward(“forward2.jsp”);
</body>
</html>

/**
*forword2用于接收参数，接收页面跳转
*/
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>forward2页面</title>
</head>
<body>
	第二个页面
	<%
		String name=request.getParameter("username");
		out.println(name);
	%>
</body>
</html>
```

（4.2）创建对象演示

```
/**
*userbean.jsp用于创建对象
*/
<%@page import="com.qf.domain.User"%>
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>userbean动作标签</title>
</head>
<body>

	<%-- <%
		User user=new User();
	%> --%>

	<!-- 1创建bean-->
	<jsp:useBean id="user" class="com.qf.domain.User"></jsp:useBean>
	
	<!--2 赋值  -->
	<jsp:setProperty property="username" name="user" value="张三" />
	<jsp:setProperty property="password" name="user" value="123456" />
	
	<!--3获取  -->
	<jsp:getProperty property="username" name="user"/><br/>
	<jsp:getProperty property="password" name="user"/>
	
	
<%-- 	<%=user.toString() %> --%>
</body>
</html>

/**
*user实体类，建在包com.qf.domain下
*/
public class User {
	private String username;
	private String password;
	public User() {
		// TODO Auto-generated constructor stub
	}
	public User(String username, String password) {
		super();
		this.username = username;
		this.password = password;
	}
	
	/*set....get函数*/
	
	public String toString() {
		return "User [username=" + username + ", password=" + password + "]";
	}	
}
```

（5）内置对象

| 对象名             | 类型                                     | 说明                          |
| --------------- | -------------------------------------- | --------------------------- |
| request         | javax.servlet.http.HttpServletRequest  |                             |
| response        | javax.servlet.http.HttpServletResponse |                             |
| session         | javax.servlet.http.HttpSession         | 由session=“true”开关           |
| application     | javax.servlet.ServletContext           |                             |
| config          | javax.servlet.ServletConfig            |                             |
| exception       | java.lang.Throwable                    | 由isErrorPage=“false”开关      |
| out             | javax.servlet.jsp.JspWriter            | javax.servlet.jsp.JspWriter |
| **pageContext** | javax.servlet.jsp.PageContext          |                             |
| page            | java.lang.Object当前对象this               | 当前servlet实例                 |

r r s a c e o p p

```
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Jsp九个内置对象</title>
</head>
<body>
	<!-- 脚本 -->
	<%
		/*request请求对象  */
		out.println(request.getRequestURL()+"<br/>");
		out.println(request.getContextPath()+"<br/>");
		//request.setAttribute("username", "小张");
		
		//response响应对象
		response.getWriter().write("嘎嘎嘎嘎<br/>");
		//session会话对象
		session.setAttribute("username", "xiaocang");
		//application全局对象
		application.setAttribute("count", 10);
		
		//config配置对象--初始化参数
		//exception异常对象
		//out输出对象对象
		out.println("yyyyyyyyyyyyyyy<br/>");
		//pageContext页面上下文对象 1 获取其他8个对象 ，2 作为容器，   request   session  application
		pageContext.setAttribute("age", 20);
		pageContext.getAttribute("age");
		//pageContext 获取其他三个域中的数据  request session application
		String u=(String)pageContext.findAttribute("username");// pageContext--->request--->session---application
		out.println(u+"<br>");
		Integer c=(Integer)pageContext.findAttribute("count");
		out.println(c);
	%>
		//page当前页面对象
</body>
</html>
```

（6）pageContext对象

（6.1）域对象

​	jsp中共包含四个域对象分别是request、session、application、pageContext，其中pageContext可以操作其他三个域对象(request,session,application)的数据

（6.2）它可以访问其它的8个隐式对象

​	在普通类中可以通过PageContext获取其它JSP隐式对象,具体如下:

```
getException方法返回exception隐式对象 
getPage方法返回page隐式对象
getRequest方法返回request隐式对象 
getResponse方法返回response隐式对象 
getServletConfig方法返回config隐式对象
getServletContext方法返回application隐式对象
getSession方法返回session隐式对象 
getOut方法返回out隐式对象
```

（6.3）提供了简易方法

```
pageContext.forward(“2.jsp”);//转发  request.getRequestDispatcher().forward();
pageContext.include(“2.jsp”);//动态包含
```

（6.4）pageContext演示

```
/**
*pageContext四大域对象加载
*/
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>四大域对象</title>
</head>
<body>

	<!-- pageContext 页面上下文 -->
	<%
		//pageContext  (适合同一个页面中使用)
		pageContext.setAttribute("name", "凤姐");
		//request   (适合同一个请求，请求用完就不再用了,查询stu=110)
		request.setAttribute("name", "张莎强");
		//sesion   (适合同一个会话共享数据 ，比如登录信息)
		session.setAttribute("name", "老张");
		//application（适合所有用户共享的信息）
		application.setAttribute("name", "老王");
		
		//pageContext特殊使用
		pageContext.setAttribute("age", 20,PageContext.APPLICATION_SCOPE);
	
	%>
	
	<!-- 输出 -->
	<%
		String name=(String)pageContext.getAttribute("name");
		out.println(name);
		
		
		request.getRequestDispatcher("/third.jsp").forward(request, response);
	%>
	
</body>
</html>

/**
*演示pageContext获取其他域对象
*/
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>第三个页面</title>
</head>
<body>
	第三个页面
	<%
		String name=(String)pageContext.getAttribute("name");
		out.print("<br/>------------从pageContext-----------<br/>");
		out.println(name);
		out.print("<br/>------------从request-----------<br/>");
		String name2=(String)request.getAttribute("name");
		out.println(name2);
		out.print("<br/>------------从session-----------<br/>");
		String name3=(String)session.getAttribute("name");
		out.println(name3);
		out.print("<br/>------------从applicatioin-----------<br/>");
		String name4=(String)application.getAttribute("name");
		out.println(name4);
		
		Integer age=(Integer)application.getAttribute("age");
		out.println(age);
		
	%>
</body>
</html>
```

##### 10.2  EL表达式

（1）EL概述和基本语法

​        EL表达式:Expression Language表达式语言
​        目的:简化jsp中java代码开发，代替脚本表达式<%=username%>
​        它不是一种开发语言，是jsp中获取数据的一种规范
​        格式如： ${EL表达式} 等价于findAttribute(name)

（2）EL的简单语句

````
/**
*User实体类，包com.qf.domain下
*/
public class User {	
	private String username;
	private String password;
	private String sex;
	private String phone;
	private Address address;
	
	public User() {
	}
	
	public User(String username, String password, String sex, String phone, Address address) {
		super();
		this.username = username;
		this.password = password;
		this.sex = sex;
		this.phone = phone;
		this.address = address;
	}

	/*set......get函数*/
	
	public String toString() {
		return "User [username=" + username + ", password=" + password + ", sex=" + sex + ", phone=" + phone
				+ ", address=" + address + "]";
	}
 
}

/**
*Address实体类，包com.qf.domain下
*/
public class Address {
	private String country;
	private String province;
	private String city;
	private String area;
	public Address() {
	}
	public Address(String country, String province, String city, String area) {
		super();
		this.country = country;
		this.province = province;
		this.city = city;
		this.area = area;
	}

	/*set....get函数*/	
}


/**
*el.jsp建在WebContect文件夹下
*/
<%@page import="java.util.HashMap"%>
<%@page import="java.util.ArrayList"%>
<%@page import="java.util.List"%>
<%@page import="com.qf.domain.Address"%>
<%@page import="com.qf.domain.User"%>
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>el表达式的使用</title>
</head>
<body>
	<!-- 先把数据放入域中(el操作必须在域里)-->
	
	<%
		pageContext.setAttribute("username", "张三");
		request.setAttribute("age", 20);
		session.setAttribute("address", "北京");
		application.setAttribute("email", "zhangsan@163.com");
		
		User user=new User();
		user.setUsername("李四");
		user.setPassword("9999");
		user.setSex("男");
		user.setPhone("18888888888");
		
		Address address=new Address();
		address.setCountry("中国");
		address.setProvince("河北");
		address.setCity("石家庄");
		
		user.setAddress(address);
		
		session.setAttribute("user", user);
		
		List<String> list=new ArrayList<String>();
		list.add("苹果");
		list.add("华为");
		list.add("小米");
		list.add("诺基亚");
		
		application.setAttribute("list", list);
		
		
		HashMap<String,String> map=new HashMap<String,String>();
		map.put("cn", "中国");
		map.put("us","美国");
		map.put("uk","英国");
		map.put("jp","日本");
		map.put("10","朝鲜");
		map.put("20","韩国");		
		application.setAttribute("map", map);	
		pageContext.setAttribute("score", 100);	
	%>

	<!-- 1 使用EL表达式从域中输出简单数据  -->
	<%-- <%=pageContext.getAttribute("username") %>
	<%=request.getAttribute("age") %> --%>
	<br/>--------------- 1 使用EL表达式从域中输出简单数据-------------------<br/>
	${pageScope.username }<br/>
	${requestScope.age }<br/>
	${sessionScope.address }<br/>
	${applicationScope.email }<br/>
	
	<br/>--1 使用EL表达式从域中输出简单数据 省略域前缀  pageContext.findAttribute() 省略域之后会从小到大依次在域中寻找-----<br/>
	${username }<br/>
	${age }<br/>
	${address }<br/>
	${email }<br/>
	<!-- 输出字符串 "username" -->
	${"username" }
	
	<!--2 使用EL表达式从域中输出对象 -->
	<br/>--------------- 2 使用EL表达式从域中输出对象--------------- <br/>
	
	${user.username }<br/>
	${user.password }<br/>
	${user.sex }<br/>
	${user.phone }<br/>
	
	${user.address.country }<br/>
	${user.address.province }<br/>
	${user.address.city }<br/>
	
	<!--3 使用EL表达式从域中输出集合 -->
	<br/>--------------- -3 使用EL表达式从域中输出集合 list集合--------------- <br/>
 	${list[0] }<br/>
 	${list[1] }<br/>
 	${list[2] }<br/>
 	${list[3] }<br/>
 	<br/>--------------- -3 使用EL表达式从域中输出集合 map集合--------------- <br/>
 	
 	${map.cn }<br/>
 	${map.us }<br/>
 	${map.uk }<br/>
 	${map.jp }<br/>
 	<%-- ${map.10 }<br/>
 	${map.20 }<br/> --%>
 	<br/>-----------------map特殊写法-------------使用.不能输出使用[]----<br/>
 	${map["cn"] }<br/>
 	${map["us"] }<br/>
 	${map["uk"]}<br/>
 	${map["jp"]}<br/>
 	${map["10"]}<br/>
 	${map["20"]}<br/>
 	
 	<br/>--------------- -4 执行运算--------------- <br/>
 	
 	${1+2}<br/>
 	${10/5}<br/>
 	${1==1}<br/>
 	${"123"=="123" }<br/>
 	
 	${score>90?"好":"差" }<br/>
 	<br/>----------empty 如果数据是"" 或 null 返回true  否则返回false----------<br/>
 	${!empty user?user.username:"" }<br/>
 	${empty "" }<br/>
 	${empty null }<br/>
 	${empty "哈哈" }<br/>
 	
	<br/>
</body>
</html>
````

（3）隐式对象（11个）	

​	JSP 表达式语言定义了一组隐式对象，其中许多对象在 JSP scriplet 和EL表达式中可用：

​	pageContext：页面上下文，可以获取jsp中其他八个内置对象

​	pageScope、requestScope、sessionScope、applicationScope表示四个域对象中集合

​	param  表示request.getParameter("username"); ${param.username} 

​	paramvalues 表示request.getPrameterValues("hobby");  	${paramValues.hobby}

​	header  表示 request.getHeader("accept");  ${header.accept};

​	headerValues 表示 request.getHeaderValues("accept-encoding"); ${headerValues["accept-encoding"][0]}

​	cookie  表示 request.getCookies();    ${cookie.JSESSIONID}

​	initParam 表示 ServletContext初始化参数

```
/**
*els.jsp
*/
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>EL表达式的11个隐式对象</title>
</head>
<body>
	<!--1 pageScope  requestScope sessionScope applicationScope  -->
	<br/>----------------1 pageScope  requestScope sessionScope applicationScope---------------<br/>
	<!--2 pageContext  -->
	<br/>----------------2 pageContext ---------------<br/>
	${pageContext.request.contextPath }<br/>
	${pageContext.session }<br/>
	${pageContext.servletContext }<br/>
	
	<form action="${pageContext.request.contextPath }/servlet/servlet1" method="post">
		
		
	</form>
	<!--3  param -->
	<br/>----------------3  param   request.getParameter-------------<br/>
	
	${param.username }<br/>
	${param.password }<br/>
	
	<br/>----------------4  paramValues   request.getParameterValues-------------<br/>
	${paramValues.hobby[0] }<br/>
	${paramValues.hobby[1] }<br/>
	${paramValues.hobby[2] }<br/>
	<br/>----------------5  header headerValues------------<br/>
	${header.accept }<br/>
	${header["accept-Encoding"] }<br/>
	${headerValues["accept-Encoding"][0] }<br/>
	
	<br/>----------------6  cookie------------<br/>
	${cookie.JSESSIONID.value }
	<br/>----------------7  initParam------------<br/>
	${initParam.haha }
	
</body>
</html>
```

##### 10.3  JSTL

（1）JSTL的概念和作用

​	 JSTL:全称Java Server Pages Standard Tag Library,JSP标准标签库,代替jsp页面的脚本，实现逻辑控制。

​	实现JSP页面中逻辑处理。如判断， 循环等；

​	下载JSTL库，http://archive.apache.org/dist/jakarta/taglibs/standard/binaries/

​	把jstl.jar、standard.jar放入WEB-INF/lib目录下

（2） 通用标签set,out,remove

```
/**
*User实体类，包com.qf.domain下
*/
public class User {	
	private String username;
	private String password;
	private String sex;
	private String phone;
	private Address address;
	
	public User() {
	}
	
	public User(String username, String password, String sex, String phone, Address address) {
		super();
		this.username = username;
		this.password = password;
		this.sex = sex;
		this.phone = phone;
		this.address = address;
	}

	/*set......get函数*/
	
	public String toString() {
		return "User [username=" + username + ", password=" + password + ", sex=" + sex + ", phone=" + phone
				+ ", address=" + address + "]";
	} 
}

/**
*jstl.jsp
*/
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
 
 <!--使用jstl必须在JSP页面添加tablib指令库-->   
<%@taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %>  
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Insert title here</title>
</head>
<body>
	<!-- 通用标签 set -->
	<br>------------set标签 放入域中 pageContext----------------<br/>
	<c:set var="username" value="zhangsan" scope="page"></c:set>
	<c:set var="age" value="20" scope="request"></c:set>
	<c:set var="address" value="beijing" scope="session"></c:set>
	<c:set var="phone" value="18888888" scope="application"></c:set>
	<c:set var="age" value="30" scope="application"></c:set>	
	<%-- <jsp:useBean id="user" class="com.qf.domain.User"></jsp:useBean>
	<c:set property="username" target="${user}" value="王五"></c:set> --%>
	${pageScope.username }<br/>
	${requestScope.age }<br/>
	${sessionScope.address }<br/>
	${applicationScope.phone }<br/>
	
<%-- 	${user.username } --%>
<br>------------out标签 输出----------------<br/>

	<c:out value="${age }" default="18"></c:out><br/>
	<c:out value="${email}" default="aaa@qq.com"></c:out><br/>
	<c:out value="<h1>标题</h1>" escapeXml="true"></c:out><br/>
	<c:out value="<script type='text/javascript'>while(true){alert('弄死你')}</script>" escapeXml="true"></c:out><br/>
	
	<br>------------remove标签 移除  从四个域中删除----------------<br/>
	
	<c:remove var="age"/>
	
	<c:out value="${username }"></c:out>
	<c:out value="${age }"></c:out>
	
	<!--给指定变量赋默认值  -->
	默认值：<c:out value="${m}" default="123456"></c:out>
</body>
</html>
```

（3）条件标签if,choose,迭代标签foreach

```
<%@page import="java.util.HashMap"%>
<%@page import="java.util.List"%>
<%@page import="java.util.ArrayList"%>
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c"%>    
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>if标签</title>
</head>
<body>
	<!-- test属性中是条件，但是条件需要使用EL表达式来书写 -->
	<c:if test="${10<5 }">
		10大于5
	</c:if>
	
	<c:if test="${!empty user }">
		用户已经登录
	</c:if>
	
	
	<c:set value="60" var="score"></c:set>
	<c:choose>
		<c:when test="${score>90 }">优秀</c:when>
		<c:when test="${score>80 }">良好</c:when>
		<c:when test="${score>70 }">一般</c:when>
		<c:when test="${score>60 }">及格</c:when>
		<c:otherwise>
			不及格
		</c:otherwise>
	</c:choose>
	<br/>
	<!-- foreach标签 输出1-10-->
	<br/>foreach标签 输出1-10<br/>
	<c:forEach var="i" begin="0" end="10" step="2">
		${i }<br/>
	</c:forEach>
	
	<%
		List<String> list=new ArrayList<String>();
		list.add("中国");
		list.add("美国");
		list.add("朝鲜");
		list.add("韩国");
		
		pageContext.setAttribute("list", list);
		
		
		HashMap<String,String> map=new HashMap<String,String>();
		map.put("cn", "中国");
		map.put("us","美国");
		map.put("uk","英国");
		map.put("jp","日本");
		map.put("10","朝鲜");
		map.put("20","韩国");
		
		pageContext.setAttribute("map", map);
	
	%>
	<br/>foreach标签遍历list集合<br/>
	
	<c:forEach var="s" items="${list }" varStatus="vs">
		${s }-----${vs.index }------${vs.count }<br/>
	</c:forEach>
	
	<br/>foreach标签遍历map集合  Map.Entry<br/>
	
	<c:forEach var="m" items="${map }" varStatus="vs">
		${m.key }.....${m.value }.....${vs.index }<br/>
	</c:forEach>
	
</body>
</html>
```

#### 第十一章 Request和Response

##### 11.1 页面跳转

Java Web服务端控制页面跳转主要有两种：重定向和转发

（1）重定向

​	重定向就是通过各种方法将网络请求重新定个方向转到其它位置。

（1.1）重定向原理和特点：

```
原理：
	客户浏览器发送http请求----》web服务器接受后发送302状态码响应及对应新的location给客户浏览器--》客户浏览器发现是302响应，则自动再发送一个新的http请求，请求url是新的location地址----》服务器根据此请求寻找资源并发送给客户。在这里location可以重定向到任意URL，既然是浏览器重新发出了请求，则就没有什么request传递的概念了。在客户浏览器路径栏显示的是其重定向的路径，客户可以观察到地址的变化的。
特点：
	特点：
        1，重定向是客户端行为。
        2，重定向是浏览器做了至少两次的访问请求的。
        3，重定向浏览器地址改变。
        4，重定向两次跳转之间传输的信息会丢失（request范围）。
        5，重定向可以指向任何的资源，包括当前应用程序中的其他资源，同一个站点上的其他应用程序中的资源，其他站点的资源。注意：传递给				
        HttpServletResponse.sendRedirect 方法的相对URL以“/”开头，它是相对于整个WEB站点的根目录。
```

（2）请求转发

​	Servlet除了支持重定向之外还支持请求转发

（2.1）转发的原理和特点：

```
原理：
	客户浏览器发送http请求----》web服务器接受此请求--》调用内部的一个方法在容器内部完成请求处理和转发动作----》将目标资源发送给客户。在这里，转发的路径必须是同一个web容器下的url，其不能转向到其他的web路径上去，中间传递的是自己的容器内的request。在客户浏览器路径栏显示的仍然是其第一次访问的路径，也就是说客户是感觉不到服务器做了转发的。

特点：
	1，转发是服务器行为
	2，转发是浏览器只做了一次访问请求
	3，转发浏览器地址不变
	4，转发两次跳转之间传输的信息不会丢失，所以可以通过request进行数据的传递
	5，转发只能将请求转发给同一个WEB应用中的组件
	注意：如果创建RequestDispatcher 对象时指定的相对URL以“/”开头，它是相对于当前WEB应用程序的根目录
```

（3）实现重定向和转发

```
/**
*html登录代码 建在文件夹WebContent下
*/
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>用户登录</title>
</head>

<body>
	<h2>用户登录</h2>
	<form action="/day12web1/loginservlet" method="post">
		用户名:<input type="text" name="username"/><br/>
		密码:<input type="password" name="pwd"/><br/>
		<input type="submit" value="提交"/>
	</form>	
</body>

</html>

/**
*html index代码 用于重定向指向网页 建在文件夹WebContent下
*/
<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8">
	<title>网站首页</title>
</head>
<body>
	欢迎访问xxx网站！内容等待完善.................
</body>
</html>

/**
*Servlet代码 重定向和转发
*/
@WebServlet("/loginservlet")
public class LoginServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
    public LoginServlet() {
        super();
    }
	protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		//1编码问题
		request.setCharacterEncoding("utf-8");
		response.setContentType("text/html;charset=utf-8");
		//2接收数据，注意getParameter函数中的名字要和html定义的名字一致
		String username=request.getParameter("username");
		String pwd=request.getParameter("pwd");
		System.out.println("用户名:"+username+" 密码:"+pwd);
		
		//3判断
		if(username.equals("john")&&pwd.equals("8888")) {
			//重定向
			//response.sendRedirect("/day12web1/index.html");
			
			//转发
			//1获取转发器
			RequestDispatcher dispatcher=request.getRequestDispatcher("/listservlet");
			//2转发
			dispatcher.forward(request, response);
			return;
		}
		//重定向
		response.sendRedirect("/day12web1/login.html");
	}
	
	protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		doGet(request, response);
	}
}

/**
*Servlet代码 接收转发代码
*/
@WebServlet("/listservlet")
public class ListServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;  
    public ListServlet() {
        super();
    }

	protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		request.setCharacterEncoding("utf-8");
		response.setContentType("text/html;charset=utf-8");
		
		//接收数据
		String username=request.getParameter("username");
		String pwd=request.getParameter("pwd");
		System.out.println("用户名："+username+"   ....密码:"+pwd);
		
		PrintWriter out=response.getWriter();
		out.println("这是listServlet返回的数据");	
	}
	protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		doGet(request, response);
	}
}
```

##### 11.2 路径问题

（1） 网络路径问题

​	路径分类 ：

​		绝对路径: 用在不同网站之间的跳转,比如：http://www.baidu.com/aaa/1.jpg

​		相对路径:用在同一个网站中,  aaa/1.jpg，如果页面比较多，会出现混乱。

​		**根路径**：根指定就是主机名（服务器）   /day12web1/loginservlet     （/ 表示  http://localhost:8080/）

​					 /day12web1/loginservlet   如果在浏览器中使用   / 表示  http://localhost:8080/

​					/listservlet                              如果是在服务器中使用  / 表示   day12web1/

##### 11.3 Response

（1）ServletResponse

​	  定义辅助 servlet 将响应发送到客户端的对象。servlet 容器创建 ServletResponse 对象，并将它作为参数传递给 servlet 的 service 方法。 要发送 MIME 正文响应中的二进制数据，请使用 getOutputStream 返回的 ServletOutputStream。要发送字符数据，请使用 getWriter 返回的 PrintWriter 对象。要混合二进制数据和文本数据，例如要创建 multipart 响应，请使用 ServletOutputStream 并手动管理字符部分。 可使用 #setCharacterEncoding 和 setContentType 显式指定 MIME 正文响应的 charset，或使用 setLocale 方法隐式指定它。显式指定优先于隐式指定。如果未指定 charset，则将使用 ISO-8859-1。setCharacterEncoding、setContentType 或 setLocale 方法必须在调用 getWriter 之前，并且必须在提交采用要使用的字符编码的响应之前调用。

（1.1）HttpServletResponse

​	扩展 ServletResponse 接口以提供特定于 HTTP 的发送响应功能。例如，该接口拥有访问 HTTP 头和 cookie 的方法。 客户端向服务器发起的都是HTTP协议操作,所以我们大部分使用HttpServletResponse对象作为直接操作对象!

（1.1.2）HttpServletResponse 常用API介绍	

| 方法名称                          |       作用       |
| :---------------------------- | :------------: |
| setStatus(int code)           |    设置响应状态码     |
| setHeader(name,value)         |    设置响应信息头     |
| setCharacterEncoding(String); |     设置编码格式     |
| setContentType(String)        | 设置返回数据mimetype |
| getWriter()                   |    获取字符输出流     |
| getOutputStream()             |    获取字节输出流     |

```
/**
 * 常用API
 */
@WebServlet("/servlet1")
public class Servlet1 extends HttpServlet {
	private static final long serialVersionUID = 1L;

    public Servlet1() {
        super();
    }
	protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		
		/*
		//1servlet字节输出流
		ServletOutputStream outputStream = response.getOutputStream();
		outputStream.write("helloworld".getBytes());
		//2字符打印流
		response.setStatus(800);
		response.setContentType(arg0);
		response.setHeader("content-Type", "text/html;charset=utf-8");
		response.setHeader("aaaa", "hello");
		PrintWriter out=response.getWriter();
		out.write("hahahahaha中文");	
		*/
		
		request.setCharacterEncoding("utf-8");
		response.setContentType("text/html;charset=utf-8");
		PrintWriter out=response.getWriter();
		out.write("哈哈哈");	
	}	

	protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {	
		doGet(request, response);
	}
}
```

（2）设置返回字符编码格式

（2.1）方案1 :可以解决返回字符串乱码问题,但是需要将返回的字符串封装到html代码中.操作繁琐!

```
response.setCharacterEncoding（）
设置tomcat编码格式
<html>
	<head>
		<meta charset="utf-8">
  		<title>xxx</title>
	</head>
	<body>编写返回的文本内容</body>
</html>	
设置浏览器解析文本内容格式  
```

（2.2）方案2:方案按相对简单,通过设置响应头告知浏览器解析字符串的编码格式!

```
response.setHeader("Content-type","text/html;charset=UTF-8")
```

（2.3）方案3：利用setContentType这种综合性的写法解决问题!常用!方便!

```
response.setContentType("text/html;charset=UTF-8")
```

（3）Response练习

（3.1）用户下载服务器图片

```
/**
 * 用户下载服务器图片
 */
@WebServlet("/downloadservlet")
public class DownLoadServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
    public DownLoadServlet() {
        super();
    }
	protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		//1读取文件  d: c:  (本地路径相对路径不行) 
		//File file=new File("images/003.jpg");
		//2使用类加载器,也不行
		/*InputStream is=DownLoadServlet.class.getClassLoader().getResourceAsStream("images/003.jpg");
		System.out.println(is);*/
		
		//3使用绝对路径
		//File file=new File("D:\\programs\\apache-tomcat-8.0.39\\webapps\\day12web1\\images\\图片.jpg");
		ServletContext application=getServletContext();
		String realpath=application.getRealPath("images\\图片.jpg");
		System.out.println(realpath);
		File file=new File(realpath);
		
		FileInputStream fis=new FileInputStream(realpath);
		
		//IE有问题
		//String filename=new String(file.getName().getBytes("utf-8"),"iso-8859-1");
		//通用的
		String filename=URLEncoder.encode(file.getName(),"utf-8");
		
		//4设置头 (告诉浏览器我是一个文件，你需要保存)
		response.setHeader("content-disposition", "attachment;filename="+filename);

		ServletOutputStream sos=response.getOutputStream();
		
		byte[] buf=new byte[1024*4];
		int len=0;
		while((len=fis.read(buf))!=-1) {
			sos.write(buf,0,len);
		}	
	}
	protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		doGet(request, response);
	}
}
```

（3.2）页面中添加验证码

​	项目中添加第三方jar包validatecode.jar;

​	创建返回验证码的servlet!

```
/**
 * 页面中添加验证码
 */
@WebServlet("/codeservlet")
public class CodeServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
       
    public CodeServlet() {
        super();
    }

	protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		/*1创建ValidateCode对象 
			width：验证码的宽度px 180 
			height:验证码的高度 px 50
			codeCount:生成验证码有几个数 5
			lineCount:有几根线 30
		*/
		ValidateCode validateCode=new ValidateCode(180, 50, 5, 30);
		//2.获取生成的验证码的字符串值
		System.out.println(validateCode.getCode());
		//3.响应写回验证图片
		validateCode.write(response.getOutputStream());
	}

	
	protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		doGet(request, response);
	}
}

/**
 *页面中使用当前servlet
 */
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>用户注册</title>
</head>
<body>
	<h1>用户注册</h1>
	<form action="" method="post">
	<table>
		<tr>
			<td>用户名:</td>
			<td>
				<input type="text" name="username" placeholder="请输入用户名" >
			</td>
		
		</tr>
		<tr>
			<td>密码:</td>
			<td>
				<input type="password" name="pwd" placeholder="请输入密码" >
			</td>
		
		</tr>
		<tr>
			<td>确认密码:</td>
			<td>
				<input type="password" name="repwd" placeholder="请再次输入密码">
			</td>
		
		</tr>
		<tr>
			<td>邮箱:</td>
			<td>
				<input type="email" name="email" placeholder="请输入邮箱">
			</td>
		
		</tr>
		<tr>
			<td>性别</td>
			<td>
				<input type="radio" name="gender" value="男" checked="checked">男
				<input type="radio" name="gender" value="女">女
			</td>
		
		</tr>
			<tr>
			<td>验证码</td>
			<td>
				<input type="text" name="validateCode">
				//设置图片通过js获得，所以设置id=codeImg
				<img id="codeImg" alt="验证码" title="验证码" src="">
				
				//javascript:void(0)是一个伪地址，即直接触发事件执行函数，并无需根据地址跳转页面
				<a href="javascript:void(0)" onclick="changeCodeImage()">看不清换一张?</a>
			
			</td>
		</tr>
		<tr>
			<td colspan="2">
				<input type="submit" value="提交">
				<input type="reset" value="重置">
			</td>
		
		</tr>
	</table>
	</form>
	
	<script type="text/javascript">
		function changeCodeImage() {
			var codeImg=document.getElementById("codeImg");
			//设置随机数目的是为了改变地址，只有改变地址浏览器才会重新向服务器申请，这样就会重新调用CodeServlet函数从而改变验证码，要理解地址改变的作用。src后面的路径要区分大小写
			codeImg.src="/MyWeb/CodeServlet?number="+Math.random();
		}
		changeCodeImage();
	</script>
</body>
</html>
```

##### 11.4 Request

（1）ServletRequest

​	定义将客户端请求信息提供给某个 servlet 的对象。servlet 容器创建ServletRequest对象，并将该对象作为参数传递给该 servlet 的service方法。

（1.2）HttpServletRequest介绍

​	HttpServletRequest对象代表客户端的请求，当客户端通过HTTP协议访问服务器时，HTTP请求头中的所有信息都封装在这个对象中，开发人员通过这个对象的方法，可以获得客户这些信息。

（1.2.1）HttpServletRequest常用API

​	URL ：Uniform Resource Location (统一资源定位符) 网址

​	URI ：Uniform Resource Identifier (统一资源标识符)

```
/**
 * Servlet implementation class Servlet2
 */
@WebServlet("/servlet2")
public class Servlet2 extends HttpServlet {
	private static final long serialVersionUID = 1L;
   
    public Servlet2() {
        super();
    }
	protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
			//获取请求对象的信息
//客户端发出请求时的完整URL:http：//localhost:8080/day12/Web1/servlet2
			System.out.println("url:"+request.getRequestURL());
			//发出请求行中的资源名部分/day12/Web1/servlet2
			System.out.println("uri:"+request.getRequestURI());		
//请求行参数部分username=zhangsan&hobby=movie&hobby=youxi&hobby=bianma			System.out.println("queryString:"+request.getQueryString());
			//发出请求的客户机的IP地址
			System.out.println("remoteAddr:"+request.getRemoteAddr());
			//发出请求的客户机的完整主机名
			System.out.println("remoteHost:"+request.getRemoteHost());
			//客户机所使用的网络端口号
			System.out.println("remotePort:"+request.getRemotePort());
			//WEB服务器的IP地址
			System.out.println("localAddr:"+request.getLocalAddr());
			//WEB服务器的主机名
			System.out.println("localName:"+request.getLocalName());
			//获取请求方式get
			System.out.println("method:"+request.getMethod());
			//接收的数据类型:text/html,application/xhtml
			System.out.println("Accept:"+request.getHeader("Accept"));
			//获得所有接收数据的编码
			Enumeration<String> headers = request.getHeaders("Accept-Encoding");
			System.out.println("--------------getHeaders--------------");
			while(headers.hasMoreElements()) {
				System.out.println(headers.nextElement());
			}
			//获得所有信息的头名字
			System.out.println("--------------getHeaderNames--------------");
			Enumeration<String> headerNames = request.getHeaderNames();
			while(headerNames.hasMoreElements()) {
				System.out.println(headerNames.nextElement());
			}
			
			//username hobby没有定义，故运行的时候必然会出现报错：500号-空指针错误。解决方法：在网址栏http：//localhost:8080/day12/Web1/servlet2后面加？username=zhangsan&hobby=movie&hobby=youxi&hobby=bianma即可
			String username=request.getParameter("username");
			System.out.println("username:"+username);
			String[] hobby=request.getParameterValues("hobby");
			System.out.println("----------------getParameterValues--------------");
			for (String string : hobby) {
				System.out.println(string);
			}
	}

	protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		doGet(request, response);
	}

}
```

##### 11.5 Request封装案例（带验证加激活码）

​	封装请求参数

​	将数据封装到实体类上，创建一个对应的实体类!实体类要变量命名和变量类型都有相应的要求,要求变量名跟提交参数的key相同,变量跟参数类型形同!

​	使用Apache BeanUtils进行快速映射:需要导入beanutils对应jar包、logging日志、commons-collections-3.2.1.jar三个jar包

```
/**
*实体类
*/
public class User {
	private int id;
	private String username;
	private String password;
	private String email;
	private String gender;
	private int flag;
	private int role;
	private String code;
	public User(int id, String username, String password, String email, String gender, int flag, int role,
			String code) {
		super();
		this.id = id;
		this.username = username;
		this.password = password;
		this.email = email;
		this.gender = gender;
		this.flag = flag;
		this.role = role;
		this.code = code;
	}
	public User() {
		// TODO Auto-generated constructor stub
	}
	public int getId() {
		return id;
	}
	public void setId(int id) {
		this.id = id;
	}
	
	/*此处省略set get函数*/
	
	public String toString() {
		return "User [id=" + id + ", username=" + username + ", password=" + password + ", email=" + email + ", gender="
				+ gender + ", flag=" + flag + ", role=" + role + ", code=" + code + "]";
	}	
}

/**
 * 验证码：需要ValidateCode jar包
 */
@WebServlet("/codeservlet")
public class CodeServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
    public CodeServlet() {
        super();
        // TODO Auto-generated constructor stub
    }
	protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		//1创建ValidateCode对象
		ValidateCode validateCode=new ValidateCode(180, 50, 5, 30);
		System.out.println(validateCode.getCode());
		validateCode.write(response.getOutputStream());
	}
	protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		doGet(request, response);
	}
}
/**
 * 注册html代码
 */
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>用户注册</title>
</head>
<body>
	<h1>用户注册</h1>
	<form action="/day12web2/registerservlet" method="post">
	<table>
		<tr>
			<td>用户名:</td>
			<td>
				<input type="text" name="username">
			</td>
		
		</tr>
		<tr>
			<td>密码:</td>
			<td>
				<input type="password" name="password">
			</td>
		
		</tr>
		<tr>
			<td>确认密码:</td>
			<td>
				<input type="password" name="repassword">
			</td>
		
		</tr>
		<tr>
			<td>邮箱:</td>
			<td>
				<input type="email" name="email">
			</td>
		
		</tr>
		<tr>
			<td>性别</td>
			<td>
				<input type="radio" name="gender" value="男" checked="checked">男
				<input type="radio" name="gender" value="女">女
			</td>
		
		</tr>
			<tr>
			<td>验证码</td>
			<td>
				<input type="text" name="validateCode">
				<img id="codeImg" alt="" src="">
				<a href="javascript:void(0)" onclick="changeCodeImage()">看不清换一张?</a>
			</td>
		
		</tr>
		<tr>
			<td colspan="2">
				<input type="submit" value="提交">
				<input type="reset" value="重置">
			</td>
		
		</tr>
	</table>
	</form>
	
	<script type="text/javascript">
		function changeCodeImage() {
			var codeImg=document.getElementById("codeImg");
			codeImg.src="/day12web2/codeservlet?number="+Math.random();
		}
		changeCodeImage();
	</script>
</body>
</html>
/**
 * 激活码工具类：用于提供注册信息中的激活码那条信息
 */
public class ActiveCodeUtils {
	public static String createActiveCode() {
		Date date=new Date();
		SimpleDateFormat sdf=new SimpleDateFormat("yyyyMMddHHmmssSSS");
		String s1=sdf.format(date);
		String s2=Integer.toHexString(new Random().nextInt(900)+100);
		return s1+s2;
	}
}
/**
 * 登录函数
 *使用Apache BeanUtils进行快速映射:需要导入beanutils对应jar包、logging日	  * 志、commons-collections-3.2.1.jar三个jar包
 */
@WebServlet("/registerservlet")
public class RegisterServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
    public RegisterServlet() {
        super();
    }

	protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
	
		/*
        
		//第一种方法
		//1编码
		request.setCharacterEncoding("utf-8");
		response.setContentType("text/html;charset=utf-8");
		//2接收数据
		
		String username=request.getParameter("username");
		String pwd=request.getParameter("pwd");
		String repwd=request.getParameter("repwd");
		String email=request.getParameter("email");
		String gender=request.getParameter("gender");
	
		//3创建对象
		User user=new User();
		user.setUsername(username);
		user.setPassword(pwd);
		user.setEmail(email);
		user.setGender(gender);
		user.setFlag(0);
		user.setRole(1);
		user.setCode(ActiveCodeUtils.createActiveCode());
		
		System.out.println(user.toString());
		
		//第二种方法
		Map<String, String[]> paraMaps = request.getParameterMap();
		User user=new User();
		for (Map.Entry<String,String[]> entry :paraMaps.entrySet()) {
			//System.out.println(entry.getKey());
			//System.out.println(entry.getValue().length);
			String  key=entry.getKey();//username
			String methodname="set"+Character.toUpperCase(key.charAt(0))+key.substring(1);//setUsername;
			try {
				//属性描述符
				PropertyDescriptor pd=new PropertyDescriptor(key,User.class);
				if(pd!=null) {
					Method method=pd.getWriteMethod();
					if(entry.getValue().length==1) {
						method.invoke(user, entry.getValue()[0]);
					}else {
						method.invoke(user, (Object)entry.getValue());
					}
					
				}
					
			} catch (Exception e) {
				// TODO Auto-generated catch block
				//e.printStackTrace();
			}
		}
		
		*/
		
		//第三种方式 使用apache beanUtils工具包，
		//1编码
		request.setCharacterEncoding("utf-8");
		response.setContentType("text/html;charset=utf-8");
		
		User user=new User();
		try {
			BeanUtils.populate(user, request.getParameterMap());
		} catch (Exception e) {
			e.printStackTrace();
		}
		System.out.println(user.toString());	
	}

	protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		doGet(request, response);
	}
} 
```

#### 第十二章 Web状态管理

##### 12.1 状态管理-Cookie

（1）状态管理概述

```
	(1.1)为什么需要状态管理
	HTTP协议是无状态的，不能保存每次提交的信息，即当服务器返回与请求相对应的应答之后，这次事务的所有信息就丢掉了。 
　　如果用户发来一个新的请求，服务器无法知道它是否与上次的请求有联系。 
　　对于那些需要多次提交数据才能完成的Web操作，比如登录来说，就成问题了。
　　(1.2)什么是状态管理
　　WEB应用中的会话是指一个客户端浏览器与WEB服务器之间连续发生的一系列请求和响应过程。WEB应用的会话状态是指WEB服务器与浏览器在会话过程中产生的状态信息，借助会话状态，WEB服务器能够把属于同一会话中的一系列的请求和响应过程关联起来。
　　(1.3)状态管理的两种常见模式
　　客户端状态管理技术：将状态保存在客户端。代表性的是Cookie技术。
　　服务器状态管理技术：将状态保存在服务器端。代表性的是session技术（服务器传递sessionID时需要使用Cookie的方式）。
　　状态管理需要这两种方式共同作用。
```

（2）Cookie应用

（2.1）什么是Cookie

```
	Cookie是在浏览器访问WEB服务器的某个资源时，由WEB服务器在HTTP响应消息头中附带传送给浏览器的一片数据，WEB服务器传送给各个客户端浏览器的数据是可以各不相同的。
	一旦WEB浏览器保存了某个Cookie，那么它在以后每次访问该WEB服务器时，都应在HTTP请求头中将这个Cookie回传给WEB服务器。
	WEB服务器通过在HTTP响应消息中增加Set-Cookie响应头字段将Cookie信息发送给浏览器，浏览器则通过在HTTP请求消息中增加Cookie请求头字段将Cookie回传给WEB服务器。
	一个Cookie只能标识一种信息，它至少含有一个标识该信息的名称（NAME）和设置值（VALUE）。
	一个WEB站点可以给一个WEB浏览器发送多个Cookie，一个WEB浏览器也可以存储多个WEB站点提供的Cookie。
	浏览器一般只允许存放300个Cookie，每个站点最多存放20个Cookie，每个Cookie的大小限制为4KB
```

（2.2）创建、查询、修改cookie、设置cookie的有效期

```
/**
 * Servlet implementation class CookieServlet
 */
@WebServlet("/aaa/bbb/cookieservlet")
public class CookieServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;        
    public CookieServlet() {
        super();
    }

	protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		//1编码
		request.setCharacterEncoding("utf-8");
		response.setContentType("text/html;charset=utf-8");
		//2响应
		PrintWriter out = response.getWriter();
		out.println("欢迎访问我的小店");
		//3添加cookie
		//3.0.0创建cookie对象实质就是写键值对，所以可以随便取名,但是不同的cookie对象名字不能一样
		Cookie myCookie=new Cookie("username","xiaocang");
		//3.0.1如果有中文，编码 url编码
		Cookie myCookie=new Cookie("username2", URLEncoder.encode("小白", "utf-8"));
		//3.1设置cookie有效期  <0表示保存内存中，浏览器退出，就删除  0 删除cookie  >0 有效期 单位秒，默认-1
		System.out.println(myCookie.getMaxAge());
		myCookie.setMaxAge(60*10);
		//3.2设置cookie有效路径
		System.out.println(myCookie.getPath());
		//myCookie.setPath("/day13web1/aaa");
		//设置路径localhost：8080
		myCookie.setPath("/");	
		//3.3设置只有Http读取,js不能读取
		myCookie.setHttpOnly(true);
		//4把cookie加入到Response
		response.addCookie(myCookie);
	
	//如果想要修改cookies，只要保证Cookie的名和路径一致，就可以设置新的参数覆盖之前的设置
		
		//5读取浏览器发回来的cookie
		System.out.println("----------------读取浏览器的cookie-----------------");
		Cookie[] cookies = request.getCookies();
		if(cookies!=null) {
			for (Cookie cookie : cookies) {
			
//如果有中文，需要url解码，如果name也有中文，则cookie.getname也需要解码      System.out.println(cookie.getName()+"........."+URLDecoder.decode(cookie.getValue(), "utf-8"));
				
				//如果cookie中不包含中文可以简化为：				System.out.println(cookie.getName()+"........."+cookie.getValue();
			}
		}
	}
	protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		doGet(request, response);
	}
}
```

（3）Cookie的路径问题

（3.1）什么是Cookie的路径问题

```
	cookie 一般都是由于用户访问页面而被创建的，可是并不是只有在创建 cookie 的页面才可以访问这个cookie。在默认情况下，出于安全方面的考虑，只有与创建 cookie 的页面处于同一个目录或在创建cookie页面的子目录下的网页才可以访问。那么此时如果希望其父级或者整个网页都能够使用cookie，就需要进行路径的设置。
```

（3.2）发送Cookie的条件

```
	浏览器在发送请求之前，首先会根据请求url中的域名在cookie列表中找所有与当前域名一样的cookie，然后再根据指定的路径进行匹配，如果当前请求在域匹配的基础上还与路径匹配那么就会将所有匹配的cookie发送给服务器，这里要注意的是最大匹配和最小匹配问题，有些cookie服务器在发送之前会有意扩大当前页面cookie的匹配范围，此时这些被扩大范围的cookie也会一起发送给服务器
```

（3.3）如何设置Cookie的路径

```
通过Cookie的setPath方法设置路径
```

（4）Cookie的特点

（4.1）优点：

```
可配置到期规则：Cookie 可以在浏览器会话结束时到期，或者可以在客户端计算机上无限期存在，这取决于客户端的到期规则，不需要任何服务器资源 Cookie 存储在客户端并在发送后由服务器读取。
简单性：Cookie 是一种基于文本的轻量结构，包含简单的键值对。
数据持久性：虽然客户端计算机上 Cookie 的持续时间取决于客户端上的 Cookie 过期处理和用户干预，Cookie 通常是客户端上持续时间最长的数据保留形式
```

（4.2）缺点：

```
大小受到限制：大多数浏览器对 Cookie 的大小有 4096 字节的限制，尽管在当今新的浏览器和客户端设备版本中，支持 8192 字节的 Cookie 大小已愈发常见。
用户配置为禁用：有些用户禁用了浏览器或客户端设备接收 Cookie 的能力，因此限制了这一功能。
潜在的安全风险：Cookie 可能会被篡改。用户可能会操纵其计算机上的 Cookie，这意味着会对安全性造成潜在风险或者导致依赖于Cookie 的应用程序失败。
   另外，虽然 Cookie 只能被将它们发送到客户端的域访问，历史上黑客已经发现从用户计算机上的其他域访问 Cookie 的方法。您可以手动加密和解密 Cookie，但这需要额外的编码，并且因为加密和解密需要耗费一定的时间而影响应用程序的性能。
```

##### 12.2 状态管理-Session

（1）Session概述

（1.1）什么是Session

```
Session用于跟踪客户的状态。
Session指的是在一段时间内，单个客户与Web服务器的一连串相关的交互过程。
在一个Session中，客户可能会多次请求访问同一个网页，也有可能请求访问各种不同的服务器资源。
```

（1.2） Session工作原理

```
session被用于表示一个持续的连接状态，在网站访问中一般指代客户端浏览器的进程从开启到结束的过程。session其实就是网站分析的访问（visits）度量，表示一个访问的过程。
session的常见实现形式是会话cookie（session cookie），即未设置过期时间的cookie，这个cookie的默认生命周期为浏览器会话期间，只要关闭浏览器窗口，cookie就消失了。实现机制是当用户发起一个请求的时候，服务器会检查该请求中是否包含sessionid，如果未包含，则系统会创造一个名为JSESSIONID的输出 cookie返回给浏览器(只放入内存，并不存在硬盘中)，并将其以HashTable的形式写到服务器的内存里面；当已经包含session id时，服务端会检查找到与该session相匹配的信息，如果存在则直接使用该sessionid，若不存在则重新生成新的 session。这里需要注意的是session始终是由服务端创建的，并非浏览器自己生成的。　但是浏览器的cookie被禁止后session就需要用get方法的URL重写的机制或使用POST方法提交隐藏表单的形式来实现
```

（1.3）Session超时

（1.3.1）什么是Session超时

​	HttpSession的最后一程访问时间和当前时间的差距大于了指定的最大空闲时间，这时服务器就会销毁Session对象。默认的空闲时间为30分钟。

（1.3.2） 如何修改Session的缺省时间限制

```
1 使用HttpSession的session.setMaxInactiveInterval(20*60);设置，单位秒
2 在web.xml中配置 ，单位分钟
  <session-config>
  	<session-timeout>20</session-timeout>
  </session-config>
```

（1.3.3）Session失效的几种情况

​		超过了设置的超时时间
​		主动调用了invalidate方法
​		服务器主动或异常关闭
​		注意：浏览器关闭并不会让Session失效

（1.4）session的创建，数据载入（对象绑定），读取，删除,超时设置

```
@WebServlet("/sessionservlet1")
public class SessionServlet1 extends HttpServlet {
	private static final long serialVersionUID = 1L;
    public SessionServlet1() {
        super();
    }

	protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		//1乱码
		request.setCharacterEncoding("utf-8");
		response.setContentType("text/html;charset=utf-8");
		//2获取(一旦获取session, 服务器就创建cookie JSESSIONID, 值是一个十六进制字符串)
		HttpSession session = request.getSession();
		//设置超时空闲时间为20分钟
		session.setMaxInactiveInterval(20*60);
		//读取session中的数据
		String name=(String)session.getAttribute("username");
		System.out.println(name);
		System.out.println("sessionId:"+session.getId());
		System.out.println("session创建时间(毫秒)"+new Date(session.getCreationTime()).toLocaleString());
		System.out.println("session最后一次访问时间（毫秒）："+new Date(session.getLastAccessedTime()).toLocaleString());
		System.out.println("session过时时间："+session.getMaxInactiveInterval());
		System.out.println("最大的空闲时间(秒):"+session.getMaxInactiveInterval());
		
		//3向session中存放数据。即使用Session绑定对象
		session.setAttribute("username", "zhangsan");
		//删除Session
		session.invalidate("username", "zhangsan")
	}

	protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		doGet(request, response);
	}
}
```

##### 12.3 浏览器禁用Cookie的解决方案

（1）浏览器禁用Cookie的后果

```
如果浏览器禁用Cookie，session还能用吗？
	答：不能，但有其他的解决方案
	服务器在默认情况下，会使用Cookie的方式将sessionID发送给浏览器，如果用户禁止Cookie，则sessionID不会被浏览器保存，此时，服务器可以使用如URL重写这样的方式来发送sessionID.

使用Session区分每个用户的方式：
	1、作为Cookie 
	2、作为隐藏域嵌入HTML表单中，附加在主体的URL中，通常作为指向其他应用程序页面的链接，即URL重写。 
	3、更加高效的方法：会话跟踪（Session）
```

（2）什么是URL重写

​	 浏览器在访问服务器上的某个地址时，不再使用原来的那个地址，而是使用经过改写的地址（即，在原来的地址后面加上了sessionID）

（3）如何实现URL重写

```
如果是链接地址和表单提交，使用
response.encodeURL(String url)生成重写后的URL
如果是重定向，使用
response.encodeRedirectURL(String url)生成重写的URL
```

##### 12.4  Session案例

（1） 验证登录

​	 测试时，直接先访问userservlet，即直接去判断用户有没有登录

```
/**
 * index html
 */
 <!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>网站后台管理</title>
</head>
<body>
	xxx网址后台首页   <a href="/day13web1/loginoutservlet">退出</a>
</body>
</html>

/**
 * 登录的html页面：login html
 */
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>用户登录</title>
</head>
<body>

	<h2>用户登录</h2>
	<form action="/day13web1/loginservlet" method="post">
		用户名:<input type="text" name="username"/><br/>
		密码:<input type="password" name="password"/><br/>
		<input type="submit" value="登录"/>	
	</form>

</body>
</html> 

/**
 * 判断用户有没有登录Servlet：implementation class UserServlet
 * 登陆一次后可以实现自动登录
 */
@WebServlet("/userservlet")
public class UserServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
    public UserServlet() {
        super();
    }
	protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		
		/*第一种自动登录方式检测部分的代码*/
		//判断用户有没有登录
		HttpSession session = request.getSession();
		String username=(String)session.getAttribute("username");
		if(username==null) {//没有登录
			//重定向到login.html
			response.sendRedirect("/day13web1/login.html");
			return;
		}
		response.sendRedirect("/day13web1/index.html");	
	}
	
	/*第二种自动登录方式检测部分的代码*/
	/*
		protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		//1读取cookie
		Cookie[] cookies=request.getCookies();
		if(cookies!=null) {
			for (Cookie cookie : cookies) {
				if(cookie.getName().equals("userinfo")) {
					String val=cookie.getValue();
					String[] vals=val.split("#");
				if(vals[0].equals("admin")&&vals[1].equals("888")) {
						HttpSession session = request.getSession();
						session.setAttribute("username", vals[0]);
						request.getRequestDispatcher("/index.html").forward(request, response);
						return;
					}
				}
			}
		}
		response.sendRedirect("/day13web2/login.html");	
	}
	*/
	
	protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		doGet(request, response);
	}
}

/**
 * 登录的Servlet:
 */
@WebServlet("/loginservlet")
public class LoginServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
    public LoginServlet() {
        super();
    }

	/*第一种方式自动登录的登录部分的代码*/
	protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		//1乱码
		request.setCharacterEncoding("utf-8");
		response.setContentType("text/html;charset=utf-8");
		//2获取
		String username=request.getParameter("username");
		String password=request.getParameter("password");
		if(username.equals("admin")&&password.equals("888")) {
			//登录成功
			//1把用户名放入session中
			HttpSession session = request.getSession();	
			//修改过期时间
		/*	session.setMaxInactiveInterval(20*60);*/
			session.setAttribute("username", username);
			//2.1 自定义 cookie 名字 JSESSIONID, 值 session.getId,有效期五分钟，路径
			Cookie cookie=new Cookie("JSESSIONID", session.getId());
			cookie.setMaxAge(60*5);
			cookie.setPath("/day13web1");
			cookie.setHttpOnly(true);
			response.addCookie(cookie);
			//2转发
			RequestDispatcher dispatcher = request.getRequestDispatcher("/index.html");
			dispatcher.forward(request, response);	
		}else {
			//3重定向login.html
			response.sendRedirect("/day13web1/login.html");
		}
	}
	
	/*第二种方式自动登录的登录部分的代码*/
	/*
	protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		//1乱码
		request.setCharacterEncoding("utf-8");
		response.setContentType("text/html;charset=utf-8");
		//2获取数据
		String username=request.getParameter("username");
		String password=request.getParameter("password");
		if(username.equals("admin")&&password.equals("888")) {
			//3获取session
			HttpSession session = request.getSession();
			session.setAttribute("username", username);
			//4创建Cookie
			Cookie cookie=new Cookie("userinfo", "admin#888");
			cookie.setMaxAge(5*60);
			cookie.setPath("/day13web2");
			cookie.setHttpOnly(true);
			response.addCookie(cookie);
			//5重定向
			response.sendRedirect("/day13web2/index.html");
			return ;
		}
		response.sendRedirect("/day13web2/login.html");	
	}

	*/
	
	protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		doGet(request, response);
	}
}

/**
*注销
*/
@WebServlet("/loginoutservlet")
public class LoginOutServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
    public LoginOutServlet() {
        super();
    }
	protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		//1设置session失效、
		request.setCharacterEncoding("utf-8");
		response.setContentType("text/html;charset=utf-8");
		HttpSession session = request.getSession();
		session.removeAttribute("username");//从session中移除用户
		session.invalidate();//设置失效
		PrintWriter out = response.getWriter();
		out.println("退出成功");
	}
	protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		doGet(request, response);
	}
}
```

（2）验证码的实现

​	本案例中涉及到了封装请求参数，故需要使用Apache BeanUtils进行快速映射:所以需要导入beanutils对应jar包、logging日志、commons-collections-3.2.1.jar三个jar包，又因为需要使用到验证码，所以也需要导入ValidateCode jar包

```
/**
*注册register.html
*/
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>用户注册</title>
</head>
<body>
	<h1>用户注册</h1>
	<form action="/day13web3/registerservlet" method="post">
	<table>
		<tr>
			<td>用户名:</td>
			<td>
				<input type="text" name="username">
			</td>
		</tr>
		<tr>
			<td>密码:</td>
			<td>
				<input type="password" name="password">
			</td>
		
		</tr>
		<tr>
			<td>确认密码:</td>
			<td>
				<input type="password" name="repassword">
			</td>
		
		</tr>
		<tr>
			<td>邮箱:</td>
			<td>
				<input type="email" name="email">
			</td>
		
		</tr>
		<tr>
			<td>性别</td>
			<td>
				<input type="radio" name="gender" value="男" checked="checked">男
				<input type="radio" name="gender" value="女">女
			</td>
		
		</tr>
			<tr>
			
			<td>
				验证码:
			</td>
			<td>
				<input type="text" name="valcode">
				<img id="imgcode" alt="" src="">
				<a href="javascript:void(0)" onclick="changeImg()">看不清换一张?</a>
			</td>
		
		</tr>
		<tr>
			
			<td colspan="2">
				<input type="submit" value="提交">
				<input type="reset" value="重置">
			</td>
		
		</tr>
	
	</table>
	
	</form>
	
	<script type="text/javascript">
	
		function changeImg(){
			var imgcode=document.getElementById("imgcode");
			imgcode.src="/day13web3/codeservlet?num="+Math.random();
		}
		changeImg();
	</script>
</body>
</html>

/**
*实体类：用于创建实体对象
*/
public class User {
	private int id;
	private String username;
	private String password;
	private String email;
	private String gender;
	private int flag;
	private int role;
	private String code;

	public User() {
	}

	public User(int id, String username, String password, String email, String gender, int flag, int role,
			String code) {
		super();
		this.id = id;
		this.username = username;
		this.password = password;
		this.email = email;
		this.gender = gender;
		this.flag = flag;
		this.role = role;
		this.code = code;
	}

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	/*此处省略set。。。。get函数*/
	
	public String toString() {
		return "User [id=" + id + ", username=" + username + ", password=" + password + ", email=" + email + ", gender="
				+ gender + ", flag=" + flag + ", role=" + role + ", code=" + code + "]";
	}	
}

/**
 * 激活码工具类：用于生成登录后的code那个参数
 */
public class ActiveCodeUtils {
	public static String createActiveCode() {
		Date date=new Date();
		SimpleDateFormat sdf=new SimpleDateFormat("yyyyMMddHHmmssSSS");
		String s1=sdf.format(date);
		String s2=Integer.toHexString(new Random().nextInt(900)+100);
		return s1+s2;
	}
}

/**
 * 用于生成验证码
 */
@WebServlet("/codeservlet")
public class CodeServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
    public CodeServlet() {
        super();
    }
	protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
			ValidateCode vcode=new ValidateCode(180, 50, 4, 200);
			//把code放入session中
			HttpSession session = request.getSession();
			session.setAttribute("vcode", vcode.getCode());
			vcode.write(response.getOutputStream());		
	}
	protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		doGet(request, response);
	}
}

/**
 * 注册Servlet implementation class RegisterServlet
 */
@WebServlet("/registerservlet")
public class RegisterServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
    public RegisterServlet() {
        super();
    }

	protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		//1乱码
		request.setCharacterEncoding("utf-8");
		response.setContentType("text/html;charset=utf-8");
		//2封装对象
		User user=new User();
		try {
			//判断验证码
			HttpSession session=request.getSession();
			//从session中获取验证码
			String vcode=(String) session.getAttribute("vcode");
			//浏览器发送的验证码
			String valcode=request.getParameter("valcode");
			if(!valcode.equals(vcode)) {
				response.getWriter().write("验证码错误");
				return;
			}
			
			BeanUtils.populate(user, request.getParameterMap());
			user.setFlag(0);
			user.setRole(1);
			user.setCode(ActiveCodeUtils.createActiveCode());
			
			//数据库操作
			System.out.println(user.toString());
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
	
	protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		doGet(request, response);
	}
}
```

##### 12.5 ServletContext

​	ServletContext:Servlet上下文，代表当前整个应用程序。（jsp中application）

（1）什么是Servlet上下文

```
Servlet上下文又叫做：ServletContext。
当WEB服务器启动时，会为每一个WEB应用程序(webapps下的每个目录就是一个应用程序)创建一块共享的存储区域
ServletContext也叫做“公共区域”，也就是同一个WEB应用程序中，所有的Servlet和JSP都可以共享同一个区域。
ServletContext在WEB服务器启动时创建，服务器关闭时销毁
容器在启动的时候，会为每一个web应用创建唯一的一个符合ServletContext接口的对象，该对象一般称之为"servlet上下文"。
```

（2）Servlet上下文的获得、作用及特点

```
@WebServlet("/servlet1")
public class Servlet1 extends HttpServlet {
	private static final long serialVersionUID = 1L;
    public Servlet1() {
        super();
    }
    
	protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		
		//1获取ServletContext（四种方式）
		//1.1使用GenericServlet的getServletContext()获取，由于本类继承了HttpServlet，而HttpServlet又继承了GenericServlet，故可以用this;
		ServletContext application = this.getServletContext();
		System.out.println(application.hashCode());
		//1.2使用ServletConfig的getServletContext();
		ServletContext application2 = getServletConfig().getServletContext();
		System.out.println(application2.hashCode());
		//1.3使用session获取
		ServletContext application3 = request.getSession().getServletContext();
		System.out.println(application3.hashCode());
		//1.4获取request获取
		ServletContext application4 = request.getServletContext();
		System.out.println(application4.hashCode());
		
		//2作用
		//2.1获取资源的真实路径
		String path=application.getRealPath("images\\003.jpg");
		//books.xml
		String path2=application.getRealPath("WEB-INF\\classes\\books.xml");
		System.out.println(path);
		System.out.println(path2);
		
		//2.2获取上下文路径及附加信息
		String contextpath=application.getContextPath();
	
	//实际获取的是项目名，故在重定向中可以应用（很实用，防止写死）：			//response.sendRedirect(request.getContextPath()+"/index.html");
		String contextpath2=request.getContextPath();
		
		System.out.println(contextpath);
		String Info=request.getServletContext().getServerInfo();	
		System.out.println(Info);

		//2.3当作容器使用，设置信息到全局容器中，这些信息可以在上下文(同项目下)所有Servlet中访问的到，访问代码如下：
		/*
		ServletContext application = request.getServletContext();
		String welcome=(String) application.getAttribute("welcome");
		System.out.println(welcome);
		*/
		application.setAttribute("welcome", "欢迎大家访问");
		request.getServletContext().setAttribute("msg", "共享信息");
		
		//2.4获取数据			System.out.println(request.getServletContext().getAttribute("msg"));
		//2.5移除数据
		request.getServletContext().removeAttribute("msg");	
	}

	protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		doGet(request, response);
	}
}
Servlet上下文特点：
	唯一性: 一个应用对应一个servlet上下文。
	一直存在: 只要容器不关闭或者应用不卸载，servlet上下文就一直存在。	
```

（3）使用ServletContext实现Servlet访问次数

```
/**
 * Servlet implementation class Servlet3
 */
@WebServlet("/servlet3")
public class Servlet3 extends HttpServlet {
	private static final long serialVersionUID = 1L;  
    public Servlet3() {
        super();
    }

	protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		request.setCharacterEncoding("utf-8");
		response.setContentType("text/html;charset=utf-8");
		
		ServletContext application = request.getServletContext();
		Integer count=(Integer) application.getAttribute("count");
		if(count==null) {
			count=1;
			application.setAttribute("count", count);
		}else {
			count++;
			application.setAttribute("count", count);
		}
		PrintWriter out=response.getWriter();
		out.write("servlet共访问次数："+count);	
	}
	protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {	
		doGet(request, response);
	}
}
```

#### 第十三章 MVC和分页

##### 13.1 MVC三层架构

​	   首先我们需要知道MVC模式并不是javaweb项目中独有的，MVC是一种软件工程中的一种设计模式，把软件系统分为三个基本部分：模型（Model）、视图（View）和控制器（Controller），即为MVC。它是一种软件设计的典范，最早为Trygve Reenskaug提出，为施乐帕罗奥多研究中心（Xerox PARC）的Smalltalk语言发明的一种软件设计模式。

（1）MVC概念

（1.1）MVC模式详解

​	虽然MVC并不是Java当中独有的，但是现在几乎所有的B/S的架构都采用了MVC框架模式。

（1.1.1）MVC工作架构

​	Model模型 （实体类 dao  业务）:和数据有关,模型代表着一种企业规范，就是业务流程/状态的处理以及业务规则的规定。业务流程的处理过程对其他层来说是不透明的，模型接受的请求，并返回最终的处理结果。业务模型的设计可以说是MVC的核心。

​	View视图（html、css、js、jsp）:视图即是用户看到并与之交互的界面

​	Controller控制器（servlet）：控制请求的处理逻辑，对请求进行处理，负责请求转发和重定向；控制Model和View的关系

```
MVC中Servlet的功能：1.接收客户端请求，封装数据
				  2.调用Model（业务）
				  3.把Model交给View，转发和重定向。
```

（1.1.2）MVC具体工作流程

​	客户端向服务器发送数据请求时，首先会把请求交给控制器Servlet控制器，控制器再交给Model，model处理完后，Servlet会通过重定向或者转发将Model交给View，View做好页面反馈给客户端。

​	好处：可以实现同一个Model使用不同的View来展示。

（1.2） MVC高级框架应用	

​	MVC模式被广泛用于Java的各种框架中，比如Struts2、[spring](http://lib.csdn.net/base/javaee) MVC等等都用到了这种思想。

Struts2是基于MVC的轻量级的web应用框架。基于MVC，说明基于Struts2开发的Web应用自然就能实现MVC，也说明Struts2着力于在MVC的各个部分为我们的开发提供相应帮助

（2） MVC三层架构演变

（2.1）JavaWeb经历的三个时期	

（2.1.1） JSP Model1第一代

​	JSP Model1是JavaWeb早期的模型，它适合小型Web项目，开发成本低！Model1第一代时期，服务器端只有JSP页面，所有的操作都在JSP页面中，连访问数据库的API也在JSP页面中完成。也就是说，所有的东西都耦合在一起，对后期的维护和扩展极为不利。

（2.1.2） JSP Model1第二代

​	JSP Model1第二代有所改进，把业务逻辑和数据访问的内容放到了JavaBean中，而JSP页面负责显示以及请求调度的工作。虽然第二代比第一代好了些，但还让JSP做了过多的工作，JSP中把视图工作和请求调度（控制器）的工作耦合在一起了。

（2.1.3）JSP Model2

​	JSP Model2模式已经可以清晰的看到MVC完整的结构了。 

JSP：视图层，用来与用户打交道。负责接收用来的数据，以及显示数据给用户； 

​	Servlet：控制层，负责找到合适的模型对象来处理业务逻辑，转发到合适的视图； 

​	JavaBean：模型层，完成具体的业务工作，例如：开启、转账等。

​	**小结**:这就是javaweb经历的三个士奇，JSP Model2适合多人合作开发大型的Web项目，各司其职，互不干涉，有利于开发中的分工，有利于组件的重用。但是，Web项目的开发难度加大，同时对开发人员的技术要求也提高了。

（2.2）基于MVC的三层架构的实现

​	虽然MVC把程序分成三部分，每个部分负责不同的功能，但是这只是逻辑的分离，实际代码并没有真正分离，特别是Model（包括业务、数据访问和实体类等）部分的代码，为了增强代码的维护性和降低代码耦合性，需要把代码分层管理，于是就有了三层架构：

​	分别是:web层（表示|界面层）、service层（业务逻辑层）、dao层(数据访问层)，web层对于MVC中的Servlet和JSP，其他层都属于MVC中的Model

##### 13.2 MVC三层架构案例

```
web层
    com.qf.web.servlet
    com.qf.web.filter
    com.qf.web.listener 
    jsp页面放在 WebContent 或  WEB-INF
    
Service层
    com.qf.service  放服务层接口
    com.qf.service.impl  放服务层实现
    
Dao  层
    com.qf.dao   方法 dao接口
    com.qf.dao.impl  放dao实现
    
实体类 
    com.qf.domain   | com.qf.beans  | com.qf.entity | com.qf.pojo

工具类 
    com.qf.commons  | com.qf.utils 

	程序前准备：建立Web项目后，按照上述分层在src文件夹下建包（|表示或，任意建其中一个即可）。
	往WebContent-->WEB-INT-->lib下添加jar包：
commons-beanutils-1.9.3.jar;      druid-1.1.5.jar ;   commons-collections-3.2.1.jar;     jstl.jar ;   commons-dbutils-1.6.jar;  	standar.jar;
commons-logging-1.2.jar; 
mysql-connector-java-5.1.41-bin.jar;

/**
*UserDao:接口 包package com.qf.dao下
*/	
public interface UserDao {
	List<User> findAll();
	User findById(int id);
	void add(User user);
	void update(User user);
	void delete(int id);
}

/**
*UserDaoImpl:实现接口类 包 com.qf.dao.impl下
*/	
public class UserDaoImpl implements UserDao{
	public List<User> findAll(){
		QueryRunner queryRunner=new QueryRunner(DruidUtils.getDataSource());
		try {
			return queryRunner.query("select * from tb_user", new BeanListHandler<User>(User.class));
		} catch (SQLException e) {
			throw new RuntimeException("dao查询所有user失败");
		}
	}
	public User findById(int id) {
		QueryRunner queryRunner=new QueryRunner(DruidUtils.getDataSource());
		try {
			return queryRunner.query("select * from tb_user where id=?",new BeanHandler<User>(User.class),id);
		} catch (SQLException e) {
			throw new RuntimeException("dao查询所有user失败");
		}
	}
	public void add(User user) {
		QueryRunner queryRunner=new QueryRunner(DruidUtils.getDataSource());
		try {
			queryRunner.update("insert into  tb_user(username,password,email,gender,flag,role,code) values(?,?,?,?,?,?,?)", user.getUsername(),user.getPassword(),user.getEmail(),user.getGender(),user.getFlag(),user.getRole(),user.getCode());
		} catch (SQLException e) {
			throw new RuntimeException("dao更新user失败");
		}
	}
	public void update(User user) {
		QueryRunner queryRunner=new QueryRunner(DruidUtils.getDataSource());
		try {
			queryRunner.update("update tb_user set password=?,email=?,gender=?,flag=?,role=? where id=?", user.getPassword(),user.getEmail(),user.getGender(),user.getFlag(),user.getRole(),user.getId());
		} catch (SQLException e) {
			throw new RuntimeException("dao更新user失败");
		}
	}
	public void delete(int id) {		
		QueryRunner runner=new QueryRunner(DruidUtils.getDataSource());
		try {
			runner.update("update tb_user set flag=2 where id=?",id);
		} catch (SQLException e) {
			throw new RuntimeException("dao删除user失败");
		}		
	}
}

/**
*User:实体类 包 com.qf.domain下
*/
public class User {
	private int id;
	private String username;
	private String password;
	private String email;
	private String gender;
	private int flag;
	private int role;
	private String code;
	public User() {
	}
	public User(int id, String username, String password, String email, String gender, int flag, int role,String code) {
		super();
		this.id = id;
		this.username = username;
		this.password = password;
		this.email = email;
		this.gender = gender;
		this.flag = flag;
		this.role = role;
		this.code = code;
	}

	/*set.......get函数*/
	
	public String toString() {
		return "User [id=" + id + ", username=" + username + ", password=" + password + ", email=" + email + ", gender="
				+ gender + ", flag=" + flag + ", role=" + role + ", code=" + code + "]";
	}	
}

/**
*UserService:业务接口 包 com.qf.service下
*/
public interface UserService {

	List<User> findAll();
	User findById(int id);
	void add(User user);
	void update(User user);
	void delete(int id);	
}

/**
*UserServiceImpl:业务接口实现类 包com.qf.service.impl下
*/
public class UserServiceImpl implements UserService{
	private UserDao userdao=new UserDaoImpl();
	public List<User> findAll() {
		List<User> list=userdao.findAll();
		System.out.println(list.size());
		return list;
	}
	public User findById(int id) {
		return userdao.findById(id);
	}
	public void add(User user) {
		userdao.add(user);
	}
	public void update(User user) {
		userdao.update(user);	
	}
	public void delete(int id) {
		userdao.delete(id);	
	}
}

/**
*DruidUtils:连接池工具类 包com.qf.utils下
*/
public class DruidUtils {
	
	private static DruidDataSource dds;
	static {
		dds=new DruidDataSource();
		
		InputStream is=DruidUtils.class.getClassLoader().getResourceAsStream("database.properties");
		
		Properties properties=new Properties();
		try {
			properties.load(is);
			System.out.println(properties.getProperty("driverClassName"));
			System.out.println(properties.getProperty("url"));
			System.out.println(properties.getProperty("username"));
			System.out.println(properties.getProperty("password"));
					dds.setDriverClassName(properties.getProperty("driverClassName"));
			dds.setUrl(properties.getProperty("url"));
			dds.setUsername(properties.getProperty("username"));
			dds.setPassword(properties.getProperty("password"));
						dds.setInitialSize(Integer.parseInt(properties.getProperty("initialSize")));
			dds.setMaxActive(Integer.parseInt(properties.getProperty("maxActive")));
			dds.setMinIdle(Integer.parseInt(properties.getProperty("minIdle")));
			dds.setMaxWait(Long.parseLong(properties.getProperty("maxWait")));	
		} catch (IOException e) {
			e.printStackTrace();
		}	
	}
	public static DataSource getDataSource() {
		return dds;
	}
	public static Connection getConnection() {
		try {
			return dds.getConnection();
		} catch (SQLException e) {
			e.printStackTrace();
		}
		return null;
	}	
}

/**
*com.qf.Web.filter:过滤器包
*/

/**
*com.qf.Web.listener:监听器包 
*/

/**
*UserDeleteServlet:服务器 包com.qf.Web.servlet下
*/
@WebServlet("/userdeleteservlet")
public class UserDeleteServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
    public UserDeleteServlet() {
        super();
    }
	protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		String userid=request.getParameter("userid");
		int id = Integer.parseInt(userid);
		UserService userService=new UserServiceImpl();
		userService.delete(id);
		//重定向	response.sendRedirect(request.getServletContext().getContextPath()+"/userlistservlet");
	}
	protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		doGet(request, response);
	}
}

/**
*usereditservlet:服务器 包com.qf.Web.servlet下
*/
@WebServlet("/usereditservlet")
public class UserEditServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
    public UserEditServlet() {
        super();
    }
	protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		//beanUtils
		request.setCharacterEncoding("utf-8");
		response.setContentType("text/html;charset=utf-8");
		UserService userService=new UserServiceImpl();
		User user=new User();
		try {
			BeanUtils.populate(user, request.getParameterMap());
			userService.update(user);
			//response.sendRedirect(request.getContextPath()+"/userlistservlet");
			
			response.getWriter().write("<script type='text/javascript'>alert('更新成功');window.location='"+request.getContextPath()+"/userlistservlet';</script>");
			
		} catch (Exception e) {
			request.setAttribute("msg", "更新失败");		request.getRequestDispatcher("/message.jsp").forward(request, response);
		}	
	}
	protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		doGet(request, response);
	}
}

/**
*UserListServlet:服务器 包com.qf.Web.servlet下
*/
@WebServlet("/userlistservlet")
public class UserListServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
      
    public UserListServlet() {
        super();
    }

	protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
	
		//1乱码、
		request.setCharacterEncoding("utf-8");
		response.setContentType("text/html;charset=utf-8");
		//2调用service
		UserService userService=new UserServiceImpl();
		List<User> users = userService.findAll();
		//3放入域中
		request.setAttribute("userlist", users);
		//4转发
		request.getRequestDispatcher("/userlist.jsp").forward(request, response);	
	}
	protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		doGet(request, response);
	}
}

/**
*UserServlet:服务器 包com.qf.Web.servlet下
*/
@WebServlet("/userservlet")
public class UserServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
       
    public UserServlet() {
        super();
    }

	protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		
		String userid=request.getParameter("userid");
		int id=Integer.parseInt(userid);
		UserService userService=new UserServiceImpl();
		User user=userService.findById(id);
		request.setAttribute("user", user);
		//转发
		request.getRequestDispatcher("/useredit.jsp").forward(request, response);
		
	}
	protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		doGet(request, response);
	}
}

/**
*database.properties:配置文件 文件夹src下
*/
url=jdbc:mysql://localhost:3306/db_shopping
driverClassName=com.mysql.jdbc.Driver
username=root
password=root
maxActive=20
initialSize=5
maxWait=60000
maxIdle=15
minIdle=10

/**
*message.jsp:jsp文件 文件夹WebContent下
*/
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>显示信息</title>
</head>
<body>
</body>
</html>

/**
*useredit.jsp:jsp文件 文件夹WebContent下
*/
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
 <%@taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c"%>
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>编辑用户</title>
</head>
<body>
	<h2>编辑用户</h2>
	<form action="${pageContext.request.contextPath }/usereditservlet" method="post" onsubmit="return confirm('确定要更新吗?')">
		<table>
			<tr>
				<td>编号</td>
				<td>
					<input type="text" name="id" value="${user.id }" readonly="readonly">
				</td>
			</tr>
			<tr>
				<td>用户名</td>
				<td>
					<input type="text" name="username" value="${user.username }" readonly="readonly">
				</td>
			</tr>
			<tr>
				<td>密码</td>
				<td>
					<input type="text" name="password" value="">
				</td>
			</tr>
			<tr>
				<td>邮箱</td>
				<td>
				<input type="text" name="email" value="${user.email }">
				</td>
			</tr>
			<tr>
				<td>性别</td>
				<td>
					<input type="radio" name="gender" value="男" ${user.gender=="男"?"checked='checked'":"" }   />男
					<input type="radio" name="gender" value="女" ${user.gender=="女"?"checked='checked'":"" } />女
				</td>
			</tr>
			<tr>
				<td>是否激活</td>
				<td>
					<select name="flag">
						<option value="1" ${user.flag==1?"selected='selected'":"" }>激活</option>
						<option value="0" ${user.flag==0?"selected='selected'":"" }>未激活</option>
						<option value="2" ${user.flag==2?"selected='selected'":"" }>删除</option>
					</select>
				</td>
			</tr>
			<tr>
				<td>角色</td>
				<td>
				<select name="role">
						<option value="0" ${user.role==0?"selected='selected'":"" }>管理员</option>
						<option value="1" ${user.role==1?"selected='selected'":"" }>普通用户</option>
					
					</select>
				
				</td>
			</tr>
			<tr>
				<td>激活码</td>
				<td>
				<input type="text" name="code" value="${user.code }" readonly="readonly">
				</td>
			</tr>
			
			<tr>
				<td colspan="2">
					<input type="submit" value="更新">
				</td>
			</tr>
		</table>
	
	</form>	
</body>
</html>

/**
*userlist.jsp:jsp文件 文件夹WebContent下
*/
<%@ page language="java" contentType="text/html; charset=UTF-8"
	pageEncoding="UTF-8"%>
<%@taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c"%>
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>用户列表</title>
</head>
<body>
	<h1>用户列表</h1>

	<table border="1">
		<tr>
			<td>编号</td>
			<td>用户名</td>
			<td>密码</td>
			<td>邮箱</td>
			<td>性别</td>
			<td>是否激活</td>
			<td>角色</td>
			<td>激活码</td>
			<td>操作</td>
		</tr>

		<c:forEach var="user" items="${userlist}">
			<tr>
				<td>${user.id }</td>
				<td>${user.username }</td>
				<td>${user.password }</td>
				<td>${user.email }</td>
				<td>${user.gender }</td>
				<td>${user.flag==1?"激活":user.flag==0?"未激活":"刪除" }</td>
				<td>${user.role==0?"管理员":"普通用户" }</td>
				<td>${user.code }</td>
				<td><a href="${pageContext.request.contextPath}/userservlet?userid=${user.id }">更新</a>&nbsp;&nbsp;<a href="${pageContext.request.contextPath}/userdeleteservlet?userid=${user.id }" onclick="return confirm('确定要删除吗?')">删除</a></td>
			</tr>
		</c:forEach>
	</table>
</body>
</html>
```

##### 13.3 MVC、事务案例

​	通过结合事务和MVC知识,练习一个转账demo

（1）项目准备

​	程序前准备：

​	（1.1）jar包： 

 commons-beanutils-1.9.3.jar;  commons-dbutils-1.6.jar;  	

 commons-logging-1.1.1.jar；commons-collections-3.2.1.jar;  

commons-logging-1.2.jar; druid-1.1.5.jar ;   jstl.jar ; 

mysql-connector-java-5.1.41-bin.jar;     standar.jar;

```
web层
    com.qf.web.servlet
    com.qf.web.filter
    com.qf.web.listener 
    jsp页面放在 WebContent 或  WEB-INF
    
Service层
    com.qf.service  放服务层接口
    com.qf.service.impl  放服务层实现
    
Dao  层
    com.qf.dao   方法 dao接口
    com.qf.dao.impl  放dao实现
    
实体类 
    com.qf.domain   | com.qf.beans  | com.qf.entity | com.qf.pojo

工具类 
    com.qf.commons  | com.qf.utils 

/**
*AccountDao:接口 包package com.qf.dao下
*/	
public interface AccountDao {
	List<Account> findAll();
	Account findById(int id);
	void update(Account account);
	void add(Account account);
	void delete(int id);
	void saveMoney(int id,double money);
	void subMoney(int id,double money);	
}

/**
*AccountDaoImpl:实现接口类 包 com.qf.dao.impl下
*/	
public class AccountDaoImpl implements AccountDao{	
	//QueryRunner qr=new QueryRunner(DruidUtils.getDataSource());
	public List<Account> findAll() {
		return null;
	}
	public Account findById(int id) {
		return null;
	}

	public void update(Account account) {	
	}

	public void add(Account account) {
		
	}
	public void delete(int id) {
		
	}
	public void saveMoney(int id, double money) {
		try {
			QueryRunner qr=new QueryRunner();//不要给连接池
			//qr.update("update account set money=money+? where id=?", money,id);
			qr.update(DruidUtils.getConnection(), "update account set money=money+? where id=?", money,id);
		} catch (SQLException e) {
			throw new RuntimeException(id+"存取失败");
		}
	}
	public void subMoney(int id, double money) {
		try {
			QueryRunner qr=new QueryRunner();		
			//qr.update("update account set money=money-? where id=?", money,id);
			qr.update(DruidUtils.getConnection(), "update account set money=money-? where id=?", money,id);
		} catch (SQLException e) {
			throw new RuntimeException(id+"取钱失败");
		}	
	}
}


/**
*Account:实体类 包 com.qf.domain下
*/
public class Account {
	private int id;
	private String username;
	private double money;
	public Account() {
		// TODO Auto-generated constructor stub
	}
	public Account(int id, String username, double money) {
		super();
		this.id = id;
		this.username = username;
		this.money = money;
	}

	/*set...get函数*/

	public String toString() {
		return "Account [id=" + id + ", username=" + username + ", money=" + money + "]";
	}	
}


/**
*AccountService:业务接口 包 com.qf.service下
*/
public interface AccountService {
	//转账
	void transMoney(int from,int to,double money);
}

/**
*AccountServiceImpl:业务接口实现类 包com.qf.service.impl下
*/
public class AccountServiceImpl implements AccountService {

	private AccountDao accountdao = new AccountDaoImpl();
	public void transMoney(int from, int to, double money) {

		try {
			DruidUtils.beginTranscation();//
			// 先取钱
			accountdao.subMoney(from, money);
			//int i = 10 / 0;
			// 再存取
			accountdao.saveMoney(to, money);
			DruidUtils.commitTranscation();
		} catch (Exception e) {
			DruidUtils.rollbackTranscation();
			throw new RuntimeException("业务转账失败", e);
		} finally {
			DruidUtils.close();
		}
	}
}


/**
*DruidUtils:连接池工具类 包com.qf.utils下
*/
public class DruidUtils {
	private static DruidDataSource dds;
	//线程变量集合
	private static ThreadLocal<Connection> threadLocal; //value Connection  相当于map集合 key 线程id， value 
	
	static {
		threadLocal=new ThreadLocal<Connection>();
		//读取配置配置
		InputStream is=DruidUtils.class.getClassLoader().getResourceAsStream("database.properties");
		Properties properties=new Properties();
		
		try {
			properties.load(is);
			dds=(DruidDataSource) DruidDataSourceFactory.createDataSource(properties);
					
		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}
	public static DataSource getDataSource() {
		return dds;
	}
	
	public static Connection getConnection() throws SQLException {
		
		Connection connection=threadLocal.get();
		if(connection==null) {//第一访问肯定没有connection
			connection=dds.getConnection();
			threadLocal.set(connection);//放入集合
		}
		return connection;
	}
	//开启事务
	public static void beginTranscation() throws SQLException {
	
		Connection connection=getConnection();
		connection.setAutoCommit(false);
		
	}
	//提交事务
	public static void commitTranscation()  {
		Connection connection;
		try {
			connection = getConnection();
			connection.commit();
		} catch (SQLException e) {
			e.printStackTrace();
		}
		
	}
	//回滚事务
	public static void rollbackTranscation() {
		Connection connection;
		try {
			connection = getConnection();
			connection.rollback();
		} catch (SQLException e) {
			e.printStackTrace();
		}	
	}
	public static void close() {
		try {
			Connection connection=getConnection();
			connection.close();
			//从ThreadLocal移除
			threadLocal.remove();	
		} catch (SQLException e) {
			e.printStackTrace();
		}
	}
}


/**
*CharacterEncodingFilter:字符过滤器com.qf.Web.filter
*/
@WebFilter("/*")
public class CharacterEncodingFilter implements Filter {
    public CharacterEncodingFilter() {
    }
	public void destroy() {
	}
	public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
		request.setCharacterEncoding("utf-8");
		response.setCharacterEncoding("utf-8");
		chain.doFilter(request, response);
	}
	public void init(FilterConfig fConfig) throws ServletException {
	}
}

/**
*com.qf.Web.listener:监听器包 
*/

/**
*AccountServlet:服务器 包com.qf.Web.servlet下
*/
@WebServlet("/accountservlet")
public class AccountServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
    public AccountServlet() {
        super();
        // TODO Auto-generated constructor stub
    }
	protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		//转账
		String from=request.getParameter("fromid");
		String to=request.getParameter("toid");
		String money=request.getParameter("money");
		//验证
		if(from==null||from.trim().equals("")) {
			request.setAttribute("msg", "付款id不能为空");
			request.getRequestDispatcher("/message.jsp").forward(request, response);
			return;
		}
		if(to==null||to.trim().equals("")) {
			request.setAttribute("msg", "收款id不能为空");
			request.getRequestDispatcher("/message.jsp").forward(request, response);
			return;
		}
		if(money==null||money.trim().equals("")) {
			request.setAttribute("msg", "转账金额不能为空");
			request.getRequestDispatcher("/message.jsp").forward(request, response);
			return;
		}
		
		int fromid=Integer.parseInt(from);		
		int toid=Integer.parseInt(to);
		double m=Double.parseDouble(money);
		
		try {
			AccountService accountService = new AccountServiceImpl();
			accountService.transMoney(fromid, toid, m);
			request.setAttribute("msg", "转账成功");			request.getRequestDispatcher("/message.jsp").forward(request, response);
		} catch (Exception e) {
			request.setAttribute("errormsg", e.getMessage());			request.getRequestDispatcher("/error.jsp").forward(request, response);			
		}		
	}
	protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		doGet(request, response);
	}
}

/**
*database.properties:配置文件 文件夹src下
*/
url=jdbc:mysql://localhost:3306/day17_2
driverClassName=com.mysql.jdbc.Driver
username=root
password=root
initialSize=5
maxActive=20
maxWait=60000
minIdle=10

/**
*account.jsp:jsp文件 文件夹WebContent下
*/
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>转账</title>
</head>
<body>

	<h3>转账</h3>
	<form action="${pageContext.request.contextPath }/accountservlet" method="post">
		付钱id:<input type="text" name="fromid" ><br/>
		收钱id:<input type="text" name="toid" ><br/>
		转账金额:<input type="text" name="money">
		<input type="submit" value="转账">
	
	</form>
</body>
</html>


/**
*error.jsp:jsp文件 文件夹WebContent下
*/
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8" isErrorPage="true"%>
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>错误页面</title>
</head>
<body>	
	${errormsg }
</body>
</html>	

/**
*message.jsp:jsp文件 文件夹WebContent下
*/
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>消息</title>
</head>
<body>
	${msg }
</body>
</html>

/**
*readme.txt:注释 建在项目文件夹下
*/
1 数据库
create database day17_2;
Create Table
CREATE TABLE `account` (
  `id` int(11) NOT NULL,
  `username` varchar(20) DEFAULT NULL,
  `money` decimal(18,2) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8

2 创建项目
	day17web2
		程序包
		com.qf.web.servlet
		com.qf.service
		com.qf.service.impl
		com.qf.dao
		com.qf.dao.impl
		com.qf.domain
		com.qf.utils
```

##### 13.4 分页概述

​	分页是web应用程序非常重要的一个技术。数据库中的数据可能是成千上万的，不可能把这么多的数据一次显示在浏览器上面。一般根据每行数据在页面上所占的空间每页显示若干行，比如一般20行是一个比较理想的显示状态。

（1）分页实现思路

分页的方法主要有以下两种思路

1.取出符合条件的数据，放到数据集或者内存当中，然后逐页浏览。例如，有可能每页只浏览20条记录，但使用这种分页方法需要把所有记录取出来。这种分页的方法叫做“指针分页或假分页”。

2.对于海量的数据查询，看多少就取多少，显然是最佳的解决方法，假如某个表中有200万条记录，第一页取前20条，第二页取21~40条记录。此时可以使用。

select top 当前页*每页记录数查询字段列表 from 表A where 主键字段 not in （select top （当前页-1）*当前页记录数主键字段 from 表A）

这样的语句来实现，因为这种查询方式要使用主键，所以叫他做“主键分页”

（2）分页代码实现 

  步骤：

1.确定每页显示的数据数量

2.确定分页显示所需的总页数

3.编写SQL查询语句，实现数据查询

4.在JSP页面中进行分页显示设置    

##### 13.5 分页案例

```
导入jar包：
commons-beanutils-1.9.3.jar;  commons-dbutils-1.6.jar; 
 commons-logging-1.1.1.jar；commons-collections-3.2.1.jar;  
commons-logging-1.2.jar; druid-1.1.5.jar ;   jstl.jar ; 
mysql-connector-java-5.1.41-bin.jar;     standar.jar;

/**
*StudentDao:接口 包package com.qf.dao下
*/	
List<Student> findByPage(int pageNum,int pageSize);
	long getCount();
	void add(Student s);
}

/**
*StudentDaoImpl:实现接口类 包 com.qf.dao.impl下
*/	
public class StudentDaoImpl implements StudentDao{
	QueryRunner qr=new QueryRunner(DruidUtils.getDataSource());
	public List<Student> findByPage(int pageNum, int pageSize) {
		List<Student> list=null;
		try {
			list = qr.query("select * from student limit ?,?", new BeanListHandler<Student>(Student.class), (pageNum-1)*pageSize,pageSize);
		} catch (SQLException e) {
			throw new RuntimeException("分页查询失败");
		}
		return list;
	}
	public long getCount() {
		Long count=0L;
		try {
			 count=qr.query("select count(*) from student", new ScalarHandler<Long>());
		} catch (SQLException e) {
			throw new RuntimeException("查询数据个数失败");
		}
		return count;
	}
	public void add(Student s) {
		try {
			qr.update("insert into student(studentNo,loginPwd,studentName,sex,bornDate) values(?,?,?,?,?)",s.getStudentNo(),s.getLoginPwd(),s.getStudentName(),s.getSex(),s.getBornDate() );
		} catch (SQLException e) {
			throw new RuntimeException("添加失败");
		}	
	}
}

/**
*PageBean:实体类 包 com.qf.domain下
*/
public class PageBean {
	//当前页码
	private int pageNum;
	//页大小
	private int pageSize;
	//总页数
	private int totalPage;
	//总数据个数
	private long totalCount;
	//数据
	private List<Student> data;
	
	private int startPage;
	private int endPage;
	
	public PageBean() {
	}
	public PageBean(int pageNum, int pageSize, long totalCount, List<Student> data) {
		super();
		this.pageNum = pageNum;
		this.pageSize = pageSize;
		this.totalCount = totalCount;
		this.data = data;
		//计算总页数	
		this.totalPage=(int) (this.totalCount%this.pageSize==0?this.totalCount/this.pageSize:this.totalCount/this.pageSize+1);	
		//计算页面中显示的页吗
		this.startPage=pageNum-4;
		this.endPage=pageNum+5;	
		//判断特殊
		if(pageNum<5) {
			this.startPage=1;
			this.endPage=10;
		}
		if(pageNum>totalPage-5) {
			this.startPage=totalPage-9;
			this.endPage=totalPage;
		}	
	}

	/*set......get函数*/
}

/**
*Student:实体类 包 com.qf.domain下
*/
public class Student {
	private int studentNo;
	private String loginPwd;
	private String studentName;
	private String sex;
	private Date bornDate;
	public Student() {
	}
	public Student(int studentNo, String loginPwd, String studentName, String sex, Date bornDate) {
		super();
		this.studentNo = studentNo;
		this.loginPwd = loginPwd;
		this.studentName = studentName;
		this.sex = sex;
		this.bornDate = bornDate;
	}

	/*set...get函数*/

	public String toString() {
		return "Student [studentNo=" + studentNo + ", loginPwd=" + loginPwd + ", studentName=" + studentName + ", sex="
				+ sex + ", bornDate=" + bornDate + "]";
	}	
}

/**
*StudentService:业务接口 包 com.qf.service下
*/
public interface StudentService {
	PageBean findByPage(int pageNum,int pageSize);
}

/**
*StudentServiceImpl:业务接口实现类 包com.qf.service.impl下
*/
public class StudentServiceImpl implements StudentService {
	private StudentDao studentdao = new StudentDaoImpl();
	public PageBean findByPage(int pageNum, int pageSize) {
		List<Student> data = studentdao.findByPage(pageNum, pageSize);
		long totalCount = studentdao.getCount();
		PageBean pageBean = new PageBean(pageNum, pageSize, totalCount, data);
		return pageBean;
	}
}

/**
*TestStudent: 包com.qf.test下
*/
public class TestStudent {
	public static void main(String[] args) {
		StudentDao studentDao=new StudentDaoImpl();
		for(int i=0;i<100;i++) { // 100-999;
			Student s=new Student(i, i+100+"", "张三"+i, "女", new Date());
			studentDao.add(s);
		}
	}
}

/**
*DruidUtils:连接池工具类 包com.qf.utils下
*/
public class DruidUtils {
	private static DruidDataSource dds;
	//线程变量集合
	private static ThreadLocal<Connection> threadLocal; //value Connection  相当于map集合 key 线程id， value 
	static {
		threadLocal=new ThreadLocal<Connection>();
		//读取配置配置
		InputStream is=DruidUtils.class.getClassLoader().getResourceAsStream("database.properties");
		Properties properties=new Properties();
		
		try {
			properties.load(is);
			dds=(DruidDataSource) DruidDataSourceFactory.createDataSource(properties);		
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
	
	public static DataSource getDataSource() {
		return dds;
	}
	
	public static Connection getConnection() throws SQLException {
		
		Connection connection=threadLocal.get();
		if(connection==null) {//第一访问肯定没有connection
			connection=dds.getConnection();
			threadLocal.set(connection);//放入集合
		}
		return connection;
	}
	public static void beginTranscation() throws SQLException {
	
		Connection connection=getConnection();
		connection.setAutoCommit(false);
		
	}
	public static void commitTranscation()  {
		Connection connection;
		try {
			connection = getConnection();
			connection.commit();
		} catch (SQLException e) {
			e.printStackTrace();
		}	
	}
	public static void rollbackTranscation() {
		Connection connection;
		try {
			connection = getConnection();
			connection.rollback();
		} catch (SQLException e) {
			e.printStackTrace();
		}	
	}
	public static void close() {
		try {
			Connection connection=getConnection();
			connection.close();
			threadLocal.remove();	
		} catch (SQLException e) {
			e.printStackTrace();
		}
	}
}

/**
*CharacterEncodingFilter:字符过滤器com.qf.Web.filter
*/
@WebFilter("/*")
public class CharacterEncodingFilter implements Filter {
    public CharacterEncodingFilter() {
    }
	public void destroy() {
	}
	public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
		request.setCharacterEncoding("utf-8");
		response.setCharacterEncoding("utf-8");
		chain.doFilter(request, response);
	}
	public void init(FilterConfig fConfig) throws ServletException {
	}
}

/**
*com.qf.Web.listener:监听器包 
*/

/**
*ListStudentServlet:服务器 包com.qf.Web.servlet下
*/
@WebServlet("/liststudentservlet")
public class ListStudentServlet extends HttpServlet {
    public ListStudentServlet() {
        super();
    }
	protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		//1接收浏览器返送的页码也页大小
		String pageNum=request.getParameter("pageNum");
		String pageSize=request.getParameter("pageSize");
		int pnum=1;
		int psize=5;
		//2转换
		if(pageNum!=null&&!pageNum.trim().equals("")) {
			pnum=Integer.parseInt(pageNum);
			if(pnum<=0) {
				pnum=1;
			}
		}
		if(pageSize!=null&&!pageSize.trim().equals("")) {
			psize=Integer.parseInt(pageSize);
		}
		//3调用业务
		StudentService studentService=new StudentServiceImpl();
		PageBean pageBean=studentService.findByPage(pnum, psize);		
		//4放入request域中
		request.setAttribute("pageBean", pageBean);
		//5转发	request.getRequestDispatcher("/liststudent.jsp").forward(request, response);
	}
	protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		doGet(request, response);
	}
}


/**
*database.properties:配置文件 文件夹src下
*/
url=jdbc:mysql://localhost:3306/day17_2
driverClassName=com.mysql.jdbc.Driver
username=root
password=root
initialSize=5
maxActive=20
maxWait=60000
minIdle=10

/**
*liststudent.jsp:jsp文件 文件夹WebContent下
*/
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<%@taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c"%>    
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>显示学生列表</title>
</head>
<body>
	<h1>学生列表</h1>
	<table border="1" width="100%">
		<tr>
			<td>学号</td>
			<td>密码</td>
			<td>姓名</td>
			<td>性别</td>
			<td>出生日期</td>
		</tr>
		<c:forEach var="s" items="${pageBean.data }">
			<tr>
				<td>${s.studentNo }</td>
				<td>${s.loginPwd }</td>
				<td>${s.studentName }</td>
				<td>${s.sex }</td>
				<td>${s.bornDate }</td>
			</tr>
		
		</c:forEach>
	
	</table>
	
	<div id="pagebar">
		<a href="${pageContext.request.contextPath }/liststudentservlet?pageNum=1&pageSize=${pageBean.pageSize}">首页</a>
		<a href="${pageContext.request.contextPath }/liststudentservlet?pageNum=${pageBean.pageNum-1 }&pageSize=${pageBean.pageSize}">上一页</a>
		<c:forEach var="p" begin="${pageBean.startPage }" end="${pageBean.endPage }" step="1">
			<c:if test="${pageBean.pageNum==p }">
				<a href="${pageContext.request.contextPath }/liststudentservlet?pageNum=${p }&pageSize=${pageBean.pageSize}" style="background-color: red">${p }</a>&nbsp;
			</c:if>
			<c:if test="${pageBean.pageNum!=p }">
				<a href="${pageContext.request.contextPath }/liststudentservlet?pageNum=${p }&pageSize=${pageBean.pageSize}">${p }</a>&nbsp;
			</c:if>
		</c:forEach>
		
		<a href="${pageContext.request.contextPath }/liststudentservlet?pageNum=${pageBean.pageNum+1 }&pageSize=${pageBean.pageSize}">下一页</a>
		<a href="${pageContext.request.contextPath }/liststudentservlet?pageNum=${pageBean.totalPage}&pageSize=${pageBean.pageSize}">尾页</a>
	
		<input type="number" min="1" id="txtPage" name="txtPage" value="${pageBean.pageNum }" style="width: 50px"><input type="button" value="跳转" onclick="doPage()"/>
	</div>


	<script type="text/javascript">
	
		function doPage(){
			var pnum=document.getElementById("txtPage").value;
			//alert(pnum);
			window.location="${pageContext.request.contextPath }/liststudentservlet?pageNum="+pnum+"&pageSize=${pageBean.pageSize}";

		}
	</script>
</body>
</html>

/**
*readme.txt:注释 建在项目文件夹下
*/
 1创建数据库和表
   create table student(
	 studentNo int(4) NOT NULL,
	 loginPwd varchar(20) NOT NULL,
	 studentName varchar(50) NOT NULL,
	 sex char(2) NOT NULL,
	 bornDate datetime
   );
   
   2 创建项目  
```


#### 第十四章 经典综合程序

##### 14.1 服务器注册Servlet,html,jdbc

​	实现注册信息的提交,页面：register.html

```
项目注释：（1）建立dynamic Web project，添加Tomcat v8.0服务器，并将该项目添加到服务器中   （2）两个类，一个是servlet，一个是普通Class   （3）在WebContent文件夹下建立html文件   （4）在WEB-INT文件夹下的lib文件夹下添加JDBC jar包 
（5）PreparedStatement，connection导入的包为：java.sql. （6）准备好数据库
（7）Data导入的是java.util包 （8）Servlet函数要导入工具函数那个类的包 （9）测试的时候是进网页（即html文件）而不是java文件  （10）测试的时候进网页的途径是在浏览器上输入网页地址（http://localhost:8080/myxiaomi1/register.html），而不是直接打开本地HTML文件
/**
*servlet(容器Tomcat)
*/
@WebServlet("/registerservlet")
public class RegisterServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
    public RegisterServlet() {
        super();
    }

	protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		//注册
		//1编码
		request.setCharacterEncoding("utf-8");
		response.setContentType("text/html;charset=utf-8");
		//2获取数据
		String username=request.getParameter("username");
		String pwd=request.getParameter("pwd");
		String repwd=request.getParameter("repwd");
		String email=request.getParameter("email");
		String gender=request.getParameter("gender");
		//3验证数据
		PrintWriter out = response.getWriter();
		if(username==null||username.trim().equals("")) {
			out.write("用户不能为空");
			return;
		}
		if(pwd==null||pwd.trim().equals("")) {
			out.write("密码不能为空");
			return;
		}
		if(!pwd.equals(repwd)) {
			out.write("两次密码不一样");
			return;
		}
		//4保存数据库
		Connection connection=null;
		PreparedStatement pstat=null;
		try {
			//4.1注册驱动
			Class.forName("com.mysql.jdbc.Driver");
			//4.2获取连接		connection=DriverManager.getConnection("jdbc:mysql://localhost:3306/db_shopping", "root", "root");
			//4.3创建命令
			pstat=connection.prepareStatement("insert into tb_user(username,password,email,gender,flag,role,code) values(?,?,?,?,?,?,?)");
			//4.4设置参数
			pstat.setString(1, username);
			pstat.setString(2, pwd);
			pstat.setString(3, email);
			pstat.setString(4, gender);
			pstat.setInt(5, 0);
			pstat.setInt(6, 1);
			pstat.setString(7, ActiveCodeUtils.createActiveCode());
			//5执行
			int result=pstat.executeUpdate();
			if(result>0) {
				out.write("注册成功");
			}else {
				out.write("注册失败");
			}
		} catch (Exception e) {
			e.printStackTrace();
			out.write("注册失败");
		}finally {
			if(connection!=null) {
				try {
					connection.close();
				} catch (SQLException e) {
					e.printStackTrace();
				}
			}
			if(pstat!=null) {
				try {
					pstat.close();
				} catch (SQLException e) {
					e.printStackTrace();
				}
			}
		}
	}
	protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {		
		doGet(request, response);
	}
}

<!--Html文件-->
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>用户注册</title>
</head>
<body>
	<h1>用户注册</h1>
	<form action="/myxiaomi/registerservlet" method="post">
	<table>
		<tr>
			<td>用户名:</td>
			<td>
				<input type="text" name="username">
			</td>
		
		</tr>
		<tr>
			<td>密码:</td>
			<td>
				<input type="password" name="pwd">
			</td>
		
		</tr>
		<tr>
			<td>确认密码:</td>
			<td>
				<input type="password" name="repwd">
			</td>
		
		</tr>
		<tr>
			<td>邮箱:</td>
			<td>
				<input type="email" name="email">
			</td>
		
		</tr>
		<tr>
			<td>性别</td>
			<td>
				<input type="radio" name="gender" value="男" checked="checked">男
				<input type="radio" name="gender" value="女">女
			</td>
		
		</tr>
		<tr>
			
			<td colspan="2">
				<input type="submit" value="提交">
				<input type="reset" value="重置">
			</td>
		
		</tr>
	</table>
	
	</form>
</body>
</html>

/**
 * 激活码工具类
 */
 public class ActiveCodeUtils {
	public static String createActiveCode() {
		Date date=new Date();
		SimpleDateFormat sdf=new SimpleDateFormat("yyyyMMddHHmmssSSS");
		String s1=sdf.format(date);
		String s2=Integer.toHexString(new Random().nextInt(900)+100);
		return s1+s2;
	}
}
```

#### 第十五章 jQuery

##### 15.1 jQuery基础

（1）jQuery概述

（1.1） jQuery简介

​	jQuery是一个快速、简洁的JavaScript框架，是继Prototype之后又一个优秀的JavaScript代码库（*或JavaScript框架*）。jQuery设计的宗旨是“Write Less，Do More”，即倡导写更少的代码，做更多的事情。它封装JavaScript常用的功能代码，提供一种简便的JavaScript设计模式，优化HTML文档操作、事件处理、动画设计和Ajax交互。

​	jQuery的核心特性可以总结为：具有独特的链式语法和短小清晰的多功能接口；具有高效灵活的css选择器，并且可对CSS选择器进行扩展；拥有便捷的插件扩展机制和丰富的插件。jQuery兼容各种主流浏览器，如IE 6.0+、FF 1.5+、Safari 2.0+、Opera 9.0+等。

（1.2） jQuery版本

​	目前jQuery有三个大版本：
	1.x：兼容ie678,使用最为广泛的，官方只做BUG维护，功能不再新增。因此一般项目来说，使用1.x版本就可以了，最终版本：1.12.4 (2016年5月20日)
	2.x：不兼容ie678，很少有人使用，官方只做BUG维护，功能不再新增。如果不考虑兼容低版本的浏览器可以使用2.x，最终版本：2.2.4 (2016年5月20日)
	3.x：不兼容ie678，只支持最新的浏览器。除非特殊要求，一般不会使用3.x版本的，很多老的jQuery插件不支持这个版本。目前该版本是官方主要更新维护的版本。最新版本：3.2.1（2017年3月20日）
1.X大版本下，细分版本非常多，各个版本的函数都会有一定的差异。网上看到的很多教程大多是1.x版本的。jquery官方手册：http://api.jquery.com/

​	课程中使用的是1.

（1.3）什么是jQuery？

​	jQuery是一个JavaScript函数库。jQuery是一个轻量级的"写的少，做的多"的JavaScript库。
	jQuery库包含以下功能：HTML 元素选取；HTML 元素操作；CSS 操作；HTML 事件函数；JavaScript 特效和动画；HTML DOM 遍历和修改；AJAX；Utilities

（1.4）为什么要用jQuery

​	目前网络上有大量开源的 JS 框架, 但是 jQuery 是目前最流行的 JS 框架，而且提供了大量的扩展。很多大公司都在使用 jQuery：Google ；Microsoft；IBM；Netflix

（2） jQuery安装

（2.1）自己下载 jQuery 库，进行本地安装,（推荐使用）

​	从 [jquery.com](http://jquery.com/download/) 下载 jQuery 库-->将库文件复制到项目WebContent文件夹下的的js文件夹下-->在html代码中添加代码：

<head> 

​	<script type="text/javascript" src="js/jquery-1.11.0.js">

</head>

-->添加完成。

​	库文件夹简介：jQuery 库文件夹百度云盘有一份，第二阶段第十九天课程里也有一份。内部文件扩展名中带有min的属于压缩库，压缩库与同名的不压缩库功能一致，区别是压缩库代码可读性差，所以开发的时候一般用不压缩的，应用的时候用压缩的。在本课程中用的版本是1.11.0

（2.2）使用其它网站的CDN，这样就不必添加本地库，但需要有网络

​	很多网站都提供了CDN，可以任选其一，直接在html代码中导入即可使用：

<head>

​		<!--百度 CDN-->

​	<script 	 src="https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js">
	</script>

​		<!--新浪 CDN-->

​	<script 	 src="http://lib.sinaapp.com/js/jquery/2.0.2/jquery-2.0.2.min.js">
	</script>

​		<!-- Google CDN-->

​	<script 	 src="http://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js">
	</script>

​		<!--Microsoft CDN-->

​	<script 	 src="http://ajax.htmlnetcdn.com/ajax/jQuery/jquery-1.10.2.min.js">
	</script>

</head>

（2.3）jQuery加载和执行顺序演示

```
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>jquery演示1</title>
	<!--本地安装加载-->
	<!-- <script type="text/javascript" src="js/jquery-1.11.0.js"></script> -->
	<!--其他网站CDN加载-->
	<script src="https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>
</head>

<body onload="doLoad()">

<script type="text/javascript">
	//当页面dom元素解析（数据还没有加载）完毕执行
	//简写
	$(function(){
		alert("欢迎使用jquery框架");
	});
	
	$(function(){
		alert("欢迎使用jquery框架2222");
		
	});
	//原始写法
	$(document).ready(function(){
		alert("欢迎使用jquery框架3333");
	});
	//onload页面加载事件,当页面中dom解析完毕，并且数据也加载完毕，才执行，onload可能会延迟
	function doLoad(){
		alert("页面执行完毕");	
	}
</script>

</body>
</html>
```

##### 15.2 jQuery语法(HTML/效果)

Query 语法是通过选取 HTML 元素，并对选取的元素执行某些操作。
基础语法： **$(selector).action()**

- 美元符号定义 jQuery
- 选择符（selector）"查询"和"查找" HTML 元素
- jQuery 的 action() 执行对元素的操作
  实例:
- $(this).hide() - 隐藏当前元素
- $("p").hide() - 隐藏所有 <p> 元素
- $("p.test").hide() - 隐藏所有 class="test" 的 <p> 元素
- $("#test").hide() - 隐藏所有 id="test" 的元素
- 隐藏、显示演示

```
</style>
</head>
	<body>
		<div id="box">这是div</div>
		<input type="button" value="点击" 		onclick="doClick()">
		<input type="button" value="点击2" onclick="doClick2()">	
			
			<script type="text/javascript">
				function doClick(){
					$("#box").hide();//隐藏		
				}
				function doClick2(){
					$("#box").show();//显示	
				}
			</script>
	</body>
</html>
```

（1） jQuery选择器

（1.1） 元素选择器

​	jQuery 元素选择器基于元素名选取元素。

（1.2）id选择器

​	jQuery #id 选择器通过 HTML 元素的 id 属性选取指定的元素。页面中元素的 id 应该是唯一的，所以您要在页面中选取唯一的元素需要通过 #id 选择器。

（1.3）class选择器

​	jQuery 类选择器可以通过指定的 class 查找元素。

（1.4）选择器演示

```
<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title>jquery选择器</title>
		<script type="text/javascript" src="js/jquery-1.11.0.js"></script>
	</head>
<body>
	<h2>静夜思</h2>
	<p>窗前明月光</p>
	<p>疑是地上霜</p>
	
	<div class="class1">div内容</div>
	<div class="class1">div内容</div>
	<div>div内容</div>
	
	<input id="btn" type="button" value="按钮">
	<input id="btn2" type="button" value="按钮2">
	<input id="btn3" type="button" value="按钮3">

	<script type="text/javascript">
		$(function(){
			
			<!--id选择器:通过 id 选取元素-->
			$("#btn").click(function(){		
				<!--元素选择器:选取所有 <p> 元素-->
				$("p").hide();//隐藏
			});//给按钮添加一个onclick事件
			
			$("#btn2").click(function(){
				<!--class选择器:通过 class 选取元素-->
				$(".class1").css("color","red");
			});
			
			$("#btn3").dblclick(function(){
				alert("你双击了按钮");
			});
		
			//$("#btn2").click();//相当于点击按钮
		});
		/* 
		$(document).ready(function(){	
		}); */
	</script>		
</body>
</html>
```

（2） jQuery事件

（2.1）什么是事件？

​	页面对不同访问者的响应叫做事件。事件处理程序指的是当 HTML 中发生某些事件时所调用的方法。实例：在元素上移动鼠标；选取单选按钮；点击元素。

​	在事件中经常使用术语"触发"（或"激发"），例如： "当您按下按键时触发 keypress 事件"。

- 常见 DOM 事件：

| 鼠标事件  | 键盘事件 | 表单事件 | 文档/窗口事件 |
| --------- | -------- | -------- | ------------- |
| click     | keypress | submit   | load          |
| dblclick  | keydown  | change   | resize        |
| mouseover | keyup    | focus    | scroll        |
| mouseout  |          | blur     | unload        |

（2.2） jQuery 事件方法语法

​	在 jQuery 中，大多数 DOM 事件都有一个等效的 jQuery 方法。
页面中指定一个点击事件：$("p").click();下一步是定义什么时间触发事件。您可以通过一个事件函数实现：

​	$("p").click(function(){
  		  // 动作触发后执行的代码!!
	});

​	也就是说，不传参数是点击，传参数是设置事件。

（2.2.1）常用的 jQuery 事件方法

​	$(document).ready() 方法允许我们在文档完全加载完后执行函数。该事件方法在 [jQuery 语法](http://www.runoob.com/jquery/jquery-syntax.html) 章节中已经提到过。

click()：当按钮点击事件被触发时会调用一个函数。该函数在用户点击 HTML 元素时执行。

dblclick()：当双击元素时，会发生 dblclick 事件。

mouseenter()：当鼠标指针穿过元素时，会发生 mouseenter 事件。

mouseleave()：当鼠标指针离开元素时，会发生 mouseleave 事件。

mousedown()：当鼠标指针移动到元素上方，并按下鼠标按键时，会发生 mousedown 事件。

mouseup()：当在元素上松开鼠标按钮时，会发生 mouseup 事件。

hover()：hover()方法用于模拟光标悬停事件，当鼠标移动到元素上时，会触发指定的第一个函数(mouseenter);当鼠标移出这个元素时，会触发指定的第二个函数(mouseleave)。

focus()：当元素获得焦点时，发生 focus 事件。当通过鼠标点击选中元素或通过 tab 键定位到元素时，该元素就会获得焦点。

blur()：当元素失去焦点时，发生 blur 事件。

（2.2.3）事件演示1

```
<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title>jquery事件</title>
		<style type="text/css">
			#box1{
				width:100px;
				height:100px;
				background-color: red;
			}
		</style>
	</head>

	<script type="text/javascript" src="js/jquery-1.11.0.js""></script>
	
<body>
	<div id="box1">xxx</div>
	
	<input id="btn" type="button" value="按钮">
	<input id="btn3" type="button" value="按钮3">
	
	<form id="form1" action="" method="post">
		用户名:<input type="text" name="username"/><br/>
		密码:<input type="text" name="password"/><br/>
	</form>
	
	<script type="text/javascript">
				
		$(function(){
			
			<!--click()事件 -->
			$("#btn").click(function(){		
				$("p").hide();//隐藏
			});//给按钮添加一个onclick事件
		
			<!--dblclick()事件 -->
			$("#btn3").dblclick()(function(){
				alert("你双击了按钮");
			});
			
			<!--mouseover()事件 -->
			$("#box1").mouseover(function(){
				$(this).css("backgroundColor","pink");
			});
			
			<!--mouseout()事件 -->
			$("#box1").mouseout(function(){
				$(this).css("backgroundColor","red");
			});
			
			//给form1表单中的input标签添加onfocus事件
			$("#form1 input").focus(function(){
	$(this).css("backgroundColor","#ffff00");
			});
			$("#form1 input").blur(function(){
				$(this).css("backgroundColor","white");
			});
		})
	</script>	
</body>
</html>
```

（2.2.3）事件演示2

```
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>表格鼠标经过变色</title>
<script type="text/javascript" src="js/jquery-1.11.0.js"></script>
</head>
<body>
	
	<table id="tab" border="1" width="500" height="200">
		<tr>
			<td>xxxx</td>
			<td>yyyy</td>
			<td>zzzz</td>
		</tr>
			<tr>
			<td>xxxx</td>
			<td>yyyy</td>
			<td>zzzz</td>
		</tr>
			<tr>
			<td>xxxx</td>
			<td>yyyy</td>
			<td>zzzz</td>
		</tr>
			<tr>
			<td>xxxx</td>
			<td>yyyy</td>
			<td>zzzz</td>
		</tr>
			<tr>
			<td>xxxx</td>
			<td>yyyy</td>
			<td>zzzz</td>
		</tr>
	</table>
	
	<script type="text/javascript">
		$(function(){
			/* $("#tab tr").mouseover(function(){
				
				$(this).css("backgroundColor","gray");
				
			});
			$("#tab tr").mouseout(function(){
				
				$(this).css("backgroundColor","white");
				
			}); */
			
			/*解析：令
			function(){
				$(this).css("backgroundColor","gray");
			}=a；
			function(){
				$(this).css("backgroundColor","white");
			}=b；
			则原程序可写成$("#tab tr").hover(a，b）
			即：给tr定义两个事件
			*/ 
			
			$("#tab tr").hover(function(){
				$(this).css("backgroundColor","gray");
			},function(){
				$(this).css("backgroundColor","white");
			});
			
		});
	
	</script>
</body>
</html>
```

（3）jQuery效果

（3.1）隐藏显示

hide():将元素隐藏

show():将元素显示

toggle():通过 jQuery，您可以使用 toggle() 方法来切换 hide() 和 show() 方法。显示被隐藏的元素，并隐藏已显示的元素

事实上，这三种方法都是有两个参数的：

​	$(selector).hide(speed,callback);

​	$(selector).show(speed,callback);

​	$(selector).toggle(speed,callback);

​	可选的 speed 参数规定隐藏/显示的速度，可以取以下值："slow"、"fast" 或毫秒。可选的 callback 参数是隐藏或显示完成后所执行的函数名称。

（3.2）淡入淡出

通过 jQuery，您可以实现元素的淡入淡出效果。jQuery 拥有下面四种 fade 方法：

jQuery fadeIn() 方法：淡入已隐藏的元素

jQuery fadeOut() 方法：用于淡出可见元素。

jQuery fadeToggle() 方法：jQuery fadeToggle() 方法可以在 fadeIn() 与 fadeOut() 方法之间进行切换。如果元素已淡出，则 fadeToggle() 会向元素添加淡入效果。如果元素已淡入，则 fadeToggle() 会向元素添加淡出效果。

以上三个方法同样有speed,callback这两个可选参数，且用法与显示隐藏函数的这两个参数一致。

jQuery fadeTo() 方法：允许渐变为给定的不透明度（值介于 0 与 1 之间）：$(selector).fadeTo(speed,opacity,callback);

​	必需的 speed 参数规定效果的时长。它可以取以下值："slow"、"fast" 或毫秒。fadeTo() 方法中必需的 opacity 参数将淡入淡出效果设置为给定的不透明度（值介于 0 与 1 之间）。可选的 callback 参数是该函数完成后所执行的函数名称。

（3.3）滑动

slideDown() 方法：用于向下滑动元素。

​	$(selector).slideDown(speed,callback);

​	可选的 speed 参数规定效果的时长。它可以取以下值："slow"、"fast" 或毫秒。可选的 callback 参数是滑动完成后所执行的函数名称。

slideUp() 方法：向上滑动元素。

​	$(selector).slideUp(speed,callback);

​	可选的 speed 参数规定效果的时长。它可以取以下值："slow"、"fast" 或毫秒。可选的 callback 参数是滑动完成后所执行的函数名称。

slideToggle() 方法：jQuery slideToggle() 方法可以在 slideDown() 与 slideUp() 方法之间进行切换。如果元素向下滑动，则 slideToggle() 可向上滑动它们。如果元素向上滑动，则 slideToggle() 可向下滑动它们。

​	$(selector).slideToggle(speed,callback);

​	可选的 speed 参数规定效果的时长。它可以取以下值："slow"、"fast" 或毫秒。可选的 callback 参数是滑动完成后所执行的函数名称。

```
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>jquery效果</title>
<script type="text/javascript" src="js/jquery-1.11.0.js""></script>
</head>
<body>
	<h1>静夜思</h1>
	<p>窗前明月光</p>
	<p>低头思故乡</p>
	<img id="img1" alt="" src="img/11.bmp" width="100" height="80">
	<img id="img2" alt="" src="img/timg.jpg" width="300" height="180">
	
	<input id="btn1" type="button" value="淡出">
	<input id="btn2" type="button" value="淡入">
	<input id="btn3" type="button" value="淡入淡出">
<input id="btn4" type="button" value="改变透明度">
<input id="btn5" type="button" value="滑入">
<input id="btn6" type="button" value="滑出">
	<script type="text/javascript">
	
		$(function(){
			/* $("h1").click(function(){
				$("p").toggle();
				
			}); */
			
			$("h1").hover(function(){
				$("p").show()
				.css("color","blue")
				.css("fontSize","20px");
			},function(){
				$("p").hide();
			});
			
			$("#btn1").click(function(){
				$("#img1").fadeOut(5000);
			});
			$("#btn2").click(function(){
				$("#img1").fadeIn(5000);
			});
			$("#btn3").click(function(){
				$("#img1").fadeToggle(5000);
			});
			$("#btn4").click(function(){ 
				$("#img1").fadeTo(5000,0); //0表示透明   1 不透明
			});
			$("#btn5").click(function(){ 
				$("#img2").slideDown(5000);
			});
			$("#btn6").click(function(){ 
				$("#img2").slideUp(5000);
			});
			
		})
	</script>	
</body>
</html>
```

（4）链式编程

​	直到现在，我们都是一次写一条 jQuery 语句（一条接着另一条）。不过，有一种名为链接（chaining）的技术，允许我们在相同的元素上运行多条 jQuery 命令，一条接着另一条。 这样的话，浏览器就不必多次查找相同的元素。如需链接一个动作，您只需简单地把该动作追加到之前的动作上。

​	下面的例子把 css()、slideUp() 和 slideDown() 链接在一起。"p1" 元素首先会变为红色，然后向上滑动，再然后向下滑动：

​	$("#p1").css("color","red").slideUp(2000).slideDown(2000);

​	如果需要，我们也可以添加多个方法调用。

​	当进行链接时，代码行会变得很差。不过，jQuery 语法不是很严格；您可以按照希望的格式来写，包含换行和缩进。

​	如：$("#p1").css("color","red")
		  .slideUp(2000)
 		 .slideDown(2000);

（5）jQuery HTML

​	jQuery 拥有可操作 HTML 元素和属性的强大方法。jQuery 中非常重要的部分，就是操作 DOM 的能力。jQuery 提供一系列与 DOM 相关的方法，这使访问和操作元素和属性变得很容易。

（5.1） 获得内容和属性 - text()、html() 、 val()以及attr()

- text() - 设置或返回所选元素的文本内容---->innerText
- html() - 设置或返回所选元素的内容（包括 HTML 标记）---innerHTML
- val() - 设置或返回表单字段的值---value属性
- attr()-jQuery attr() 方法用于设置或获取属性值

（5.2）设置内容和属性 -  text()、html() 、 val()以及attr()

- text() - 设置或返回所选元素的文本内容---->
- html() - 设置或返回所选元素的内容（包括 HTML 标记）
- val() - 设置或返回表单字段的值---value属性
- attr()-设置/改变属性值。

（5.3）jQuery dom操作演示

```
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>jQuerydom操作</title>
<script type="text/javascript" src="js/jquery-1.11.0.js""></script>
</head>
<body>
	<div id="txt1">原始内容</div>
	
	<input id="username" type="text" name="username">
	
	<input id="btn1" type="button" value="改变内容">
	<input id="btn2" type="button" value="获取value内容">
	
	<input id="btn3" type="button" value="改变属性">
	
	<img id="img1" alt="" src="img/11.bmp" width="100" height="80">
	<script type="text/javascript">
	
		$(function(){
			$("#btn1").click(function(){
				//html() - 设置或返回所选元素的内容
				//$("#txt1").html("<font color='red'>内容被html()方法改变了...</font>");
				//text() - 设置或返回所选元素的文本内容
				//$("#txt1").text("<font color='red'>内容被html()方法改变了...</font>");
				
	//html() - 设置或返回所选元素的内容（包括 HTML 标记）
				//var h=$("#txt1").html();
				//text() - 设置或返回所选元素的文本内容
				//var h=$("#txt1").text();
				//alert(h);
			});
			$("#btn2").click(function(){
			
			//val() - 设置或返回表单字段的值---value属性
				//var v=$("#username").val();
				$("#username").val("zhangsan");
			
			});
			$("#btn3").click(function(){	
				//var src=$("#img1").attr("src");
				//alert(src);
				//attr()方法用于设置或获取属性值
				$("#img1").attr("src","img/timg.jpg");	
			});	
		})
	</script>
</body>
</html>
```

（5.4）text()、html() 以及 val() 的回调函数

​	上面的三个 jQuery 方法：text()、html() 以及 val()，同样拥有回调函数。回调函数有两个参数：被选元素列表中当前元素的下标，以及原始（旧的）值。然后以函数新值返回您希望使用的字符串。

​	演示带有回调函数的 text() 和 html()：

```
$("#btn1").click(function(){
    $("#test1").text(function(i,origText){
        return "旧文本: " + origText + " 新文本: Hello world! (index: " + i + ")"; 
    });
});
 
$("#btn2").click(function(){
    $("#test2").html(function(i,origText){
        return "旧 html: " + origText + " 新 html: Hello <b>world!</b> (index: " + i + ")"; 
    });
});
```

（5.5）删除/添加元素

（5.5.1）删除元素

如需删除元素和内容，一般可使用以下两个 jQuery 方法：

- remove() - 删除被选元素（及其子元素）：$("#div1").remove();
- empty() - 从被选元素中删除子元素：$("#div1").empty();

jQuery remove() 方法也可接受一个参数，允许您对被删元素进行过滤。该参数可以是任何 jQuery 选择器的语法。如删除 class="italic" 的所有 <p> 元素：

​			$("p").remove(".italic");

（5.5.2）添加元素

添加新HTML 内容的四个 jQuery 方法:

- append() - 在被选元素的结尾插入内容：$("p").append("追加文本");
- prepend() - 在被选元素开头插入内容：$("p").prepend("在开头追加文本");
- after() - 在被选元素之后插入内容：$("img").after("在后面添加文本");
- before() - 在被选元素之前插入内容：$("img").before("在前面添加文本");

```
<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title>jquery添加元素</title>
		<script type="text/javascript" src="js/jquery-1.11.0.js"></script>
	</head>
	<body>
		<p id="p1" style="background-color: green; height: 100px;"></p>
		<div id="box1"></div>
		
		<input id="btn1" type="button"  value="添加元素"/>
		<input id="btn2" type="button"  value="删除元素"/>
		<script type="text/javascript">
			$("#btn1").click(function(){		
				$("#p1").append("<span style='color:red'>追加的内容</span>")
				$("#box1").append("<img src='img/003.jpg' alt=''>");
				
//				$("#box1").prepend("<h1>这是一级标题</h1>");
//				
//				$(this).after("<img src='img/003.jpg' alt=''>");
				
			});
			$("#btn2").click(function(){			
				//$("#p1").remove();//删除父元素
				$("#p1").empty();//清空内容
			});	
		</script>
	</body>
</html>
```

​	通过 append() 、prepend() 方法、after() 和 before() 添加若干新元素,以上四种方法方法能够通过参数接收无限数量的新元素。可以通过 jQuery 来生成文本/HTML（就像上面的例子那样），或者通过 JavaScript 代码和 DOM 元素。在下面的例子中，我们创建若干个新元素。这些元素可以通过 text/HTML、jQuery 或者 JavaScript/DOM 来创建。然后我们通过 append() ，after() 方法把这些新元素追加到文本中（对 prepend()、 before()  同样有效）：

```
function appendText()
{
    var txt1="<p>文本。</p>";              // 使用 HTML 标签创建文本
    var txt2=$("<p></p>").text("文本。");  // 使用 jQuery 创建文本
    var txt3=document.createElement("p");
    txt3.innerHTML="文本。";               // 使用 DOM 创建文本 text with DOM
    $("body").append(txt1,txt2,txt3);        // 追加新元素
}

function afterText()
{
    var txt1="<b>I </b>";                    // 使用 HTML 创建元素
    var txt2=$("<i></i>").text("love ");     // 使用 jQuery 创建元素
    var txt3=document.createElement("big");  // 使用 DOM 创建元素
    txt3.innerHTML="jQuery!";
    $("img").after(txt1,txt2,txt3);          // 在图片后添加文本
}
```

（5.6）CSS类

jQuery 拥有若干进行 CSS 操作的方法。我们将学习下面这些：

- addClass() - 向被选元素添加一个或多个类:   $("button").click(function(){
    	$("h1,h2,p").addClass("blue");
   	 $("div").addClass("important");

  ​	$("body div:first").addClass("important blue");

  });	  

- removeClass() - 从被选元素删除一个或多个类:   

  $("h1,h2,p").removeClass("blue");

- toggleClass() - 对被选元素进行添加/删除类的切换操作: $("h1,h2,p").toggleClass("blue");

- css() - 设置或返回样式属性：

  ```
  如需返回指定的 CSS 属性的值，请使用如下语法：
  	css("propertyname");
  返回首个匹配元素的 background-color 值：
  	$("p").css("background-color");
  设置指定的 CSS 属性，请使用如下语法：
  	css("propertyname","value");
  为所有匹配元素设置 background-color 值:
  	$("p").css("background-color","yellow");
  如需设置多个 CSS 属性，请使用如下语法：	css({"propertyname":"value","propertyname":"value",...});	
  为所有匹配元素设置 background-color 和 font-size：
  $("p").css({"background-color":"yellow","font-size":"200%"});
  ```

（5.6.1）css操作

```
<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title></title>
		<style type="text/css">
			.error{
				color: red;
				font-size: 16px;
				background-color: bisque;
			}
			
		</style>
		<script type="text/javascript" src="js/jquery-1.11.0.js" ></script>
	</head>
	<body>
		<div>div内容</div>
		
		<input id="btn1" type="button" value="按钮"  />
		<script type="application/javascript">
			$(function(){
				$("#btn1").click(function(){
					//$("div").addClass("error");// .className;
					//$("div").removeClass("error");
					//$("div").toggleClass("error");
					$("div").css({"background-color":"red","font-size":"30px"});
				});
				
			})
			
		</script>
	</body>
</html>
```

（5.7） 尺寸

**jQuery 尺寸方法**

jQuery 提供多个处理尺寸的重要方法：

- width()
- height()
- innerWidth()
- innerHeight()
- outerWidth()
- outerHeight()

jQuery width() 和 height() 方法

width() 方法设置或返回元素的宽度（不包括内边距、边框或外边距）。

height() 方法设置或返回元素的高度（不包括内边距、边框或外边距）。

下面的例子返回指定的 &lt;div&gt; 元素的宽度和高度：

```
$("button").click(function(){
  var txt="";
  txt+="div 的宽度是: " + $("#div1").width() + "</br>";
  txt+="div 的高度是: " + $("#div1").height();
  $("#div1").html(txt);
});
```

jQuery innerWidth() 和 innerHeight() 方法

innerWidth() 方法返回元素的宽度（包括内边距）。

innerHeight() 方法返回元素的高度（包括内边距）。

下面的例子返回指定的 &lt;div&gt; 元素的 inner-width/height：

```
$("button").click(function(){
  var txt="";
  txt+="div 宽度，包含内边距: " + $("#div1").innerWidth() + "</br>";
    txt+="div 高度，包含内边距: " + $("#div1").innerHeight();
  $("#div1").html(txt);
});
```

jQuery outerWidth() 和 outerHeight() 方法

outerWidth() 方法返回元素的宽度（包括内边距和边框）。

outerHeight() 方法返回元素的高度（包括内边距和边框）。

下面的例子返回指定的 &lt;div&gt; 元素的 outer-width/height：

```
$("button").click(function(){
  var txt="";
  txt+="div 宽度，包含内边距和边框: " + $("#div1").outerWidth() + "</br>";
  txt+="div 高度，包含内边距和边框: " + $("#div1").outerHeight();
  $("#div1").html(txt);
});
```

##### 15.3  jQuery遍历

（1）jQuery 遍历，意为"移动"，用于根据其相对于其他元素的关系来"查找"（或选取）HTML 元素。以某项选择开始，并沿着这个选择移动，直到抵达您期望的元素为止。下图展示了一个家族树。通过 jQuery 遍历，您能够从被选（当前的）元素开始，轻松地在家族树中向上移动（祖先），向下移动（子孙），水平移动（同胞）。这种移动被称为对 DOM 进行遍历。

​	使用jquery的each方法遍历演示：

```
<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title>使用jquery的each方法遍历</title>
	</head>
		<script type="text/javascript" src="js/jquery-1.11.0.js"></script>
	<body>
		<div> div1</div>
		<div> div2</div>
		<div> div3</div>
		<div> div4</div>	
	<script type="text/javascript">
		$(function(){
			$("div").css("color","red");//隐式迭代
			//alert($("div").length);
			//1使用for
			for(var i=0;i<$("div").length;i++){
				//dom对象
				//var domdiv=$("div")[i]; //不能使用jquery中的方法
				//$(domdiv);
				
				//jquery对象
//				var $div=$("div").eq(i);
//				if(i==1){
//					$div.css("fontSize","20px");
//				}
				//alert($div);
			}
			//2使用jquery的中each方法
			
			$("div").each(function(i,n){ //i索引  n每一个dom元素
				$(n).css("backgroundColor","pink");
				
			});
			
		})
		
	</script>		
	</body>
</html>
```

（2）祖先

 	jQuery parent() 方法返回被选元素的直接父元素，该方法只会向上一级对 DOM 树进行遍历。返回每个 <span> 元素的的直接父元素：

​		$("span").parent();

​	jQuery parents() 方法返回被选元素的所有祖先元素，它一路向上直到文档的根元素 (<html>)，返回所有 <span> 元素的所有祖先：

​		$("span").parents();

​	可以使用可选参数来过滤对祖先元素的搜索。返回所有 <span> 元素的所有祖先，并且它是 <ul> 元素：

​		$("span").parents("ul");

​	jQuery parentsUntil() 方法返回介于两个给定元素之间的所有祖先元素，返回介于 <span> 与 <div> 元素之间的所有祖先元素：

​		$("span").parentsUntil("div");

（3）后代

​	jQuery children() 方法返回被选元素的所有直接子元素，该方法只会向下一级对 DOM 树进行遍历。返回每个 <div> 元素的所有直接子元素：	$("div").children();

​	可以使用可选参数来过滤对子元素的搜索。返回类名为 "1" 的所有 <p> 元素，并且它们是 <div> 的直接子元素：

​		 $("div").children("p.1");

​	jQuery find() 方法返回被选元素的后代元素，一路向下直到最后一个后代。返回属于 <div> 后代的所有 <span> 元素：

​		 $("div").find("span");

​	下面的例子返回 <div> 的所有后代：

​		$("div").find("*");

（4）同胞

​	jQuery siblings() 方法返回被选元素的所有同胞元素。返回 <h2> 的所有同胞元素：$("h2").siblings();

​	也可以使用可选参数来过滤对同胞元素的搜索。返回属于 <h2> 的同胞元素的所有 <p> 元素： $("h2").siblings("p");

​	jQuery next() 方法返回被选元素的下一个同胞元素。该方法只返回一个元素,返回 <h2> 的下一个同胞元素：$("h2").next();

​	jQuery nextAll() 方法返回被选元素的所有跟随的同胞元素。返回 <h2> 的所有跟随的同胞元素： $("h2").nextAll();

​	jQuery nextUntil() 方法返回介于两个给定参数之间的所有跟随的同胞元素。返回介于 <h2> 与 <h6> 元素之间的所有同胞元素：

​				$("h2").nextUntil("h6");

（5）过滤

​	jQuery first() 方法返回被选元素的首个元素。选取首个 <div> 元素内部的第一个 <p> 元素：$("div p").first();

​	jQuery last() 方法返回被选元素的最后一个元素。选择最后一个 <div> 元素中的最后一个 <p> 元素：$("div p").last();

​	jQuery eq() 方法返回被选元素中带有指定索引号的元素。索引号从 0 开始，因此首个元素的索引号是 0 而不是 1。下面的例子选取第二个 <p> 元素（索引号 1）：$("p").eq(1);

​	jQuery filter() 方法允许您规定一个标准。不匹配这个标准的元素会被从集合中删除，匹配的元素会被返回。返回带有类名 "url" 的所有 <p> 元素：$("p").filter(".url");

​	jQuery not() 方法方法返回不匹配标准的所有元素。提示：not() 方法与 filter() 相反。返回不带有类名 "url" 的所有 <p> 元素： 	

​			$("p").not(".url");

jQuery节点关系（祖父子孙）演示：

```
<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title>jQuery节点关系</title>
		<script type="text/javascript" src="js/jquery-1.11.0.js" ></script>
	</head>
	<body>
		<div>xxxx</div>
		
		<div id="div1">
			<p>
				<span id="span1">span标签</span>
				
			</p>
			<p>
				<span id="span2">span2标签</span>
				
			</p>
			
		</div>
		<h1>标题1</h1>
		<h2>标题2</h2>
		
		<script type="text/javascript">
		
			$(function(){
				var $p1=$("#span1").parent();//获取父节点
				$p1.css("baound-color","red");
				
				//alert($("#span1").parents().length);//所有的父节点
				
				//alert($("#div1").children().length);//直接孩子节点
				
				//alert($("#div1").find("span").length);//从后代中查找
				var $s= $("#div1").siblings();
				$s.each(function(i,n){
					console.log(n);
				});
			});
		</script>
		
	</body>
</html>
```

##### 15.4  jQuery AJAX

（1）jQuery AJAX简介

​	AJAX = 异步 JavaScript 和 XML（Asynchronous JavaScript and XML）。简短地说，在不重载整个网页的情况下，AJAX 通过后台加载数据，并在网页上进行显示。使用 AJAX 的应用程序案例：谷歌地图、腾讯微博、优酷视频、人人网等等。

（2）load方法

​	jQuery load() 方法是简单但强大的 AJAX 方法。从服务器加载数据，并把返回的数据放入被选元素中。

​	$(selector).load(URL,data,callback);

​	必需的 *URL* 参数规定您希望加载的 URL。

​	可选的 *data* 参数规定与请求一同发送的查询字符串键/值对集合。

​	可选的 *callback* 参数是 load() 方法完成后所执行的函数名称。该参数也可以规定当 load() 方法完成后所要允许的回调函数。回调函数可以设置不同的参数：*responseTxt* - 包含调用成功时的结果内容；*statusTXT* - 包含调用的状态；*xhr* - 包含 XMLHttpRequest 对象。在 load() 方法完成后显示一个提示框。如果 load() 方法已成功，则显示"外部内容加载成功！"，而如果失败，则显示错误消息：

```
$("button").click(function(){
  $("#div1").load("demo_test.txt",function(responseTxt,statusTxt,xhr){
    if(statusTxt=="success")
      alert("外部内容加载成功!");
    if(statusTxt=="error")
      alert("Error: "+xhr.status+": "+xhr.statusText);
  });
});
```

​	load示例：

```
<!--demo_test.txt-->
<h2>jQuery AJAX 是个非常棒的功能！</h2>
<p id="p1">这是段落的一些文本。</p>

把文件 "demo_test.txt" 的内容加载到指定的 <div> 元素中：
$("#div1").load("demo_test.txt");
```

​	也可以把 jQuery 选择器添加到 URL 参数。把 "demo_test.txt" 文件中 id="p1" 的元素的内容，加载到指定的 <div> 元素中：

​	$("#div1").load("demo_test.txt #p1");

```
<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title>jqueryajax请求</title>
		<script type="text/javascript" src="js/jquery-1.11.0.js" ></script>
	</head>
	<body>
		<input id="btn1" type="button" value="发送ajax请求" />
		
		
		<script type="text/javascript">
			$(function(){
				$("#btn1").click(function(){
					//ajax原始请求(见Ajax大章节)
					//1创建
					//2设置回调函数
					//3open打开
					//4send发送
					
					//jquery的ajax请求
					$.ajax({
						url:"http://localhost:8080/day19web3/plainservlet?id=123",//地址
						type:"GET",//请求方式
						dataType:"text",//期望服务器的返回类型
						success:function(data){
							alert(data);
						}
					});	
				});	
			})	
		</script>
	</body>
</html>
```

（3）get和post方法

（3.1）jQuery $.get() 方法

​	$.get() 方法通过 HTTP GET 请求从服务器上请求数据。

​	$.get(URL,callback);

​	必需的 *URL* 参数规定您希望请求的 URL。

​	可选的 *callback* 参数是请求成功后所执行的函数名。

​	使用 $.get() 方法从服务器上的一个文件中取回数据：

```
$("button").click(function(){
  $.get("demo_test.php",function(data,status){
    alert("数据: " + data + "\n状态: " + status);
  });
});
```

（3.2）jQuery $.post() 方法

​	$.post() 方法通过 HTTP POST 请求从服务器上请求数据。

​	$.post(*URL,data,callback*);

​	必需的 *URL* 参数规定您希望请求的 URL。

​	可选的 *data* 参数规定连同请求发送的数据。

​	可选的 *callback* 参数是请求成功后所执行的函数名。

​	使用 $.post() 连同请求一起发送数据：

```
$("button").click(function(){
    $.post("/try/ajax/demo_test_post.jsp",
    {
        name:"百度",
        url:"http://www.baidu.com"
    },
        function(data,status){
        alert("数据: \n" + data + "\n状态: " + status);
    });
});
```

jqueryajax请求演示：

```
/**
*PlainServlet：servlet函数，用于Ajax请求数据
*/
@WebServlet("/plainservlet")
public class PlainServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
    public PlainServlet() {
        super();
    }
	protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		//1乱码
		request.setCharacterEncoding("utf-8");
		response.setContentType("text/plain;charset=utf-8");
		//允许跨域访问
		response.addHeader("Access-Control-Allow-Origin", "*");  // jsonp
		String id = request.getParameter("id");
		System.out.println(id);
		//2响应
		PrintWriter out = response.getWriter();
		out.write("ajax返回的数据");
	}
	protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		doGet(request, response);
	}
}

/**
*xmlservlet：servlet函数，用于Ajax请求数据
*/
@WebServlet("/xmlservlet")
public class XmlServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
    public XmlServlet() {
        super();
    }
	protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		//1乱码
		request.setCharacterEncoding("utf-8");
		response.setContentType("text/xml;charset=utf-8");
		
		String id = request.getParameter("id");
		System.out.println(id);
		//2响应
		PrintWriter out = response.getWriter();
		out.write("<?xml version='1.0' encoding='utf-8'?>");
		out.write("<books>");
		out.write("<book>");
		out.write("<id>10001</id>");
		out.write("<bookname>java宝典</bookname>");
		out.write("</book>");
		out.write("</books>");
	}
	protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		doGet(request, response);
	}
}

/**
*postservlet：servlet函数，用于Ajax请求数据
*/
@WebServlet("/postservlet")
public class PostServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
    public PostServlet() {
        super();
    }

	protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		//1乱码
		request.setCharacterEncoding("utf-8");
		response.setContentType("text/plain;charset=utf-8");
		//2接收数据
		String username=request.getParameter("username");
		String password=request.getParameter("password");
		System.out.println(username+"...."+password);
		
		response.getWriter().write("登录成功");
	}
	protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		doGet(request, response);
	}
}

/**
*jsonservlet：servlet函数，用于Ajax请求数据
*/
@WebServlet("/jsonservlet")
public class JsonServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
    public JsonServlet() {
        super();
    }
	protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		//1乱码
		request.setCharacterEncoding("utf-8");
		//response.setContentType("text/json;charset=utf-8");//老的写法
		response.setContentType("application/json;charset=utf-8");//新的写法
		//response.setContentType("application/javascript;charset=utf-8");//新的写法
		
		//2返回json数据
		PrintWriter out = response.getWriter();
		//3写
		out.write("{\"id\":1001,\"name\":\"张三\",\"age\":20}");
	}
	protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		doGet(request, response);
	}
}


/**
*jqueryajax请求1 html函数
*/
<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title>jqueryajax请求</title>
		<script type="text/javascript" src="js/jquery-1.11.0.js" ></script>
	</head>
	<body>
		<input id="btn1" type="button" value="发送ajax请求1 get" />
		<input id="btn2" type="button" value="发送ajax请求2 get" />
		<input id="btn3" type="button" value="发送ajax请求3 get" />
		<input id="btn4" type="button" value="发送ajax请求4 post" />

		<script type="text/javascript">
			$(function(){
				$("#btn1").click(function(){
					//ajax请求
					//1创建
					//2设置回调函数
					//3open打开
					//4send发送
					
					//jquery的ajax请求
					$.ajax({
						url:"plainservlet?id=123",//地址
						type:"GET",//请求方式
						dataType:"text",//期望服务器的返回类型
						success:function(data){
							alert(data);
						}
					});	
				});
				
				$("#btn2").click(function(){
					//ajax请求
					//1创建
					//2设置回调函数
					//3open打开
					//4send发送
					
					//jquery的ajax请求
					$.ajax({
						url:"xmlservlet",//地址
						type:"GET",//请求方式
						dataType:"xml",//期望服务器的返回类型
						success:function(data){
							alert(data.getElementsByTagName("bookname")[0].innerHTML);
							
						}
					});
					
				});
				
				$("#btn3").click(function(){
					//ajax请求
					//1创建
					//2设置回调函数
					//3open打开
					//4send发送
					
					//jquery的ajax请求
					$.ajax({
						url:"jsonservlet",//地址
						type:"GET",//请求方式
						dataType:"json",//期望服务器的返回类型
						success:function(data){
							alert(data.id);
							alert(data.name);
							alert(data.age)
						}
					});
					
				});
				
				
				$("#btn4").click(function(){
					//ajax请求
					//1创建
					//2设置回调函数
					//3open打开
					//4send发送
					
					//jquery的ajax请求
					$.ajax({
						url:"postservlet",//地址
						type:"POST",//请求方式
						dataType:"text",//期望服务器的返回类型
						data:"username=zhangsan&password=888",//发送的数据
						contentType:"application/x-www-form-urlencoded",//告诉服务器数据类型
						success:function(data){
							alert(data);
						}
					});
					
				});
				
			})
			
		</script>
	</body>
</html>

/**
*jqueryajax请求2 html函数（包含load）
*/
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>jquery的load方法</title>
<script type="text/javascript" src="js/jquery-1.11.0.js" ></script>
</head>
<body>

	<div id="box"></div>
	<input id="btn1" type="button" value="加载数据">
	<input id="btn2" type="button" value="get()方法">
	<input id="btn3" type="button" value="post()方法">
	<script type="text/javascript">
		$(function(){
			$("#btn1").click(function(){
				$("#box").load("plainservlet",{"id":888,"name":"zhangsan"});
			});
			
			$("#btn2").click(function(){
				$.get("jsonservlet",{"id":888,"name":"zhangsan"},function(data){
					$("#box").html(data.id+"..."+data.name+"..."+data.age);
				},"json");
			});
			
			$("#btn3").click(function(){
				$.post("postservlet",{"username":"hahaha","password":"99999"},function(data){
					alert(data);
				},"text");
			});
		});	
	</script>
</body>
</html>
```

##### 15.5 noConflict

（1）jQuery noConflict方法

​	jQuery 使用 $ 符号作为 jQuery 的简写。

​	如果其他 JavaScript 框架也使用 $ 符号作为简写怎么办？其他一些 JavaScript 框架包括：MooTools、Backbone、Sammy、Cappuccino、Knockout、JavaScript MVC、Google Web Toolkit、Google Closure、Ember、Batman 以及 Ext JS。

​	其中某些框架也使用 $ 符号作为简写（就像 jQuery），如果您在用的两种不同的框架正在使用相同的简写符号，有可能导致脚本停止运行。jQuery 的团队考虑到了这个问题，并实现了 noConflict() 方法。

​	jQuery noConflict() 方法会释放对 $ 标识符的控制，这样其他脚本就可以使用它了。当然，您仍然可以通过全名替代简写的方式来使用 jQuery。

（1.1）jquery让渡演示

```
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>jquery让渡</title>

<script type="text/javascript" src="js/jquery-1.11.0.js" ></script>
</head>
<body>
	<script type="text/javascript">
		$(function(){
			alert("欢迎使用Jquery");
			
		});
		//把$符号让给其他框架，也可以创建自己的简写：noConflict() 可返回对 jQuery 的引用，您可以把它存入变量，以供稍后使用
		var jq=$.noConflict();
		
		//仍然可以通过全名替代简写的方式来使用 jQuery
		jQuery(function(){
			alert("欢迎使用Jquery222222");	
		})
		
		jq(function(){
			alert("欢迎使用Jquery33333333");
		});		
		//特殊情况：如果你的 jQuery 代码块使用$简写，并且您不愿意改变这个快捷方式。
	那么您可以把$ 符号作为变量传递给 ready 方法。这样就可以在函数内使用 $ 符号了 - 而在函数外，依旧不得不使用 "jQuery"：
		(function($){
			//继续使用$
			$(function(){
				alert("欢迎使用Jquery44444444");
			})	
		})(jQuery);	
	</script>
</body>
</html>
```

#### 第十六章 文件上传下载

##### 16.1 文件上传

（1）实现文件上传

（1.1）项目准备

​	导入: commons-fileupload.jar； commons-io.jar

​	其他可能jar包：jstl.jar   ; standard.jar

（1.2）文件上传三要素

- 提供form表单,method必须是post!
- form表单的enctype必须是multipart/form-data
- 提供 input type="file" 类型输入

```
/**
 * 上传页面
 */
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>注册页面</title>
</head>
<body>

	<h2>用户注册</h2>
	<!--提供form表单,method必须是post;form表单的enctype必须是multipart/form-data-->
	<form action="${pageContext.request.contextPath }/upLoadfile" method="post" enctype="multipart/form-data">
		用户名:<input type="text" name="username"/><br/>
		邮箱:<input type="text" name="email"/><br/>
		<!--提供 input type="file" 类型输入-->
		文件1:<input type="file" name="myfile1"><br/>
		<input type="submit" value="提交">
	</form>
</body>
</html>

/**
 * 文件上传 服务器1
 */
@WebServlet("/upLoadfile")
public class UpLoadFileServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
    public UpLoadFileServlet() {
        super();
    }
	protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		//1乱码
		request.setCharacterEncoding("utf-8");
		response.setContentType("text/html;charset=utf-8");
		String s=request.getParameter("username");
		System.out.println("s..........."+s);
		
		//得到上传文件的保存目录，将上传的文件存放于WEB-INF目录下，不允许外界直接访问，保证上传文件的安全
		String path=request.getServletContext().getRealPath("/WEB-INF/upload");
		File dir=new File(path);
		//判断上传文件的保存目录是否存在
		if(!dir.exists()) {
			dir.mkdirs();
		}
		//2处理文件上传
		//2.1创建磁盘文件工厂
		DiskFileItemFactory factory=new DiskFileItemFactory();
		//设置缓存大小
		factory.setSizeThreshold(1024*100);//设置缓存大小100k
		//设置缓存的位置
		//factory.setRepository(new File("d:\\temp"));
		
		//2.2创建文件解析器
		ServletFileUpload upload=new ServletFileUpload(factory);
		//2.3判断是不是多分布表单
		if(!ServletFileUpload.isMultipartContent(request)) {
			return;
		}
		//2.4解析
		upload.setHeaderEncoding("utf-8");//解决文件名中文问题
		//控制文件上传大小
		//控制单个文件大小
		upload.setFileSizeMax(1024*1024*2);
		//控制总的文件大小
		upload.setSizeMax(1024*1024*50);
		try {
		//使用ServletFileUpload解析器解析上传数据，解析结果返回的是一个List<FileItem>集合，每一个FileItem对应一个Form表单的输入项
			List<FileItem> fileItems=upload.parseRequest(request);
			if(fileItems!=null) {
				for (FileItem fileItem : fileItems) {
					//处理表单中的数据 普通数据 username email
					if(fileItem.isFormField()) {
						String name=fileItem.getFieldName();
						//解决普通输入项的数据的中文乱码问题
						String value=fileItem.getString("utf-8");				
						System.out.println(name+"....."+value);
						
					}else { //fileitem中封装的是上传文件
						//流处理
						InputStream is=fileItem.getInputStream();
						String filename=fileItem.getName();//获取文件名
						//如果没有上传文件
						if(filename==null||filename.trim().equals("")) {
							continue;
						}
						
						//控制上传的文件的类型
						String ext=filename.substring(filename.lastIndexOf(".")+1);
						List<String> acceptExts=new ArrayList<String>();
						acceptExts.add("jpg");
						acceptExts.add("png");
						if(!acceptExts.contains(ext)) {
							response.getWriter().write(filename+"不支持文件上传");
							continue;
						}
	 //注意：不同的浏览器提交的文件名是不一样的，有些浏览器提交上来的文件名是带有路径的，如：  c:\a\b\1.txt，而有些只是单纯的文件名，如：1.txt		
						//新的文件名
						String newfilename=FileUploadUtils.getNewFileName(filename);
						//新的目录
						String newpath=FileUploadUtils.getNewPath(dir.getAbsolutePath(), filename);
						FileOutputStream fos=new FileOutputStream(newpath+"\\"+newfilename);
						 //创建一个缓冲区
						byte[] buf=new byte[1024*4];
						//判断输入流中的数据是否已经读完的标识
						int len=0;
						//循环将输入流读入到缓冲区当中
						while((len=is.read(buf))!=-1) {
							fos.write(buf, 0, len);
						}
						
						fos.close();
						is.close();
						
						System.out.println(filename+"文件上传成功");
						response.getWriter().write(filename+"文件上传成功");	
					}	
				}	
			}
		} catch (FileUploadException e) {
			e.printStackTrace();
		}	
	}
	protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		// TODO Auto-generated method stub
		doGet(request, response);
	}
}
```

（2）文件上传细节注意

​	上述的代码虽然可以成功将文件上传到服务器上面的指定目录当中，但是文件上传功能有许多需要注意的小细节问题，以下列出的几点需要特别注意的：1、为保证服务器安全，上传文件应该放在外界无法直接访问的目录下，比如放于WEB-INF目录下。  2、为防止文件覆盖的现象发生，要为上传文件产生一个唯一的文件名。 3、为防止一个目录下面出现太多文件，要使用hash算法打散存储。4、要限制上传文件的最大值。 5、要限制上传文件的类型，在收到上传文件名时，判断后缀名是否合法。

##### 

#### 第999章 xiala

