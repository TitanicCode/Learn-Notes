###第一部葵花宝典

#### 第一节 **设计模式**

#####1.1 单例设计模式

1.概念：单例设计模式：某个类在类外只能创建一个对象。

2.实现原理：得到一个类的对象，需要通过new关键字，调用构造方法创建对象，若构造方法私有化，则会阻止对构造方法的调用，那么对象将不能在类外被创建。从而实现单例的设计模式。

3.实现步骤：

1）私有化构造方法和属性；2）在类内部声明一个本类静态的对象作为属性；3）提供一个共有静态的方法用来获取本类对象。

4.实现方式：

懒汉式和饿汉式

```java
1.4.1饿汉式：    public class Boss{
					private String name; //私有化构造属性
					private int age; //私有化构造属性
					private Boss(String name, int age){ //私有化构造方法
						this.name = name;
						this.age = age;
					}
					private static Boss boss = new Boss("马云",12); //私有静态本类对象作为属性
					public static Boss getBoss(){ //提供共有静态方法获取本类对象
						return boss;
					}
				}
	饿汉式Test：  public class Test2 {
					public static void main(String[] args) {
						SingleTon2 s=SingleTon2.getInstance();
						System.out.println(s.hashCode());
					}
				}
	懒汉式：	pulbic class King{
					private String name; //私有化构造属性
					private int age; //私有化构造属性
					private King(String name, int age){ //私有构造方法
						this.name = name;
						this.age = age;
					}
					private static King king; //私有静态本类对象
					public static King getKing(){//共有静态方法获取本类对象
						if(king==null){
							king = new King("唐太宗",12);
						}
							return king;
					}
				}
	懒汉式Test：	public class Test {
						public static void main(String[] args) {
							SingleTon singleTon=SingleTon.getInstance();
							System.out.println(singleTon.hashCode());
						}
					}
```

##### 1.2 装饰者设计模式

1.要实现装饰者模式,注意一下几点内容：	

		a.装饰者类要实现真实类同样的接口
		b.装饰者类内有一个真实对象的引用(可以通过装饰者类的构造器传入)
		c.装饰类对象在主类中接受请求,将请求发送给真实的对象(相当于已经将引用传递到了装饰类的真实对象)
		d.装饰者可以在传入真实对象后,增加一些附加功能(因为装饰对象和真实对象都有同样的方法,装饰对象可	以添加一定操作在调用真实对象的方法,或者先调用真实对象的方法,再添加自己的方法)
		e.不用继承
代码实现：

	public abstract class ReadFile {
		public abstract void read();
	}
	
	public class ReadMusicFile extends ReadFile{
		public void read() {
			System.out.println("没有缓冲的读音乐文件");
		}
	}
	
	public class ReadTextFile extends ReadFile{
		public void read() {
			System.out.println("没有缓冲的读文本文件");		
		}
	}
	
	public class ReadVideoFile extends ReadFile {
		public void read() {
			System.out.println("没有缓冲的读视频文件");		
		}
	}
	
	/*
	 * 装饰类 ：提供新的打印方法
	 */
	public class PrintReadFile extends ReadFile{
		private ReadFile readFile;
		public PrintReadFile( ReadFile readFile) {
			this.readFile=readFile;
		}
		public void read(){		
		}
		public void print(){	
		}
		public void println(){	
		}
	}
	
	/*
	 * 装饰类 增强类
	 */
	public class BuffedReadFile extends ReadFile{
		private ReadFile readFile;
		public BuffedReadFile(ReadFile readFile) {
			this.readFile = readFile;
		}
		public void read(){
			System.out.println("使用缓冲功能读取文件");
			readFile.read();
		}
	}
	
	import java.io.BufferedReader;
	import java.io.PrintStream;
	public class Test {
		public static void main(String[] args) {
			ReadFile readFile=new ReadVideoFile();
			BuffedReadFile brf=new BuffedReadFile(readFile);
			brf.read();	
		}
	}


##### 1.3 简单工厂设计模式

1.动机：考虑一个简单的软件应用场景，一个软件系统可以提供多个外观不同的按钮（如圆形按钮、矩形按钮、菱形按钮等），这些按钮都源自同一个基类，不过在继承基类后不同的子类修改了部分属性从而使得它们可以呈现不同的外观，如果我们希望在使用这些按钮时，不需要知道这些具体按钮类的名字，只需要知道表示该按钮类的一个参数，并提供一个调用方便的方法，把该参数传入方法即可返回一个相应的按钮对象，此时，就可以使用简单工厂模式。

2.优缺点：

   优点：工厂类含有必要的判断逻辑，可以决定在什么时候创建哪一个产品类的实例，客户端可以免除直接创建产品对象的责任，而仅仅“消费”产品；简单工厂模式通过这种做法实现了对责任的分割，它提供了专门的工厂类用于创建对象。

   缺点：由于工厂类集中了所有产品创建逻辑，一旦不能正常工作，整个系统都要受到影响。使用简单工厂模式将会增加系统中类的个数，在一定程序上增加了系统的复杂度和理解难度。系统扩展困难，一旦添加新产品就不得不修改工厂逻辑，在产品类型较多时，有可能造成工厂逻辑过于复杂，不利于系统的扩展和维护。

3.案例实现：

	import java.util.Scanner;
	public class Test {
		public static void main(String[] args) {
			System.out.println("请选择您要的衣服1 裤子 2外套 3T-shirt");
			Scanner input=new Scanner(System.in);
			String choice=input.next();
			Clothes clothes=ClothesFactory.make(choice);
			clothes.show();
			check(clothes);
		}
		public static void check(Clothes clothes){
			if(clothes instanceof Pants){
				Pants pants=(Pants)clothes;
				pants.print1();
			}else if(clothes instanceof Coat){
				Coat coat=(Coat)clothes;
				coat.print2();
			}else if(clothes instanceof T_shirt){
				T_shirt t_shirt=(T_shirt)clothes;
				t_shirt.print3();
			}
		}
	}
	
	/*
	 * 服装（父类）
	 */
	public abstract class Clothes {
		//设计赋值
		public abstract void design();
		//生产
		public abstract void produce();
		public abstract void show();
	}
	
	public class T_shirt extends Clothes {
		public void design() {
			System.out.println("开始设计T恤...");
		}
		public void produce() {
			System.out.println("开始制作T恤...");
		}
		public void show() {
			System.out.println("这是一件T恤");
		}
		public void print3(){
			System.out.println("zzzzzzz");
		}
	}
	
	/*
	 * 外套
	 */
	public class Coat extends Clothes {
		public void design() {
			System.out.println("开始设计外套...");
		}
		public void produce() {
			System.out.println("开始制作外套...");
		}
		public void show() {
			System.out.println("这是一件外套");
		}
	
		public void print2(){
			System.out.println("yyyyyy");
		}
	}
	
	/*
	 * 裤子
	 */
	public class Pants extends Clothes {
		public void design() {
			System.out.println("开始设计裤子.....");
		}
		public void produce() {
			System.out.println("开始生产裤子....");
		}
		public void show() {
			System.out.println("这是一条裤子");
		}
		public void print1(){
			System.out.println("xxxxxxx");
		}
	}
	
	/**
	 * 服装厂
	 */
	public class ClothesFactory {
		//1 裤子 2外套 3T恤
		public static Clothes make(String type){
			Clothes clothes=null;
			if(type.equals("1")){
				clothes=new Pants();
			}else if(type.equals("2")){
				clothes=new Coat();
			}else if(type.equals("3")){
				clothes=new T_shirt();
			}
			if(clothes!=null){
				clothes.design();
				clothes.produce();
			}
			return clothes;
		}
	}
#### 第二节 **内部类**

##### 2.1 成员内部类：

		public class Outer {
			int num=10;
			String name="阿福";
			public void show(){
				System.out.println("外部类的num:"+num);
			}
		    class Inner{//添加成员内部类；成员内部类作为外部类的成员存在，与成员变量和成员方法平级，故访问修饰符可以任意；成员内部类中不能添加静态成员
		   		 int num2=20;	//内部类中成员变量
				 String name="阿毛";
				 public void print(){
						System.out.println("成员内部类:num2:"+num2);
						show();//在成员内部类中可以直接调用外部类的成员变量和方法
						System.out.println("成员内部类中调用外部类的num:"+num);
						System.out.println(this.name);//打印阿毛
						System.out.println(Outer.this.name); //打印阿福，当成员内部类中属性和外部类中属性名称相同，内部类优先级高,如果想调用外部类的属性，外部类名称.this.属性名
				 }
			
			 }
		}
			
	Test函数：	
	  public class Test {
			public static void main(String[] args) {
				Outer outer=new Outer();//1创建外部类Outer对象
				outer.show();
				//2创建内部类对象
				Outer outer2=new Outer();//2.1创建外部类对象
				Outer.Inner inner=outer2.new Inner();//2.2创建内部类对象
				Outer.Inner inner2=new Outer().new Inner();//3一步完成内部类的创建
				inner2.print();
			}
	   }
##### 2.2 局部内部类：

		public class Outer {
			int num=10;
			String name="阿福";
			public void show(){
				 String address="beijing";//默认final类型
				 int num2=20;//方法中局部变量名与局部内部类变量名相同时，在局部内部类无法打印该变量
	    		 class Inner{//1 局部内部类 和局部变量同级，不能使用任何访问修饰符。
						int num2=20;
						String name="阿毛";
						public void print(){
							System.out.println("num2:"+num2);
							System.out.println("num:"+num);//打印20
							System.out.println(name);//打印阿毛
							System.out.println(Outer.this.name);//打印阿毛
							System.out.println(address);// 如果局部内部类中访问局部变量，必须是常量，jdk1.8之后，不需要手工添加final
						}
				 }
	  		     Inner inner=new Inner(); //2创建局部内部类对象
	   		     inner.print();
	   		 }
	    }
	    Test：
	    public class Test {
			public static void main(String[] args) {
				Outer outer=new Outer();
				outer.show()；//局部内部类不用再在主函数中创建对象，因为他在局部方法中就已经被调用了
			}
	   }	

##### 2.3 静态内部类：

1）私有化构造方法和属性；2）在类内部声明一个本类静态的对象作为属性；3）提供一个共有静态的方法用来获取本类对象。



		public class Outer {
			int num=10;
			String name="阿福";
			static String country="中国";
			public  void show(){
				System.out.println(this.num);
				System.out.println(this.name);
				System.out.println(Outer.country);
			}
			public static  void show2(){
				Outer o=new Outer();//静态方法访问本类非静态成员需要创建对象。
				System.out.println(o.num);
				System.out.println(o.name);
				System.out.println(Outer.country);
			}	
			public static class Inner{//静态内部类，只有内部类才可以定义成静态的，和静态属性和静态方法同级
				int num2=20;
				String name="阿毛";
				static String address="东莞";
				public void  print(){
					System.out.println("num2:"+this.num2);
					System.out.println("name:"+this.name);
					System.out.println("address:"+Inner.address);
					Outer o=new Outer();//创建对象
					System.out.println(o.name);
					System.out.println(o.num);
				}
			}
	}
	Test：
	public class Test {
		public static void main(String[] args) {
			Outer.Inner inner=new Outer.Inner();//不需要外部类对象，可以直接创建静态内部类对象
			inner.print();
		}
	}
##### 2.4 匿名内部类：

```java
cryable外部接口：
	public interface Cryable {
			void cry();//叫
	}
狗类实现接口cryable：
	public class Dog implements Cryable{
		public void cry() {
			System.out.println("汪汪的叫...");
		}
	}
Test：
	public class Test {
		public static void main(String[] args) {
			Cryable cryable=new Dog();
			cryable.cry();
	 		/*Cryable cryable2=new Cryable() {//若一个接口的实现类或一个抽象类的子类只需要使用一次，可以使用匿名内部类；匿名内部类只能创建一个对象
					public void cry() {
						System.out.println("喵喵的叫...");	
					}
			};
			cryable2.cry();*/ 
}
注：匿名内部类中可以声明独有的属性和方法，但是由于接口引用不能访问实现类中独有的属性和方法，所以一般不在匿名内部类中声明独有的方法匿名对象：若在匿名内部类中声明了独有的方法或属性，可以使用匿名对象访问，不能通过对象名.方法名()访问。
例：public static void main(String[]args){
	//匿名对象调用成员方法
	new I(){
		public void fun(){}
		public void fun1(){
			System.out.println("匿名内部类的fun1");
		}
	}.fun1();//使用匿名内部类的匿名对象调用匿名内部类中独有的方法
	//new Animal().eat();
}
```
#### 第三节 **基础**

##### 3.1 DOS命令：

```java
cd：change directory 改变目录 ；cd .. 返回上一级目录  ；  cd \或cd /  返回根目录； d: 切换盘符d盘； cd programs 进入programs目录
cmd：command 命令提示符（windows键加R打开运行）
dir  [盘符:][目录路径] [/p]  [/s]  [/w]  [/o]  
	/p 分页显示下一页内容，按任意键查看下一屏
	/s 显示所有目录及其子目录下所有文件
	/w 宽屏显示
	/o 分类顺序显示
md：make directory 建目录，可以建开头为.的名字的文件夹（直接建是建不起来的）；md myPhoto\aaa\bbb 在当前目录下创建myPhoto\aaa\bbb多级目录（注：md建的是文件夹）
type nul>a.mp3(创建空的MP3文件夹)；
echo 15106910621>123.txt(创建内容为15106910621的文本文件，名字是123)；
copy a.txt d:\myFile 复制a.txt文件到d:\myFile文件夹中；copy myFile myPhoto  只赋值myFile文件夹下的所有文件到myPhoto中,不包括子文件夹中的文件；如果要复制所有子文件夹下文件可使用:
	xcopy myFile myPhoto /s  不能复制空目录
	xcopy myFile myPhoto /e  复制空目录
rd：只能删除空目录，不能删除当前目录；rd myFile 删除myFile目录；rd myFile\aaa 只能删除aaa目录，不能删除myFile目录
del:删除目录中的一个或一组文件,不能删除目录;del info.txt 删除info.txt文件;del myFile\* 删除myFile目录下所有的文件
- cls命令：清空屏幕
- exit命令：退出dos命令行
- mspaint：打开画图板
- notepad：打开记事本
/*在cmd中执行Java文件注意事项*/
1.源文件要改为.java文件
2.cd：转向源文件所在位置
2.javac ****.Java
3.Java ****
```

##### 3.2 进制转换：

​	n进制转十进制：如（1201）：1乘以n^0+0乘以n^1+2乘以n^2+1乘以n^3。

##### 3.3 java运行核心机制：

​	1.Java虚拟机(Java Virtual Machine) JVM： JVM可以理解成一个可运行Java字节码的虚拟计算机系统。它有一个解释器组件，可以实现Java字节码和计算机操作系统之间的通信；对于不同的运行平台，有不同 的JVM。 JVM屏蔽了底层运行平台的差别，实现了“一次编译，随处运行”。所以Java语言是跨平台的。

​	java源代码编写--》编译--》java字节码（可跨平台）--》运行--》不同系统的JVM

​	2.垃圾回收器(Garbage Collection) ： 在C/C++等语言中，由程序员负责回收无用内存,而Java语言消除了程序员回收无用内存空间的责任；JVM提供了一种系统线程跟踪存储空间的分配情况。并在JVM的空闲时，检查并释放那些可以被释放的存储空间。垃圾回收器在Java程序运行过程中自动启用，程序员无法精确控制和干预，即使程序员通过代码告诉垃圾回收器执行，也不会立即回收内存。

##### 3.4 JDK，环境搭建：

​	1. JDK软件打开安装程序后，原安装软件会自动删除

​	2.环境配置：

​	 我的电脑--》属性--》高级系统配置--》环境变量

​	系统变量下新建--》变量名：JAVA_HOME 变量值：JDK安装目录--》确定

​	系统变量中点Path变量--》编辑--》在变量值文本框最前面添加%JAVA_HOME%\bin;--》确定

​	（可选）系统变量点classpath--》编辑--》在变量值文本框最前面添加.;%JAVA_HOME%\lib\rt.jar;%JAVA_HOME%\lib\tools.jar

##### 3.5  基本数据类型：

```java
1.Java中所有的基本数据类型都有固定的存储范围和所占内存空间的大小，而不受具体操作系统的影响，以保证Java程序的可移植性 
byte: 1个字节 ，范围 -128 到 127
short: 2个字节 ，范围 -32168到 32767
int：4个字节 
long :8个字节；long  l = 3L；
float:4个字节； float  f = 3.14f；float精度为小数点后6-7位，6位最准确，7位会不准确
double:8个字节；可精确到小数点后15-16位，float和double存储的都是近似值
char:2个字节；char ch='8';char类型定义需要加单引号，且单引号内只能有一个字符；ch+1表示的指向ch的下一个地址，即ch+1=‘9’；char c2=97，97没有加单引号，故表示的是将ASCII码赋予c2
boolean：不确定
注1.除了这八种基本数据类型外，其它数据类型均为引用型数据类型。基本数据存储在栈中，引用数据类型存储在堆中。如：String。
```
2.自动类型转换：数据类型取值范围小的转为取值范围大的；强制转型：数据类型取值范围大的转为取值范围小的；

    自动转型方向：
    * byte ---> short--->int--->long--->float --->double
    * char---> int
    * byte,short,char三者在计算时会转换成int类型  （了解）（故：byte b1=10；byte b2=20； byte b3=b1+b2会出问题）
    * int整型常量和字符常量在合理范围内可以直接赋值给 byte、short、int、char （了解）
    强制转型：long a=100L；int n=（int）a；
    short s;-->s=s+2与s+=2的区别：
    	s=s+2会编译失败，因为在运算过程中，s会被提升为int类型，无法赋值给s；而s+=2会编译通过，因为+=运算符在给s赋值时，会自动完成强转操作。
##### 3.6  常用函数，常用类：

​	1. 数学函数：

```
 （1）/*Math*/
  public class Demo4 {
 	 public static void main(String[] args) {	
		//1绝对值
		System.out.println("Math.abs---------");//absolute
		System.out.println(Math.abs(10));
		System.out.println(Math.abs(-2.8));
		//2立方根
		System.out.println("Math.cbrt---------");//cube root
		System.out.println(Math.cbrt(27));
		//3ceil()返回大于或等于这个数字的最小整数
		System.out.println("Math.ceil---------");
		System.out.println(Math.ceil(5));
		System.out.println(Math.ceil(5.2));	
		System.out.println(Math.ceil(5.8));
		//4floor()返回小于或等于这个数字的最大整数
		System.out.println("Math.floor---------");
		System.out.println(Math.floor(3.5));
		System.out.println(Math.floor(4));
		System.out.println(Math.floor(3.2));
		//5pow(double a, double b) a的b次幂
		System.out.println("Math.pow---------");
		System.out.println(Math.pow(2,10));
		//6random()，返回0-1之间的随机数  含0不含1
		System.out.println(Math.random());
		//7round(); 四舍五入
		System.out.println("Math.round---------");
		System.out.println(Math.round(3.4));
		System.out.println(Math.round(2.89));
		System.out.println((double)Math.round(1.43389*100)/100);
		//8平方根
		System.out.println("Math.sqrt---------");
		System.out.println(Math.sqrt(25));
	}
}
(2)	import java.math.BigDecimal;
	import java.math.BigInteger;
	public class Test2 {
		public static void main(String[] args) throws Exception{
			BigDecimal b1=new BigDecimal("1.4");  //1.4+(-0.5);
			BigDecimal b2=new BigDecimal("-0.5");
			BigDecimal b3=new BigDecimal("0.9");
			BigDecimal result=b1.add(b2).divide(b3);//这种算法比“+”要准确，故适合高精度运算
			System.out.println(result);
			BigInteger bigInteger= new BigInteger("1231241312312312412312312123123413123");
			BigInteger bigInteger2=new BigInteger("1123124131231231241231231212312314123");
			BigInteger result2=bigInteger.add(bigInteger2);
			System.out.println(result2);
		}
	}
```

​          2.Random类：

```
import java.util.Random;
/*Random()随机数类,伪随机数*/
public class Demo5 {
	public static void main(String[] args) {
		//1伪随机数对象(48位种子，根据时间生成)
		Random random=new Random();/*创建一个新的随机数生成器。此构造方法将随机数生成器的种子设置为某个值，该值与此构造方法的所有其他调用所用的值完全不同。*/
		System.out.println(random.nextDouble());//2nextDouble(); 0-1之间随机数 含0不含1	
		System.out.println(random.nextInt());//3返回一个整数		
		System.out.println(random.nextInt(100));//4返回0-99之间的整数
		Random random2=new Random(1234);//5创建伪随机数对象(种子多少1234)
		Random random3=new Random(1234);
		System.out.println("----------------------");
		System.out.println(random2.nextDouble());
		System.out.println(random3.nextDouble());
		System.out.println(random2.nextDouble());
		System.out.println(random3.nextDouble());
	}
}
		Random random = new Random(10);
		random.setSeed(20);//将随机数种子设置为20,修改种子
```

​	   3.System类：

```java
import java.util.Arrays;
import java.util.Date;
/*System类*/
public class Demo6 {
	public static void main(String[] args) {
		//1 System.err
		//System.err.println("错误信息");
		//2 arraycopy(Object src, int srcPos, Object dest, int destPos, int length) 
		/*src 复制的源数组   srcPos 从源数组的哪个位置, dest 目标数组， destPos 目标数组的位置， length复制的长度*/
		int[] src={10,5,8,100,200,80,90};
		int[] dest=new int[src.length];
		System.arraycopy(src, 2, dest, 2, 2);
		System.out.println(Arrays.toString(dest));
		//3 currentTimeMillis()获取当前时间，毫秒数;long time2 = System.nanoTime();获取当前时间，毫微秒
		System.out.println(new Date(System.currentTimeMillis()).toLocaleString());
      }
}
System.exit();//强制退出当前正在执行的虚拟机
System.gc()： 运行垃圾回收器。
```

​	 4.Runtime类：	

```java
	public class Demo8 {
		public static void main(String[] args) throws Exception{
			Runtime runtime=Runtime.getRuntime();//1获取当前应用程序的运行时		
			System.out.println(runtime.availableProcessors());//2availableProcessors() 	
			//Process process=runtime.exec("notepad");//3执行一个cmd命令
			//System.out.println("五秒钟后关闭记事本");
			//Thread.sleep(3000);
			//process.destroy();//销毁
			//4退出jvm虚拟机
			//runtime.exit(0);
			//5获取空闲内存量 
			System.out.println(runtime.freeMemory()/1024/1024);
			//6返回内存总量totalMemory()
			System.out.println(runtime.totalMemory()/1024/1024);
			//7返回jvm可以使用的最大内存数
			System.out.println(runtime.maxMemory()/1024/1024);
		}
	}
```


​	5.方法函数：

​	  （1）return：在没有返回值的方法中使用return，作用是结束整个方法，此时return单独成句：
​			                             即：	return；

​	  （2）switch：

	  int i = 1;
	  switch(i){/*switch(表达式expr)中，expr是变量名，所以即使是字符类型也不用加单引号，如char ch=‘1’；switch（ch）；表达式expr的值必须是下述几种类型之一：byte、short、int、char、enum；java7之后可以是String。*/
	
	  		case 1://case子句中的值const 必须是常量值(或final的变量)，case中的值不能是一个范围
	   				System.out.println("Hello World!");
	   				break;// break是帮助跳出switch 语句的, 如果执行过程中没有遇到break，程序将继续向下执行，且不会再进行判断，直到遇到break为止
	   			case 2:
	   				System.out.println("Hello World!2");
	   			case 3:
	   				System.out.println("Hello World3");
	   				break;
	   			default://default子句是可选的（不是必须的）
	   				System.out.println("Haaaa");
	   				break;
	   	}
​     （3）this（参数列表，可以为空）：访问本类中的构造函数

​		a.必须出现在构造方法中
​		b.访问的是除了当前构造方法之外的其他构造方法
​		c.具体访问的是哪个构造方法，取决于所传的参数
​		d.只能书写在构造方法的第一条语句
​		e.this()在同一个构造方法中只能出现一次

​     6.Object类：

​        类Object是类层次结构的根类。每个类都使用Object作为超类。此类包含以下函数：

​      （1）equals()方法：

​		==比较对象的引用（地址）； 默认情况equals和==一样；String类型重写了Object中的equals，所以String比较使用equals方法，这样比较的就是字符串的值而不是地址了。

​      （2） hashCode()方法：返回该对象的哈希码值。每一个对象的哈希码值唯一。	

	Object obj1 = new Object();
	Object obj2 = new Object();
	Object obj3 = obj2;
	//obj2与obj3两个对象的哈希码值一样
	System.out.println(obj1.hashCode());
	System.out.println(obj2.hashCode());
	System.out.println(obj3.hashCode());
​     （3） getClass()方法：返回此Object的运行时类。通过某个对象通过反射获取类。

	Object obj = new Object();
	Class cls = obj.getClass();//通过反射获取到了Object类

​	(4) toString()方法:返回该对象的字符串表示。可以在自定义类中重写toString方法，以实现是对象转成指定格式的字符串。

    	public class Person{
    		String name;
    		public Person(String name){
    			this.name = name;
    		}
      		public String toString(){//重写toString方法
    			return "name="+name;
            }
    	}
    	public class DemoPerson{
     		 public static void main(String[]args){
    			Person p = new Person("张三");
      			System.out.println(p);//输出结果为：name=张三
      		}
    	}
    	toString应用：
    		StringBuffer sb=new StringBuffer();//创建一个空的StringBuffer对象;其初始容量为16个字符 
    		sb.append("hello world");//1追加
    		sb.append("我爱编程");
    		System.out.println(sb.toString());
    		//注意两个toString的调用方法，注意sb是个对象
    		int[] arr={1,2,3,4,5};
    		System.out.println(Arrays.toString(arr));
7.常用类

（1）Date类：Date表示特定的瞬间，精确到毫秒。Date类中的大部分方法都已经被Calendar类中的方法所取代。

```
import java.util.Date;//导入Date包
import javax.xml.crypto.Data;
/* Date时间类*/
 public class Demo1 {
 	public static void main(String[] args) {
		//1创建时间对象
		//1.1表示当前时间
		Date date=new Date();//分配Date对象并初始化此对象，以表示分配它的时间（精确到毫秒）。
		System.out.println(date.toString());
		System.out.println(date.toLocaleString());
		//1.2表示2016-10-1 10:10:10;
		Date date2=new Date(123412312333L);/*分配Date对象并初始化此对象，以表示自从标准基准时间（称为“历元（epoch）”，即 1970 年 1 月 1 日 00:00:00 GMT）以来的指定毫秒数。*/
		System.out.println(date2.toLocaleString());
		//2比较两个时间的前后
		System.out.println(date.after(date2));//若date在date2之后，则返回true，否则返回false
		System.out.println(date.before(date2));//若date在date2之前，则返回true，否则返回false
		//3比较两个时间，返回1 或者-1 相同返回0
		System.out.println(date.compareTo(date2));//若date大于date2，则返回1，相等返回0，小于返回-1；
		System.out.println(date2.compareTo(date));
		//4返回某个时间的毫秒数
		long l = date.getTime();//获取时间
		System.out.println(l);
	}
}
```

（2）calendar类：Calendar类是一个抽象类，它为特定瞬间与一组诸如YEAR、MONTH、DAY_OF_MONTH、HOUR等日历字段之间的转换提供了一些方法，并为操作日历字段（例如获得下星期的日期）提供了一些方法。瞬间可用毫秒值来表示，它是距历元（即格林威治标准时间 1970 年 1 月 1 日的 00:00:00.000，格里高利历）的偏移量。

```
import java.util.Calendar;
import java.util.Date;
/*Calendar"2016-10-10""2016-10-10 10:10:10"*/
public class Demo2 {
  	public static void main(String[] args) {
		//1创建日历对象
		Calendar calendar=Calendar.getInstance();//Calendar类是抽象类不能创建对象，可以通过Calendar类中的静态getInstance方法获取对象//Calendar c = Calendar.newInstance();
		//2获取当前是哪一年
		int year=calendar.get(Calendar.YEAR);//注意大小写
		System.out.println(year);
		//3获取月(0-11 )
		int month=calendar.get(Calendar.MONTH);
		System.out.println(month+1);
		//4获取日
		int day=calendar.get(Calendar.DAY_OF_MONTH);
		System.out.println(day);
		//小时 分钟 秒
		int hour=calendar.get(Calendar.HOUR);
		int minute=calendar.get(Calendar.MINUTE);
		int second=calendar.get(Calendar.SECOND);
		System.out.println(hour+":"+minute+":"+second);
		//表示2016-10-1 10:10:10;
		Calendar calendar2=Calendar.getInstance();
		calendar2.set(2016, 9, 1, 10, 10, 10);//显示的月份会加一
		Date date=calendar2.getTime();
		System.out.println(date.toLocaleString());
	}
}
//获取某个属性所表示的最大、最小值
Calendar c = Calendar.newInstance();
int max = c.getMaximum(Calendar.DATE);//获取日期的最大值,无论c表示几月份,max的值都是31
int min = c.getMinimum(Calendar.DATE);//获取日期的最小值,无论c表示几月份,min的值都是1
//获取指定Calendar对象的指定属性的最大、最小值
Calendar c = Calendar.newInstance();
int max = c.getActualMaximum(Calendar.DATE);/若c表示的1月，则max值为31；若c表示的4月，则max值为30；
int min = c.getActualMimimum(Calendar.DATE);//无论c表示几月份，min值都是1
```

（3）SimpleDateFormat类：

> SimpleDateFormat是一个以与语言环境有关的方式来格式化和解析日期的具体类。
>
> 它允许进行格式化（日期 -> 文本）、解析（文本 -> 日期）和规范化。

> 通过SimpleDateFormat类将字符串和日期相互转换时，需要使用一些时间模式字母，常用的时间模式字母：

```
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Date;
import java.util.Formatter;
/*SimpleDateFormat用于格式化时间，实现时间和字符串之间的转换*/
public class Demo3 {
	    public static void main(String[] args) throws Exception{
	    	//1把字符转换成时间  "2016-10-10"
	    	String str="2016-10-10 12:10:5"; // yyyy-MM-dd HH:mm:ss
			//2pattern  时间模式
			DateFormat df=new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
			//3转换
			Date date=df.parse(str);
			System.out.println(date.toLocaleString());
			//2时间转成字符  ,符合一定模式   xxxx年xx月xx日  xx时xx分xx秒
			DateFormat df2=new SimpleDateFormat("yyyy年MM月dd日  HH时mm分ss秒");
			System.out.println(df2.format(date));
			//3xxxx/xx/xx
			DateFormat df3=new SimpleDateFormat("yyyy/MM/dd");
			System.out.println(df3.format(date));
			//4SimpleDateFormat其他方法
			Calendar calendar=df3.getCalendar();
			System.out.println(calendar.getTime());
		}
}	
```

（4） Arrays工具类：Arrays工具类存在于java.util包下，所以使用的第一步就是导包：import java.util.Arrays;

但凡是工具类，类中的方法全部是静态的，方便调用---调用语法：类名.方法名（实参列表）

	import java.util.*;
	class ArraysUsageDemo {
		public static void main(String[] args) {
	    	int[] arr = new int[10];//使用动态初始化的方式初始化一个数组
			//1.填充
			Arrays.fill(arr,10); //将指定的 int 值10分配给指定 int 型数组arr的每个元素。
			//Java但凡涉及到区间问题，一般规律：包头不包尾，前闭后开区间
			Arrays.fill(arr,2,6,56);// 将指定的 int值56分配给指定int 型数组arr下标2到5的每个元素。 
			//2.排序	
			int[] arr1 = {43,2,65,1,45,9898,989};
			Arrays.sort(arr1);//对指定的 int 型数组按数字arr1升序进行排序。默认情况下只能进行升序排序
			Arrays.sort(arr1,2,5);//对指定 int 型数组arr1的指定范围下标为[2,5)按数字升序进行排序。
			//3.二分法查找：前提必须是排好序的数组
			int key = 45;
			int result1 = Arrays.binarySearch(arr1,key);//对指定的 int 型数组按数字arr1执行key的查找
			System.out.println(result1);
	
			int result2 = Arrays.binarySearch(arr1,3，54，20);对指定的 int 型数组按数字arr1的指定范围下标为3-53的范围内执行key的查找
			System.out.println(result2);
			//4.拷贝
			int[] newArr1 = Arrays.copyOf(arr1,3);// 复制指定的数组，截取或用 0 填充（如有必要），以使副本具有指定的长度3。 
			int[] newArr2 = Arrays.copyOfRange(arr1,2,6);//将指定数组的指定范围复制到一个新数组。 
			//5.将数组转换为字符串
			System.out.println(arr1);//[I@15db9742
			System.out.println(Arrays.toString(arr1));//[1, 2, 43, 45, 65, 989, 9898]
			//6.比较数组
			int[] array1 = {1,54,76};//如果两个数组以相同顺序包含相同的元素，则两个数组是相等的。
			int[] array2 = {1,54,76};//如果两个数组引用都为 null，则认为它们是相等的
			System.out.println(Arrays.equals(array1,array2));//true
			System.out.println(array1 == array2);//false
		}
	}

##### 3.7  方法构造，重载，重写：

​      （1）构造方法的语法：访问权限修饰符 类名() {
​						//方法体
​				  }	

		public Cat(){
			System.out.println("无参构造执行了...");	
		}
​	创建一个对象时，构造方法会首先被自动调用；如果不写构造方法，系统会默认为我们提供一个无参的构造方法；构造方法没有返回值类型；如果添加了构造方法，系统不再提供默认的构造方法。构造方法也可以被重载。

​      （2）方法重载：同一个类中，方法名字相同，参数列表不同（包括参数个数不同，或者参数数据类型不同），则是重载。方法的重载与方法的修饰符和返回值没有任何关系。方法的重载发生在同一个类中	

```java
class TextDemo04 
{
	public static void main(String[] args) 
	{
		//对于重载方法而言，具体调用的是哪个方法，取决于所传的参数
		show("10");
		show("10",10);
	}
}
```
​	（3）方法重写：子类继承父类后（方法重写是在两个不同类中，发生在继承的过程中），方法名字相同，参数列表相同，方法体不同，子类方法的访问权限大于等于父类中被重写方法的访问权限，这个过程中，在子类会对父类方法进行完善，这个完善过程叫做方法重写，方法的重写相当于在子类中覆盖父类中的方法。

​	注a：静态方法不能被重写，当子类定义了与父类静态方法名称参数列表相同的方法时，父类的对应静态方法会自动隐藏。

##### 3.8  递归算法：

​	在一个方法的方法体内调用该方法本身，称为方法的递归，方法递归包含了一种隐式的循环，会重复执行某段代码，但是这种重复不需要使用循环语句来进行控制，

​	出现问题： StackOverFlowError 栈空间溢出异常，所以递归不能一直运行，一定要有结束条件。

​	递归心得：（1）先找出固定值写出if语句（2）找出逻辑关系（3）返回逻辑值

​	案例： 求斐波那契数列中的某个数：

```java
/*
	斐波那契数列
	位置：1,2,3,4,5,6, 7, 8, 9,10,11,.....
	数值：1,1,2,3,5,8,13,21,34,55,89....
	分析：
		1.第一个位置和第二个位置上的数是固定的，都是1
		2.第n个位置上的数 = 第n - 1个位置上的数 + 第n - 2个位置上的数
		fun(1)  = 1
		fun(2) = 1
		fun(3) = fun(2) + fun(1) = 1  + 1
		fun(4) = fun(3) + fun(2) = fun(2) + fun(1) +fun(2)
		....
		fun(n) = fun(n - 1) + fun(n -2)
	*/
class  DiGuiUsageDemo01{
	public static void main(String[] args){
	
		int result1  = fun(10);
		System.out.println(result1);
	}
	//需求：报个数，获取在斐波那契数列中对应的数
	public static int fun(int n) {
		if(n == 1 || n == 2) {//（1）先找出固定值写出if语句
			return 1;
		} else {
			int num1 = fun(n - 1);//fun函数中调用fun函数，故为递归。
			int num2 = fun(n -2);
			int sum = num1  + num2;//（2）找出逻辑关系
			System.out.println("num1=" + num1 + ",num2=" + num2);
			return sum;//（3）返回逻辑值.注：谁调用就返回给谁
		}
	}
}
```
##### 3.9 位运算符，反码补码：

​	（1）a<<b=a*2^b;例：3<<2=3乘以2^2=12

​	a>>b=a/2^b;例：6>>2=6/2^2=1

​	>>最高位补什么由原有数据的最高位决定;>>>:最高位只能补0；

​	（2）反码：正数的反码与原码相同，负数的反码是除符号位外对其原码逐位取反。例10010反码11101；010反码010

​	补码：正数补码与原码相同，负数补码是其反码加1.

​	而负数的表示是正数按位取反后加1，和反码无关。

##### 3.10 类，内存：

​	（1）一个Java文件中可以写多个类，如果写多个类，则编译后会生成多个.class文件
​	          一个Java文件中最多只能有一个被public修饰的类，这个类的类名必须和Java源文件名保持一致
​		  一个Java文件中如果只有一个类，并且这个类不用public修饰的话，类名和文件名可以不一样，但习惯上，我们都会写上public

​		一个Java文件中可以没有被public修饰的类。

​	（2）在同一个类中，在静态方法中只能直接调用静态方法，若要调用非静态方法需要创建类的对象；在非静态方法中可以直接调用非静态方法和静态方法。

​		 在不同类中，如果要访问另外一个类中的静态成员变量和静态方法 类名.静态成员变量  类名.静态方法名

​	（3）类中的成员变量是全局变量，又称为属性，当对象被创建时，出现在堆内存当中（局部变量：所属的区间被运算时，出现在栈内存当中），成员变量因为在堆内存当中，所以他有默认的初始值。

​	（4）程序运行时，操作系统会分配三块主要的内存空间

- **栈**：直接存放基本类型的局部变量，和引用类型的地址

- **堆**：存放引用类型的实际数据部分

- **方法区**：（静态区、串池、代码段）方法区中有一块空间叫串池，用来存放字符串常量；静态区用来存放静态方法和静态变量

  (5)printf()   格式化输出，"%"表示进行格式化输出，"%"之后的内容为格式的定义,如%.2f  保留小数点后2位，%d    "d"表示输出十进制整数。

##### 3.11枚举：

​	枚举是一个引用类型，本质上就是类，枚举就是一个规定了取值范围的变量类型,枚举变量不能使用其他的数据，只能使用枚举中常量赋值,提高程序安全性,常量一般都写大写字母,final

```java
public enum Week {//public enum 枚举名{
	MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATERDAY, SUNDAY;	//枚举的取值范围
  	//在枚举中可以声明方法，但是必须在所有的取值之后声明，而且最后一个值后必须使用分号隔开.
}
public enum Gender {
	MALE("男"),FEMALE("女");
	private String value;
	private Gender(String s){
		this.value=s;
	}
	public String getValue(){
		return value;
	}
}
public class Test {
	public static void main(String[] args) {
		Week week=Week.MONDAY;
		System.out.println(week);
		//String sex="妖";
		Gender sex=Gender.FEMALE;
		System.out.println(sex.getValue());
		switch (sex) {// byte  short int char String 枚举
		case FEMALE:
			System.out.println("女");
			break;
		case MALE:
			System.out.println("男");
			break;
		default:
			break;
		}
	}
}
```

##### 3.12 eclipse：

(1)快捷键：

ctrl+shift+f：格式化代码	 ctrl+S：保存文件      	ctrl+shift+o：导包
ctrl+alt+方向键上下键：向上或向下复制	          alt+方向键的上下键：向上或向下移动
alt+shift+j：文档注释	          ctrl+shift+/：多行注释      	       ctrl+shift+\:取消多行注释
shift+enter：强制向下换行        ctrl+shift+enter 强制向上换行
更多资料：可参考http://www.runoob.com/eclipse/eclipse-create-java-project.html

（2）提取方法放到主函数外：选中需要提取的语句-->refactor-->extract method-->设置函数名

（3）shift+alt+s：生成get set函数；生成tostring，equals重写

​	Syso+alt+/  输出函数书写

（4）辅助配置：windows--preferences--java--editor--content assist--Autoactivation triggers for java--.a-zA-Z(@,--Auto activation delay(ms):20

（5）设置字体：windows--preferences--general--appearance--colors and font--java Editor Text Font--edit

（6）更改字码：windows--preferences--general--workspace--testfile encoding--other--UTF-8

（7）打开项目：左边package Explorer空白处右击--import--general--Exisiting projects into workspace

#### 第四节 经典程序

1. 如何不借助第三个变量，交换两个数据

```
public class OtherThing {
	public static void main(String[]  args) {
		int num1=4;
		int num2=81;
		num1=num1^num2;//异或,按位异或
		num2=num1^num2;//n^m^m=n;m^n^n=m
		num1=num1^num2;
		System.out.println("num1="+num1+" num2="+num2);	
	}
}
```

   2.最大公约数的计算：

	int num1=m;
	int num2=n;
	while(num1%num2!=0){
	  int temp=num1%num2;
	  num1=num2;
	  num2=temp;
	}
	则num2是m和n的最大公约数，（m*n）/num2是最小公倍数。

 3.设计一个图书类Book，包括私有属性：编号、书名、价格，实现图书自动编号

​    设计一个工具类Tools，工具类中设计以下方法：

​	1）在一个图书数组中按编号查找图书，并将图书信息输出，
​	分析：返回值：可以不要返回值
​	参数：需要，两个，Book数组、编号	
​	2）在一个图书数组中按价格查找图书，并将查找到的所有图书返回（注意考虑相同价格的图书，返回一个数组）
分析：返回值：有，一个新数组（Book），是查询到指定价格的图书
​	   参数：需要，两个，Book数组，价格

​	3）在主方法中创建一个图书数组，调用工具类中的按编号查找图书，再调用按价格查找图书，再将所有查找到的图书信息输出，图书信息的输出格式：编号是xx，书名xxx，价格是xx

	public class Book {
		private int id;
		private String bookname;
		private double price;
		public static int count=0;//计数
		{
			count++;
			this.id=count;
		}
		public Book() {	
		}
		public Book(String bookname, double price) {
			this.bookname = bookname;
			this.price = price;
		}
		public int getId() {
			return id;
		}
		public String getBookname() {
			return bookname;
		}
		public void setBookname(String bookname) {
			this.bookname = bookname;
		}
		public double getPrice() {
			return price;
	  	}
		public void setPrice(double price) {
			this.price = price;
		}
		public void show(){
			System.out.println("编号:"+this.id+" 书名:"+this.bookname+" 价格:"+this.price);
		}
	}
	
	public class BookTools {
		//根据编号搜索图书
		public static void searchBook(Book[] books,int id){
			for(int i=0;i<books.length;i++){
				Book b=books[i];
				if(b.getId()==id){
					b.show();
			}
		}
	}
		public static Book[] searchBook(Book[] books,double price){
			Book[] books2=new Book[books.length];
			int count=0;
			for(int i=0;i<books.length;i++){
				Book b=books[i];
				if(b.getPrice()==price){
	              books2[count]=b;
	              count++;
				}
			}
			return books2;
		}
	}
	
	public class Demo1 {
		public static void main(String[] args) {
			//1创建书籍数组
			Book java=new Book("java从入门到精通", 88.9);
			Book html=new Book("html从0到1", 9.99);
			Book ui=new Book("ui是如何炼成的", 9.99);
			Book[] books={java,html,ui};
			//BookTools.searchBook(books, 3);
			Book[] books2=BookTools.searchBook(books, 9.99);
			for(Book b:books2){
				if(b!=null){
					b.show();
				}
			}
		}
	}
 4.使用Calendar完成一个万年历

​     要求：键盘输入一个年份和月份，控制台输出当月的日历

	import java.util.Calendar;
	import java.util.Scanner;
	public class Task1 {
		public static void main(String[] args) {
			Scanner input=new Scanner(System.in);
			System.out.println("请输入一个年份");
			int year=input.nextInt();
			System.out.println("请输入一个月份");
			int month=input.nextInt();
			System.out.println("日\t一\t二\t三\t四\t五\t六");
			Calendar calendar=Calendar.getInstance();
			calendar.set(year, month-1, 1);//月份要减一
			int maxday=calendar.getActualMaximum(Calendar.DATE);//Date必须全部大写；Calendar.DATE表示一个月的某一天，返回常量5，getActualMaximum是获得给定范围的最大值，所以本语句是获取一个月的最大天数。
			int w=calendar.get(Calendar.DAY_OF_WEEK);//DAY_OF_WEEK表示一周中的某天，返回常量7；整个语句作用是获取星期几
			StringBuilder sb=new StringBuilder();
			for(int i=1;i<w;i++){
				sb.append("\t");
			}
			int count=w-1;
			for(int i=1;i<=maxday;i++){
				sb.append(i+"\t");
				count++;
				if(count==7){
					sb.append("\n");
					count=0;
				}
			}
			System.out.println(sb.toString());	
		}
	}
 5.在控制台输入一句英语， 获得每个字母出现的次数，注：每个字符作为key，出现的次数作为value

	import java.util.HashMap;
	import java.util.Map;
	import java.util.Scanner;
	import javax.naming.InitialContext;
	public class Task2 {
		public static void main(String[] args) {
			HashMap<Character, Integer> hashMap=new HashMap<Character,Integer>();
			Scanner input=new Scanner(System.in);
			System.out.println("请输入一句英语");
			String yingyu=input.nextLine();// I am a student, I love java!
			//1处理空格
			String s1=yingyu.replaceAll(" ", "");
			System.out.println(s1);
			//2处理
			for(int i=0;i<s1.length();i++){
				char c=s1.charAt(i);
				//每个字符出现的次数
				int index=s1.indexOf(c);
				int count=0;
				while(index>-1){
					count++;
					index=s1.indexOf(c, index+1);		
				}
				hashMap.put(c, count);	
			}
			for (Map.Entry<Character, Integer> entry : hashMap.entrySet()) {
				System.out.println(entry.getKey()+"----->"+entry.getValue());
			}		
		}
	}		
6.统计一个含有英文单词的文本文件的单词个数

```
public class Task4 {
	public static void main(String[] args) throws Exception{
		//1读取文件
		FileReader fr=new FileReader("d:\\aaa.txt");
		BufferedReader br=new BufferedReader(fr);
		//2读取
		char[] buf=new char[1024];
		int len=0;
		StringBuilder sb=new StringBuilder();
		while((len=br.read(buf))!=-1){
			sb.append(buf, 0, len);
		}
		//3关闭
		br.close();
		String con = sb.toString();
		String[] infos=con.split("( +)|[,!]");
		for (String string : infos) {
			System.out.println(string);
		}
		System.out.println("单词个数:"+infos.length);
	}
}
```



#### 第五节 包装类和字符串

##### 5.1数据的装箱和拆箱：

1. 基本数据类型储存在栈中，类储存在堆中

  2. 基本数据类型所对应的包装类

     byte-->Byte;  int--->Integer;	char-->Character

2. 拆箱：将包装类型数据转换成基本类型数据

   装箱：将基本类型数据包装成包装类型数据

   ```
   public class Demo1 {
   	public static void main(String[] args) {		
   		byte b=12;
   		Byte b2=new Byte((byte)10);//加（byte）将10强制转化为字节类型
   		Byte b3=6;	
   	
   		int num=20;
   		Integer i = new Integer(num);//使用包装类中的构造方法装箱
   	
   		double b = 3.0;
   		Double d = Double.valueOf(b);//静态valueOf方法装箱
   	
   		Integer num2=new Integer(150);
   		Integer num3=new Integer(150);
   		Integer num4=new Integer(20);
   		System.out.println(num2==num3);
   		//1 当基本类型和包装类型比较时，把包装类型转成基本类型再比较  (拆箱)
   		System.out.println(num==num4); //num==num4.intValue();

   		Integer num5=new Integer(127);
   		Integer num6=new Integer(127);
   		System.out.println(num5==num6); //false，new会创建新地址，故两地址不一样

   		Integer num9=127; //自动装箱
   		Integer num10=127;
   		System.out.println(num9==num10);//true；//Integer中有一个-128到127缓冲区，只要没用到new关键字，在这个范围内相同数值的地址一样
   	
   		Integer num7=128; //装箱 Integer.valueOf(128);
   		Integer num8=128;//
   		System.out.println(num7==num8);//false；128在缓冲区范围之外
   	}
   }
   ```
   ```
   	拆箱：
   	Integer num2=new Integer(250);
   	int num3=num2;// 自动拆箱
       int num3=num2.intValue();//包装类中的xxValue方法拆箱
   ```

   ##### 5.2 基本类型和字符串之间的转换:

   public class Demo3 {
   public static void main(String[] args) {
   	//1基本类型转成字符串
   	int i=10;
   	String s=i+"";//字符串连接符：任何基本类型数据与字符串链接都变成字符串形式
   	boolean b=true;
   	String s2=String.valueOf(b);//String类中的valueOf方法：
   	System.out.println(s2);
   	//2把字符串转成基本类型:
   	String s3="12";
   	String s4="3.14";
   	String s5="false"; 
   	int num=Integer.parseInt(s3);
   	double d=Double.parseDouble(s4);
   	boolean b2=Boolean.parseBoolean(s5);//字符串转布尔类型时,"true"转成true,如果不是，则转成false
   	System.out.println(num);
   	System.out.println(d);
   	System.out.println(b2);
   	
   	//3字符串转成char
   	String s6="hello";
   	char c=s6.charAt(1);
   	System.out.println(c);
   	
   	int num5=Integer.valueOf("20");//可以使用包装类中的valueOf(String str)方法：Character类中没有valueOf(String str)方法	
   }
   }


##### 5.3 字符串:

   	字符串数据是常量，存储在常量池中，常量池中不允许存储相同的数据，字符串可以直接将数据赋值给对象引用.

```java
/String类型,特征：不可变性/
public class Demo4 {
	public static void main(String[] args) {
		String name="张三";  //"张三" 放在串池中
		String name2=name;
		String name3=new String("张三");
		System.out.println(name);//张三
		System.out.println(name2);//张三
		System.out.println(name==name2);//true
		System.out.println(name==name3)；/false

		//修改
		name="李四";
		System.out.println(name);//name指向新地址并创建李四
		System.out.println(name2);//原地址值不变，仍是张三
		}
}	

public class Demo6 {
	public static void main(String[] args) {
		String s1="abc";
		String s2 = new String("abc");//创建一个字符串对象
		
        System.out.println(s2.length());//1 字符串的长度
		
      	String con="wo ai bei jing tian an men,tian an men shang tai yang sheng";
		//2查找子字符串出现的位置
		//2.1查找tian 在con中的位置 第一个出现的位置
		System.out.println(con.indexOf("tian"));
		//2.2从指定位置查找tian 在con中的位置 第一个出现的位置
		System.out.println(con.indexOf("tian", 16));
		//2.3查找tian 在con中的位置 最后一个出现的位置
		System.out.println(con.lastIndexOf("tian"));
		/// info.txt.rar.jpg
		
		//3获取某个位置的字符
		char c=con.charAt(0);
		//4判断某个字符串是否存在
		boolean b=con.contains("tai yang");
		System.out.println(b);
		//5判断字符串中是否有内容
		String e="";
		System.out.println(e.isEmpty());
		//6判断字符串是否是以某个前缀开始的
		String name="张三丰";
		System.out.println("是否是已张开头:"+name.startsWith("王"));
		//7判断字符串是否是以某个后缀开始的
		String file="zhangsan.jpg";
		System.out.println("是否是一jpg结束:"+file.endsWith("jpg"));		
	}
}

/* String 操作*/
public class Demo7 {
	public static void main(String[] args) {
		//1 equals方法比较
		String str="hello";
		System.out.println(str.equals("hello"));
		String str2=new String("hello");
		System.out.println(str==str2);
		System.out.println(str.equals(str2));
		//2 忽略大小比较
		String str3="Hello";
		System.out.println(str3.equalsIgnoreCase(str));
		
		//3字符替换
		String con="我爱北京天安门,天安门上太阳升,太阳啊,太阳啊";
		//替换把太阳换成月亮
		String con1=con.replace("太阳", "月亮");
		System.out.println(con1);
		
		//4截取(含头不含尾)
		String sub=con.substring(0, 4);
		System.out.println(sub);
		String sub2=con.substring(4,7);
		System.out.println(sub2);
		//file=file.txt截取后缀名
		String filename="file.txt";
		String ext=filename.substring(filename.lastIndexOf(".")+1);
		System.out.println(ext);
		
		//5 去除前面和尾部的空格
		String address="    北京市昌平区           沙河老牛湾       ";
		String address2=address.trim();//返回字符串的副本，忽略前导空白和尾部空白
		String address3=address2.replace(" ", "");
		System.out.println(address3);
		//6格式化输出
		System.out.printf("%s","ajfiwef");
		String format=String.format("%.2f-----%b-----%s", 3.14159999f,true,"hello");
		System.out.println(format);
		
		//7比较compareTo; 按字典顺序比较两个字符串。 
		String a="h";
		String b="W";
		int r=a.compareTo(b); // a在前面，b后面,则输出 -1，反之输出1，相等则输出0；
		System.out.println(r);
		
		//8拼接
		String pin1="hello";
		String pin2="你好";
		String pin3=pin1.concat(pin2);
		String pin4=pin1+pin2;//编译后没有了，因为没有用到它，所以编译后直接就没有了
		System.out.println(pin3);		
	}
}
		
public class Demo8 {
	public static void main(String[] args) {
		String str="this is a text";
		//1拆分str，返回数组
		String[] strs=str.split(" ");//按给定的表达式拆分，本句就是遇到空格就拆分
		for(int i=0;i<strs.length;i++){
			//替换
			if(strs[i].equals("text")){
				strs[i]="practice";//将str中的text替换为practice
			}
			
			char c=strs[i].charAt(0); //a  -32 A;获取每个单词的首字母
			String n=strs[i].replaceFirst(String.valueOf(c), String.valueOf((char)(c-32)));//将每个单词的首字母改为大写
			System.out.println(n);
			
			System.out.println(strs[i]);
		}
		
		//2将str中的text替换为practice
		String result=str.replace("text", "practice");
		System.out.println(result);
		
		//3.在text前面插入一个easy
		String result2=str.replace("text", "easy text");
		System.out.println(result2);
		
	}
}
```
##### 5.4内存中的字符串:

	class StringUsageDemo01 {
		public static void main(String[] args) {
			String s1 = "hello";//s1表示引用，存储在栈空间中，但是，“hello”存储在常量池中
			String s2 = "hello";
			System.out.println(s1 == s2);//true//使用一个字符串常量定义两个不同的变量，这时两个变量在内存中是同一块内存空间;原因：两个变量都拷贝了字符串常量的地址
			System.out.println(s1.equals(s2));//true
			
			String s3 = new String("hello");//但凡遇到new关键字，表示开辟了不同的空间
			String s4 = new String("hello");
			System.out.println(s3 == s4);//false;s3和s4分别指向了两个不同的有效空间
			System.out.println(s3.equals(s4));//true
	
			String s1 = "hello";		只有一个对象，是“hello”
			String s3 = new String("hello");	两个对象，一个是“hello”,另外一个就是new出现的对象
	
			//字符串是一个特殊的对象，一旦被初始化之后将不能发生改变
			//注意3：不能发生改变指的是真正的对象【字符串常量对象和new出现的对象】
			String str = "abc";
			等价于char[] arr = {'a','b','c'};
			a.字符串的底层是一个字符数组，默认的修饰符为final
			b.访问权限修饰符是private，私有的，没有提供对外的可以修改数组的方法，所以数组中的元素不能发生改变
		}
	}
##### 5.5 StringBuffer和StringBuilder类：	

```
/StringBuffer;执行效率比String高很多，追加和插入、替换、删除/
public class Demo9 {
	public static void main(String[] args) {
		StringBuffer sb=new StringBuffer();//创建一个空的StringBuffer对象;其初始容量为16个字符 
		
		sb.append("hello world");//1追加
		sb.append("我爱编程");
		System.out.println(sb.toString());
 		
 		sb.insert(0, "我在最前面");//2插入
		System.out.println(sb.toString());
		
		sb.replace(13, 15, "学习");//3替换指定区间的字符串
		System.out.println(sb.toString());	
		sb.setCharAt(0,'x');//替换指定位置上的字符
		System.out.println(sb);
		
		//4其他方法
		System.out.println(sb.length());
		//sb.delete(0, sb.length());//清空
		sb.reverse();//反转
		sb1.delete(2,3);//删除指定区间的字符串
		sb.deleteCharAt(0);//删除指定位置上的字符
		System.out.println(sb.toString());
	}
}
```
​	StringBuilder和StringBuffer的区别

 * 1 功能上一样
 * 2 StringBuffer是线程安全的，StringBuilder是线程不安全的
 * 3 StringBuilder效率高

##### 5.6 正则表达式

> 正则表达式就是一个验证字符串格式是否满足要求的字符串

字符类

| x              | 字符x                         |
| -------------- | --------------------------- |
| [^abc]         | 任何字符，除了 a、b 或 c（否定）         |
| [a-zA-Z]       | a 到 z 或 A 到 Z，两头的字母包括在内（范围） |
| [a-d[m-p]]     | a 到 d 或 m 到 p：[a-dm-p]（并集）  |
| [a-z&&[def]]   | d、e 或 f（交集）                 |
| [a-z&&[ ^bc]]  | a 到 z，除了 b 和 c：[ad-z]（减去）   |
| [a-z&&[ ^m-p]] | a 到 z，而非 m 到 p：[a-lq-z]（减去） |

```
import java.util.regex.Matcher;
import java.util.regex.Pattern;
/*正则表达式；RegEx；Regular Expression */
public class Demo11 {
	public static void main(String[] args) {
	//1手机号 ^1[3578]\d$；//^行开头;$行结尾,可以不写，系统自动提供；[abc]a或b或c
	String phone="15838383838";
	boolean b=phone.matches("^1[3578]\\d{9}$");//‘\\’表示‘\’;\d表示数字[0-9];{9}表示9个数
	System.out.println(b);
	//.	任意字符（与行结束符可能匹配也可能不匹配）;\w单词字符：[a-zA-Z_0-9];X?一次或0次;X* 0次或多次(包括1次);X+ 一次或多次;X{n}恰好n次;X{n, }至少n次
	
	//2判断qq邮箱  [1-9]\d{5,10}@[qQ]{2}\.com//X{n,m}至少n次，不超过m次,
	String qq="1312412@qQQ.com";
	boolean b2=qq.matches("[1-9]\\d{5,10}@[qQ]{2}\\.com");
	System.out.println(b2);
	//3拆分
	//String con="我      爱    编          程 ";
	String con2="我.爱.编 .程 ";
	//String[] strs=con.split(" +");
	String[] strs=con2.split("\\.");
	System.out.println(strs.length);
	for (String string : strs) {
		System.out.println(string);
	}
	
	//Pattern类
	//1创建Patter对象
	Pattern p=Pattern.compile("1[3578]\\d{9}");
	//2创建匹配器
	Matcher matcher=p.matcher("178412424222");
	//p.matcher("18924123213");
	//3匹配
	boolean r=matcher.matches();
	System.out.println(r);
	//一步到位
	boolean r2=Pattern.matches("1[3578]\\d{9}", "17841242422");
	System.out.println(r2);
}
}
```

#### 第六节 面试题,选择题，填空题

1.switch是否能作用在byte上，是否能作用在long上，是否能作用在String上?

```
可以是byte 也可以是String，不能是long
```

2.switch中default的位置是否必须出现在最后？
```
不是，可以放在任意位置，但是无论放在什么位置，一定会是执行完case后最后执行的
```

3.1.56e2表示什么？

	1.56*10^2
4.最有效率算出2乘以8的方式是什么？

```
2<<3（当计算m*n时，只要n是2的整数次方倍，可以考虑一下位移运算符，其效率要高）
```

5.String s2 = new String("abc");创建出了几个字符串对象;是否可以继承String类？b3,b4的值分别是多少？

	String s1 = "abc";
	String s2 = new String("abc");
	String s3 = "a";
	String s4 = "bc";
	String s5 = s3 + s4;
	boolean b1 = s1==s2;
	boolean b2 = s1.equals(s2);
	boolean b3 = s1==s5;
	boolean b4 = s1.equals(s5);
	（1）在本题中创建了一个对象。当String s2 = new String("abc")单独出现时，两个或一个都有可能，”abc”对应一个对象，这个对象放在字符串常量缓冲区（在方法区内），常量”abc”不管出现多少遍，都是缓冲区中的那一个。New String每使用一遍，就会在堆里建一个新的value字符串对象，然后该value对象会继续指向字符串常量缓冲区所对应的对象内容‘abc’；所以当‘abc’已经在字符串常量缓冲区存在时String s2 = new String("abc")就会只创建value一个对象，若以前没有用过"abc"，那么此时就会创建一个对象‘abc’并放入字符串常量缓冲区，这种情况它创建两个对象。
	（2）至于String类是否继承，答案是否定的，因为String默认final修饰，是不可继承的。
	（3）b1,b2,b3,b4的值分别是多少？b3=false  b4=true 
6.什么时候用for循环，什么时候用while循环

​	循环次数确定的情况优先选用for循环，循环次数不确定的情况，通常选用while循环。

7.设int 型变量 a、b，float 型变量 x、y，char 型变量 ch 均已正确定义并赋值，正确的switch语句是( B )

A、switch (x + y)  { ...... }       B、switch ( ch +1 )  { ...... }

C、switch  ch  {...... }           D、switch ( a + b);  { ...... }

```
A.float型不能作为switch的判断语句
C.漏了括号
D.多了分号
```

8.判断以下程序执行结果以及被标识语句的执行顺序。

```
public class lianxi2 {
	public static void main(String[] args) {  
		int a=test();
        System.out.println("结果： " + a);  
    }     
	@SuppressWarnings("finally")
	public static int test(){  
        int i = 1;  
        try {  
            System.out.println("try里面的i : " + i);  //a;
            return i; //b; 
        }finally{// 会在try方法return返回调用前执行。准确的说是在return中间执行。
            System.out.println("进入finally..."); //c; 
            ++i;  
            System.out.println("fianlly里面的i : " + i); //d; 
            return i; //e; 
        } 
    }  
}
执行结果：try里面的i : 1
		 进入finally...
	     fianlly里面的i : 2
	     结果： 2
执行顺序：a-->c-->d-->b-->e
注：（1）Finally{}只有在两种情况下不会执行 ：1.System.exit(); 退出jvm   2. 系统异常退出	
```

9.String 和StringBuilder、StringBuffer 的区别?有没有哪种情况用+做字符串连接比调用StringBuffer / StringBuilder对象的append方法性能更好？

```
(1)Java 平台提供了两种类型的字符串：String和StringBuffer / StringBuilder，它们可以储存和操作字符串。其中String是只读字符串，即String引用的字符串内容是不能被改变的。而StringBuffer和StringBuilder类表示的字符串对象可以直接进行修改。StringBuilder是JDK 1.5中引入的，它和StringBuffer的方法完全相同，区别在于它是在单线程环境下使用的，因为它的所有方面都没有被synchronized修饰，因此它的效率也比StringBuffer略高。   （2）如果连接后得到的字符串在静态存储区中是早已存在的，那么用+做字符串连接是优于StringBuffer / StringBuilder的append方法的。
```

10.byte Max是127,那byte Max+1会是多少?

```
结果是-128；byte取值范围是-128~127，当127换成二进制加1后满2进1，0111 1111（127）变成1000 0000（128）
```



#### 第七节 封装继承多态抽象接口

##### 7.1 抽象、封装

（1）封装：在类中，对于不想被类外直接访问的成员变量，进行私有化，同时对外提供一个共有的方法为了访问私有的成员。

（2）抽象：有些类创建对象没有意义，需要把这个定义为抽象类。抽象类（abstract）不能实例化（即不能创建对象），只能被继承。

	//abstract 抽象
	public abstract class Animal {//abstract可以修饰类：叫做抽象类，抽象方法所在的类必须是抽象类；但是抽象类中可以没有抽象方法
		private int id;//封装：通过private关键字对id进行私有化封装
		private String name;
		private int health;
		private int love;
		public Animal(){// 抽象类中有构造方法，但是不能创建对象，构造方法目的是在子类中会被调用
		}
		public int getId() {//封装：私有化变量后要对外提供共有方法获取成员值
			return id;
		}
		public void setId(int id) {//封装：私有化变量后要对外提供共有方法设置成员值
			this.id = id;
		}
		public String getName() {
			return name;
		}
		public void setName(String name) {
			this.name = name;
		}
		public int getHealth() {
			return health;
		}
		public void setHealth(int health) {
			this.health = health;
		}
		public int getLove() {
			return love;
		}
		public void setLove(int love) {
			this.love = love;
		}
		public abstract void print();//abstract修饰的方法叫做抽象方法，没有方法体，需要用分号表示声明结束
		}
		
		public  class Dog extends Animal{//extends表示继承
		private String strain;
		public String getStrain() {
			return strain;
		}
		public void setStrain(String strain) {
			this.strain = strain;
		}
		public void print() {//重写父类函数，抽象类的存在就是为了被继承，子类必须重写父类的抽象方法，除非子类也是抽象类。
			System.out.println("id:"+this.getId()+" name:"+this.getName()+" health:"+getHealth()+" love:"+this.getLove()+" strain:"+this.strain);
		}	
	}
	
	public class TestAnimal {
		public static void main(String[] args) {
			Dog afu=new Dog();
			afu.setId(120);
			afu.setName("阿福");
			afu.setHealth(90);
			afu.setLove(100);
			afu.setStrain("金毛");
			afu.print();
		}
	}

##### 7.2 static，final，abstract

（1）final和abstract是否可以连用？

​	1）两个关键字修饰方法时，final修饰的方法特点：可以被继承不能被重写；abstract修饰的方法特点：必须被重写；所以这两个关键字不能同时修饰同一个方法

​	2）两个关键字修饰类时：final修饰的类特点：不能被继承；abstract修饰的类特点：必须被继承；所以这两个关键字不能同时修饰同一个类

​	综上所述：final和abstract不可以连用

​	final的类中能否有abstract方法？不能
​	abstract类中能否有final方法？可以

（2）static：可以创建静态代码块，程序一加载静态代码块就运行，而且只运行一次

（3）  构造方法和static方法、final方法不能是抽象的

##### 7.3 接口

（1）接口的概念：

​	从语法上讲：接口是一种特殊的抽象类，这种抽象类中只包含常量和方法的定义，而没有方法的实现。(特殊的：在接口中使用static关键字修饰的方法有方法体，即静态方法需要有方法体；在接口中使用default关键字修饰的方法有方法体）

​	从功能上讲：接口表示一种约定或能力

（2）接口的特点：

​	1）接口不能创建对象，而且接口中没有构造方法；
​	2）接口中的方法一般都是共有抽象方法：public abstract
​	3）接口中所有的属性都是共有静态常量属性：pulbic static final

​	在一个接口中声明方法时，若没有声明访问权限，默认也是public，若没其他修饰默认也是abstract；声明属性时，若没有声明访问权限和静态常量，默认也是public static final

   (3)接口和接口的关系：	

> 继承关系：使用关键字extends实现接口与接口的继承关系

> 接口继承的特点：
> 1）接口中没有私有成员，所以父类接口中的所有成员都会被子接口继承
> 2）父子关系中都是接口，所以在子接口中不需要实现任何的抽象方法
> 3）接口可以多继承
>
> 思考：
> 现有类A和类B，两个类中都有fun()方法，类C继承类A和类B，当使用类C的对象调用fun方法时，如何执行？此时不知道执行那个fun方法，所以类不可以多继承。
>
> 现有接口A,B,两个接口中都有fun方法，接口C继承A,B，由于接口中的没有方法体，所在只要在接口C中存在了fun方法即可
>
> 所以接口支持多继承

	public interface USB {//接口的声明语法，接口interface和类class是平级关系
		void service();//也可以使用以下格式声明方法public abstract void service();
		int a = 9;//也可以使用以下格式声明属性public static final int a = 9;
	}
	
	public class Upan implements USB{//接口的实现类:implements
		public void service() {
			System.out.println("和电脑连接成功,u盘开始工作....");
		}
	}
	
	public class Mouse implements USB{
		public void service() {
			System.out.println("和电脑连接成功,鼠标开始工作.....");
		}
	}
	
	public class Fan implements USB{
		public void service() {
			System.out.println("和电脑连接成功，风扇开始工作.....");
		}
	}
	
	public class Computer {
		USB usb1;//电脑拥有三个usb接口
		USB usb2;
		USB usb3;
		public void work(){//电脑工作方法
			if(usb1!=null){
				usb1.service();
			}
			if(usb2!=null){
				usb2.service();
			}
			if(usb3!=null){
				usb3.service();
			}
		}
	}
	
	public class Test {
		public static void main(String[] args) {
			Computer lenovo=new Computer();//1创建电脑
			Mouse luoji=new Mouse();//2鼠标
			Upan jinshidun=new Upan();//3优盘
			Fan meidi=new Fan();//4风扇
			
			lenovo.usb1=luoji;
			lenovo.usb2=meidi;
			lenovo.usb3=jinshidun;
			
			lenovo.work();
		}
	}
	
	public class Dog extends Animal implements I{若一个类有父类同时也实现接口，声明类时，必须先继承再实现接口
		public void fun(){}
	}
##### 7.4 多态

（1）多态：同一个引用类型，使用不同的实例而执行不同操作 ，一句话理解：父类引用，子类对象。

（2）案例引入：

​          a.编写一个宠物类 Pet 属性：id,name,health,love ;方法有print(),打印信息，要封装成员变量

​	 b. 两个子类狗狗和猫类，狗狗有品种(strain),猫类有爱好(hobby),重写父类print()方法

​	 c.宠物饿了，需要主人给宠物喂食，狗狗吃狗粮、猫咪吃小鱼，吃完之后健康值狗狗增加3，猫咪增加5。

```java
/*宠物类*/
public class Pet{
	private int id; //id 宠物编号
	private String name;// 宠物昵称
	private int health;// 健康值
	private int love;// 亲密度

	public void setId(int id){
		this.id=id;
	}
	public int getId(){
		return id;
	}
	public void setName(String name){
		this.name=name;
	}
	public String getName(){
		return name;
	}
	public void setHealth(int health){
		this.health=health;
	}
	public int getHealth(){
		return health;
	}
	public void setLove(int love){
		this.love=love;
	}	
	public int getLove(){
		return love;
	}
	public void print(){
		System.out.println("宠物id:"+this.id+",宠物昵称:"+this.name+",健康值:"+health+",亲密度:"+love);
	}


/*dog类继承Pet类*/
public class Dog extends Pet{
	private String strain;
	public void setStrain(String strain){
		this.strain=strain;
	}
	public String getStrain(){
		return strain;
	}

	public void print(){
		int id=getId();
		String name=getName();
		int health=getHealth();
		int love=getLove();
		System.out.println("狗狗id:"+id+" 昵称:"+name+" 健康值:"+health+" 亲密度:"+love+" 品种:"+strain);
	}
	public void eat(){
		String name=getName();
		System.out.println(name+"大口吃狗粮....");
		int health=getHealth();//增加健康值
		setHealth(health+3);
	}
}

/*猫类*/
public class Cat extends Pet{
	private String hobby;
	public void setHobby(String hobby){
		this.hobby=hobby;
	}
	public String getHobby(){
		return hobby;
	}
	public void print(){
		int id=getId();
		String name=getName();
		int health=getHealth();
		int love=getLove();
		System.out.println("猫咪id:"+id+" 昵称:"+name+" 健康值:"+health+" 亲密度:"+love+" 爱好:"+hobby);
	}
	public void eat(){
		String name=getName();
		System.out.println(name+"大口吃小鱼....");
		//增加健康值
		int health=getHealth();
		setHealth(health+5);
	}
}

/*主人*/
public class Master{
	private String name;	
	public void setName(String name){
		this.name=name;
	}
	public String getName(){
		return name;
	}
	//喂食
	/*public void feed(Dog d){
		System.out.println(name+"要给狗狗喂食物...");
		d.eat();
		d.print();
	}
	public void feed(Cat c){
		System.out.println(name+"要给猫咪喂食物...");
		c.eat();
		c.print();
	}*/
  	public void feed(Pet p){
		String n=p.getName();
		System.out.println(name+"要给"+n+"喂食物...");
		p.eat();//调用子类重写的方法
		p.print();//调用子类重写的方法
	}
  	public Pet adopt(int type){
		if(type==1){
          	Pet d=new Dog();//向上转型：将子类的对象赋值给父类变量，自动转换
	/*d是引用型变量，Dog是对象；当成员函数和变量都是非静态时：（1）成员函数在多态中被调用时：编译是否成功看左边引用型变量所属类中是否有调用的方法，有则编译通过，无则编译失败；运行是否成功看右边对象所属类中是否有调用的方法，有则运行通过，无则运行失败，故此时d.setHealth(80)实则是执行调用的右边的函数,但若右边子类没有重写的函数时，执行结果就只能看父类了。（2）成员变量在多态中被调用时，无论编译还是运行都看左边。*/
    /*当成员函数或者变量是静态时，编译运行都看左边*/
    	    /*Pet c=new Cat();//1式；向上转型：将子类的对象赋值给父类变量，自动转换；
    	      c.eat();
    	      cat a=(cat)c;//向下转型：将父类的变量赋值给子类变量，强制转换
    	      a.catchMouse();*/
    /*要注意的是：cat a=(cat)c中的c是父类指向了自己的子类对象，故可以向下转型，再看一个错误的程序：*/
    	     /* Pet c=new Pet();//2式
          		cat a=(cat)c;
    这段程序错误的原因是不能将父类对象向下转，要注意1式和2式的区别
          	*/
          	d.setHealth(80);
			d.setLove(50);
			return 	d;
		}else if(type==2){
			Pet c=new Cat();
			c.setHealth(80);
			c.setLove(50);
			return 	c;
		}else{
			return null;
		}
	}

}

public class TestPet{
	public static void main(String[] args){
		Dog afu=new Dog();
		afu.setId(120);
		afu.setName("阿福");
		afu.setHealth(85);
		afu.setLove(90);
		afu.setStrain("拉布拉多");
		afu.print();

		Cat amao=new Cat();
		amao.setId(119);
		amao.setName("阿猫");
		amao.setHealth(90);
		amao.setLove(70);
		amao.setHobby("爬树");
		amao.print();

		Master yuhuan=new Master();
		yuhuan.setName("玉环");
		yuhuan.feed(afu);
		yuhuan.feed(amao);
	}
}
  
 /* 领养宠物*/
import java.util.Scanner;
public class TestPet2{
	public static void main(String[] args){
		System.out.println("欢迎来到xxx宠物商店.....");
		System.out.println("请选择您要领养的宠物类型 1 狗狗  2 猫咪");
		Scanner input=new Scanner(System.in);
		int choice=input.nextInt();
		
		Master yuhuan=new Master();
		Pet p=yuhuan.adopt(choice);
		if(p!=null){
			System.out.println("领养成功");
			p.print();
		}else{
			System.out.println("领养失败");
		}
		
	}
} 
```

##### 7.5 instanceof

> 对象向下转型时，存在一个问题：
>
> ​	若一个父类A的引用a，指向一个子类B的实例，将a赋值给另一个子类C引用时，会抛出java.lang.ClassCastException异常；
>
> ​	抛出异常后程序将不能继续向下执行，为了避免这个异常的抛出，我们可以通过instanceof关键字判断引用指向的实例是否可以进行强制转换成某个子类对象

> 已知Animal类有两个子类Dog和Cat：

      public class Demo{
      	public static void main(String[]args){
      		Animal a = new Dog();
      		check(a);
      	}
      	public static void check(Animal a){//设计一个方法，判断一个动物是猫还是狗
      			if(a instanceof Dog){
        			System.out.println("狗");
      			}else if(a instanceof Cat){
        			System.out.println("猫");
      			}
      	}
    }
#### 第八节 集合

	Collection
	|_____List （特点：有序的，可以重复）
		   |___ ArrayList （存储结构:数组）
	        |___LinkedList  （链表）
	        |___Vector      数组 
	        |___Stack       数组（栈）
	|
	|_____Set（特点:无序的，不能重复）
	       |_____HashSet  哈希表(数组加链表)  1 执行hashCode()来计算存储的位置 ，2 执行equals比较结果
	       |____LinkedHashSet 哈希表 可以保证顺序 
	       |_____TreeSet  自平衡红黑二叉树 	1 元素要实现Comparable接口 ，2 定制比较器 Comparator
	
	Map(特点：存储键值对，键不能重复，值可以重复，无序)  
	  |__ HashMap  哈希表 1 执行hashCode()来计算存储的位置 ，2 执行equals比较结果
	
	  |__ Hashtable 哈希表  不能存储null键和null值，线程安全的  jdk1.0
	
	  |___LinkedHashMap  哈希表  可以保证顺序
	
	  |___TreeMap  自平衡红黑二叉树  1 key 要实现Comparable接口 ，2 定制比较器 Comparator

##### 8.1 集合与数组的对比

​	集合与数组一样，也是一个容器，可以存储多个数据，与数组不同的是，数组中的元素只能是相同，集合中的元素是任意的（泛型），  数组中可以存储基本类型和引用类型，集合只能存储引用类型；数组是定长的，一旦初始化长度就不可以修改，集合长度可以修改，可以删除元素和添加元素。

##### 8.2 Collection接口与迭代器

```
import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;
import java.util.concurrent.ConcurrentHashMap;
/*- Collection接口的使用*/
public class Demo1 {
  	public static void main(String[] args) {	
		Collection collection=new ArrayList();//1创建Collection对象
		//2操作
        collection.add("张三");//2.1添加
        collection.add("李四");
        collection.add("他二大爷");
        collection.add("他老爷");
        collection.add("七大妈");
        collection.add("张三");
        System.out.println("集合的元素个数:"+collection.size());
        //	collection.remove("张三"); //2.2.1删除，删除一个
		//	System.out.println("删除之后的数据个数:"+collection.size());
		//	collection.clear();//2.2.2清空		
		//	System.out.println("清空之后:"+collection.size());
		//3遍历
        System.out.println("--------使用增强for遍历----------");//3.1 使用增强for
        for(Object obj:collection){
            System.out.println(obj);
        }
        System.out.println("-------使用迭代器---------"); //3.2使用迭代器
        Iterator it=collection.iterator();
        while(it.hasNext()){
            Object obj=it.next();
            System.out.println(obj);
        }
        //4判断       
        boolean b=collection.contains("王五"); //4.1判断是否存在
        System.out.println(b);
        //4.2判断是否为空
        System.out.println(collection.isEmpty());
        //5查找
	}
}   
```
##### 8.3  泛型

```
/*定义泛型类：泛型好处是可以提高的程序安全性
- T (Type) ：是一个占位符,表示一种数据类型，也可以用E(Element) ，也可以用任意字母
泛型就是可以表示一个广泛数据类型的类型参数（泛型只能表示引用类型）,把数据类型作为参数来传递。
*/
    public class Person<T> {
    	private String name;
    	private int age;
   	 	private T t;//声明未知数据类型，该数据的具体类型取决于实例化时传入的实际类型
/*final修饰的属性必须在声明的同时初始化，所以泛型不能声明常量
static修饰的属性是静态属性，先于对象，泛型类型取决于创建对象时传入的实际类型，所以泛型不能声明静态属性
综上所述：不能使用泛型声明静态属性、常量*/
    	private T[] arr;//泛型不能在类中初始化数组，但是可以声明数组:初始化数组时需要给元素进行分配空间,但是泛型类型不确定无法分配空间
    	public String getName() {
    		return name;
    	}
    	public void setName(String name) {
    		this.name = name;
    	}
   		public int getAge() {
    		return age;
    	}
    	public void setAge(int age) {
    		this.age = age;
    	}
  		public T getT() {
			return t;
		}
		public void setT(T t) {//声明方法时，在方法的参数列表中声明未知数据类型
			this.t = t;	
        }
		public <T> void show(T t){//在类中不能使用泛型声明参数个数相同的重载方法:当一个类中有两个泛型时，创建对象时，两个泛型使用相同类型替换，那么重载方法就是相同的方法（同名，参数列表也相同）
			System.out.println(t);//使用不同实际类型创建出的泛型类对象的引用不可以相互赋值
		}
    }
    
    public class TestPerson {
		public static void main(String[] args) {
			Person<String> p1=new Person<String>();
			p1.setT("hello");
			System.out.println(p1.getT());
			p1.show("hello world");
			p1.show(20);
			p1.show(3.5);
			p1.show('a');
		
			Person<Integer> p2=new Person<Integer>();
			p2.setT(20);
			System.out.println(p2.getT());
 		}
	}
	
	/*受限泛型*/
	1）<?>：表示任意类型
	2）<? extends T>：表示T类或者T类的子类
	3）<? super T>：表示T类或者T类的父类
	public static void show(School<?> shool){ //? 表示任何类型
		System.out.println(shool.toString());
	}
	public static void show2(School<? extends Animal> shool){ //? 表示Animal或Animal的子类  泛型上限
		System.out.println(shool.toString());
	}
	
	public static void show3(School<? super Dog> shool){ //? 表示Dog或Dog的父类  泛型下限
		System.out.println(shool.toString());
	}
```
##### 8.4 List接口

1.List相对有序存储，可以存储相同元素（不排重），可以通过下标访问集合元素，List接口中可以使用独有的迭代器ListIterator，具有反向遍历的功能

```
 import java.util.ArrayList;
 import java.util.Iterator;
 import java.util.List;
 import java.util.ListIterator;
 import java.util.concurrent.SynchronousQueue;
 import org.omg.CosNaming.IstringHelper;
 /*
 - List集合
 - 特点：有序的，可以重复的
  */
  public class Demo1 {
  	public static void main(String[] args) {
		List<String> list=new ArrayList<String>();//1创建List集合对象
		list.add("苹果");//2添加
		list.add("菠萝");
		list.add("香蕉");
		list.add("榴莲");
		list.add("小米");
		System.out.println("元素个数:"+list.size());
		System.out.println(list);

		//list.remove(0);//3删除：List可以通过下标访问集合元素
		//list.remove("小米");//依据equals();
		//System.out.println("删除之后:"+list);
		//list.clear();
		
		//4遍历
		//4.1 foreach
		System.out.println("------------增强for-------------");
		for (String string : list) {
			System.out.println(string);
		}
		//4.2 迭代器(只能向前迭代)
		System.out.println("------------迭代器-------------");
		Iterator<String> it=list.iterator();
		while(it.hasNext()){
			String s=it.next();
			System.out.println(s);
		}
		//4.3使用for
		System.out.println("------------for-------------");
		for(int i=0;i<list.size();i++){
			System.out.println(list.get(i));
		}
		//4.4使用listIterator
		System.out.println("------------listIterator 顺序输出------------");
		ListIterator<String> lit=list.listIterator(3);
		while(lit.hasNext()){
			String s=lit.next();
			System.out.println(s);
		}
		System.out.println("------------listIterator 逆序输出------------");
		while(lit.hasPrevious()){
			String s=lit.previous();
			System.out.println(s);
		}
		//5判断
		//5.1判断是否存在
		System.out.println(list.contains("小米"));
		//5.2判断是否为空
		System.out.println(list.isEmpty());
		//6查找（查找位置）
		int index=list.indexOf("香蕉");
		System.out.println(index);

		//7其他方法
		//截取集合subList(int fromIndex, int toIndex) 
		List<String> newlist=list.subList(2, 4);
		System.out.println(newlist);
	}
}	

/*ArrayList类*/
//ArrayList类是List接口的大小可变数组的实现。实现了所有可选列表操作，并允许包括null在内的所有元素。
//ArrayList集合适用在对元素查询操作较频繁的时候
import java.util.ArrayList;
public class Demo3 {
	public static void main(String[] args) {
		//1ArrayList对象
		ArrayList<Integer> arrayList=new ArrayList<Integer>();
		arrayList.add(1);
		arrayList.add(2);
		arrayList.add(3);
		arrayList.add(4);
		arrayList.add(5);
		//2删除
		System.out.println("删除之前："+arrayList);
		//arrayList.remove(0);//索引
		arrayList.remove(new Integer(5));
		System.out.println("删除之后："+arrayList);
	}
}

/*LinkedList*/
//LinkedList类是List接口的链接列表实现。实现所有可选的列表操作，并且允许所有元素（包括null）。
//LinkedList集合适用在对元素插入和删除操作较频繁的时候
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.ListIterator;
public class Demo4 {
	public static void main(String[] args) {		
		LinkedList<String> linkedList=new LinkedList<>();//1创建对象	
		linkedList.add("菠菜");//2添加
		linkedList.add("黄瓜");
		linkedList.add("西红柿");
		linkedList.add("茄子");
		linkedList.add("萝卜");
		linkedList.addFirst("韭菜");
		System.out.println("元素个数:"+linkedList.size());
		System.out.println(linkedList);
		//3删除
		linkedList.remove(0);
		System.out.println(linkedList);
		//4遍历
		//4.1迭代器
		System.out.println("---------迭代器-------");
		Iterator<String> it=linkedList.iterator();
		while(it.hasNext()){
			System.out.println(it.next());
		}
		System.out.println("------listIterator迭代器------");
		ListIterator<String> lit=linkedList.listIterator();
		while(lit.hasNext()){
			System.out.println(lit.next());
		}
		//5判断
		System.out.println(linkedList.contains("黄瓜"));
		//6查找位置
		System.out.println(linkedList.indexOf("萝卜"));	
	}
}

/*Vector*/
//Vector类可以实现可增长的对象数组。与数组一样，它包含可以使用整数索引进行访问的组件。但是Vector
的大小可以根据需要增大或缩小，以适应创建 Vector后进行添加或移除项的操作。
/**和ArrayList区别：
 * 1 Vector是线程安全的，ArrayList线程不安全
 * 2 ArrayList效率高于Vector
 * 3 Vector从jdk1.0, ArrayList jdk1.2
 */
import java.util.Enumeration;
import java.util.Vector;
public class Demo1 {
	public static void main(String[] args) {	
		Vector<String> vector=new Vector<>();//1创建集合
		vector.addElement("可乐");//2添加元素
		vector.addElement("雪碧");
		vector.addElement("红茶");
		vector.addElement("果汁");
		System.out.println("数据元素个数:"+vector.size());
		System.out.println(vector);		
		vector.remove(0);//3删除
		System.out.println("删除之后:"+vector);
		//4遍历
		//4.1foreach
		System.out.println("---------增强for-----------");
		for (String string : vector) {
			System.out.println(string);
		}
		System.out.println("---------for-----------");
		for (int i=0;i<vector.size();i++) {
			System.out.println(vector.get(i));
		}
		//4.3使用枚举器
		System.out.println("---------枚举器-----------");
		Enumeration<String> en=vector.elements();
		while(en.hasMoreElements()){
			System.out.println(en.nextElement());
		}	
	}
}

/*Stack*/
import java.util.Stack;
public class Demo2 {
	public static void main(String[] args) {
		//1创建对象
		Stack<String> stack=new Stack<String>();
		//2入栈
		stack.push("啤酒");
		stack.push("花生米");
		stack.push("羊肉串");
		stack.push("金针菇");
		stack.push("猪腰子");
		//3出栈
		System.out.println("出栈之前："+stack.size());
		for(int i=0;i<5;i++){
			System.out.println(stack.pop());
		}
		System.out.println("出栈之后:"+stack.size());
	}
}
```

##### 8.5 ArrayList与LinkedList，Vector三种实现类存储的比较

​	a.在用法上和ArrayList完全相同【Vector就是ArrayList的前身】
​	b.底层存储结构：ArrayList是数组，LinkedList是链表，Vector是数组
​	c.Vector是一个古老的集合，从JDK1.0开始就有了，Vector存在一些方法名比较长的方法，xxxxElement
​	d.Vector是线程安全的，效率低，ArrayLIst是线程不安全的，效率高，推荐使用ArrayList【Collections工具类中有相应的方法可以将ArrayList改为线程安全的】
​	e.ArrayList查找遍历比较快，LinkedList插入删除比较快

#### 第九节 Set接口和Map接口

##### 9.1 Set接口

```
import java.util.HashSet;
import java.util.Iterator;
import java.util.Set;
/*- Set
- 特点:
- 不能包含重复元素；无序的；不能通过下标访问
  无序的：可以理解为元素存入和输出的顺序不一定一致
*/

/*set集合的使用*/ 
public class Demo1 {
	public static void main(String[] args) {
		Set<String> set=new HashSet<String>();//1创建集合对象	
        set.add("hello");//2添加
        set.add("world");
        set.add("nihao");
        set.add("hi");
        set.add("apple");
        set.add("hello");
        set.add("baomawxs");
        System.out.println("元素个数:"+set.size());//显示6个，重复元素会算做一个元素
		System.out.println(set);
		//3删除
		//set.remove("nihao");
		System.out.println("删除之后:"+set);
		//set.clear();
		//4遍历
		//4.1使用foreach
		System.out.println(".............使用增强for.............");
		for (String string : set) {
			System.out.println(string);
		}
		//4.2使用迭代器：迭代器可以用来输出集合元素
		System.out.println(".............使用迭代器.............");
		Iterator<String> it = set.iterator();//ctrl+1
		while(it.hasNext()){
			String string = it.next();
			System.out.println(string);
		}
		//5判断
		System.out.println(set.contains("apple"));
		System.out.println(set.isEmpty());
	}
}

/* HashSet
 * 存储结构: 哈希表（数组加链表）
 * 此类实现Set接口，由哈希表（实际上是一个HashMap实例）支持。它不保证set的迭代顺序；特别是它不保证该顺序恒久不变。此类允许使用null元素。
 */
 /*hashSet集合排除重复元素的原理*/
1.添加set成员后，set底层会首先自动调用hashCode函数判断哈希值是否一致，若不一致则认为不重复，若一致会进一步调用equals函数
2.若equals函数对比内容一致，则认为是相同元素，直接排除。（注：若hashCod判断元素哈希值不一样后，就不会再调用equals函数）
3.我们可以通过重写hashiCode和equals函数改变排重标准
	public boolean equals(Object obj) {//重写equals函数	
		if(obj instanceof Student) {//先判断传入的参数对象是否是Student对象，若不是直接返回false    
			Student s = (Student) obj;//若是，强转成Student对象，并比较属性的值
			if(this.name.equals(s.name)) { //若属性的值相同，则返回true   	
				return true;
			}
		}
		return false;
	}
  
    public int hashCode(){//重写hashiCode函数
      	/*hashCode方法返回值是int类型，所以重写时需要找到int类型的数据返回，还要保证此方法的返回值与对象的所有属性都相关,所以返回姓名属性的字符串的长度（也可以返回字符串哈希值：不同字符串对应哈希值不同）*/
		return this.name.length();
    }
 
/*hashSet的使用*/ 
import java.util.HashSet;
import java.util.Iterator;
public class Demo1 {
	public static void main(String[] args) {
		HashSet<String> hashSet=new HashSet<String>();//1创建集合对象
		//2添加
		hashSet.add("中国");
		hashSet.add("韩国");
		hashSet.add("泰国");
		hashSet.add("朝鲜");
		hashSet.add("俄罗斯");
		hashSet.add("俄罗斯");
		
		System.out.println（hashSet.add("俄罗斯")）；//打印boolean类型true
		System.out.println（hashSet.add("俄罗斯")）；//打印boolean类型false，表示重复不被存储
		System.out.println("元素个数:"+hashSet.size());//显示5，两个俄罗斯会被认为重复，只算一个
		System.out.println(hashSet);//[泰国, 朝鲜, 韩国, 俄罗斯, 中国]：按哈希表规定顺序输出
		//3删除
		hashSet.remove("朝鲜");
		System.out.println("删除之后:"+hashSet);
		//4遍历
		System.out.println("-----------使用迭代器------------");
		Iterator<String> iterator = hashSet.iterator();
		while(iterator.hasNext()){
			System.out.println(iterator.next());
		}
		//5判断
		System.out.println(hashSet.contains("俄罗斯"));	
	}
}

/*
 * LinkedHashSet
 * 存储结构哈希表 
 * 保证存储和读取的顺序一致
 * 在原有的哈希表的基础上有多一个链表，链表保存者存储的顺序
 */
package com.qf.day16_3;
import java.util.LinkedHashSet;
public class Demo2 {
	public static void main(String[] args) {
		//创建对象
		LinkedHashSet<String> linkedHashSet=new LinkedHashSet<String>();
		//1添加数据
		linkedHashSet.add("中国");
		linkedHashSet.add("韩国");
		linkedHashSet.add("泰国");
		linkedHashSet.add("朝鲜");
		linkedHashSet.add("俄罗斯");	
		System.out.println(linkedHashSet);//[中国, 韩国, 泰国, 朝鲜, 俄罗斯]		
	}
}

/* 使用TreeSet存储数据
 * 存储结构：自平衡红黑二叉树
 * 无序，存储后把数据排序。
 * 数字按照从小到大
 *TreeSet集合是可以给元素进行重新排序的一个Set接口的实现。使用元素的自然顺序对元素进行排序，或者根据创建 set 时提供的Comparator进行排序，具体取决于使用的构造方法。*/
/*一些简单的元素treeSet可以实现自动排序，当遇到复杂的元素时，可以通过一下两种方式进行排序：1.元素的自然顺序（默认顺序）：让元素自身具备比较性，元素需要实现Comparable接口，覆盖compareTo方法；2.当元素自身不具备比较性或者具备的比较性不是所需要的，这时就需要让集合自身具备比较性，在集合初始化的时候就让他有比较性，可以通过定义比较器实现比较器接口，将比较器对象作为参数传递给TreeSet集合的构造函数实现*/

/*第一种方式*/
/*另建类*/
public class Animal implements Comparable<Animal>{//TreeSet需要自动排序，所以当程序不能识别排序方法时，需要让对象具备比较性，方法就是对象所在类实现比较器接口，通过实现Comparable实现排序的方式均属于自然顺序排序
	private String nickname;
	private int age;
	public String getNickname() {
		return nickname;
	}
	public void setNickname(String nickname) {
		this.nickname = nickname;
	}
	public int getAge() {
		return age;
	}
	public void setAge(int age) {
		this.age = age;
	}
	public Animal() {
	}
	public Animal(String nickname, int age) {
		this.nickname = nickname;
		this.age = age;
	}
	public String toString() {//手动重写toString；如果不重写，主函数打印的会是地址；当打印的是字符串时，系统才会自动重写toString
		return "Animal [nickname=" + nickname + ", age=" + age + "]";
	}
	public int compareTo(Animal o) {//重写compareTo函数
		int num1= this.age-o.age;//二叉树存储，返回值num1时，num1大于0，this.age就往右存，否则往左存；打印往外取的时候先取左边的；this.元素表示当前加入的元素，在此元素加入的时候会自动调取已有元素作为o.元素传过来进行比较。
		int num2=this.nickname.compareTo(o.nickname);//compareTo方法对两个字符串对比是根据字典存储顺序。
		return num1==0?num2:num1;//若将此句改为return 1；就会实现怎么存就怎么打印的功能
	}	
}
/*主函数所在类*/
import java.util.TreeSet;
public class Demo3 {
	public static void main(String[] args) {	
		TreeSet<Animal> treeSet=new TreeSet<Animal>();//1创建集合
		Animal animal1=new Animal("阿福", 2);
		Animal animal3=new Animal("小强", 4);
		Animal animal2=new Animal("阿毛", 3);
		Animal animal4=new Animal("阿毛2", 3);	
		treeSet.add(animal1);//集合中添加对象元素
		treeSet.add(animal3);//添加元素后会自动调用引用类中的比较器
		treeSet.add(animal2);
		treeSet.add(animal4);
		
		System.out.println("个数:"+treeSet.size());
		System.out.println(treeSet);
	}
}

/*第二种方式*/
/*构造比较器*/
import java.util.Comparator;
public class MyComparator implements Comparator<Student>{//创建比较器类
	/*因为已经类默认继承Object类，所以不需要覆盖equals方法*/
	public int compare(Student o1, Student o2) {
		int num1=o1.getAge()-o2.getAge();
		int num2=o1.getName().compareTo(o2.getName());
		return num1==0?num2:num1;
	}
}
/*对象类*/
public class Student{
	private String name;
	private int age;
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public int getAge() {
		return age;
	}
	public void setAge(int age) {
		this.age = age;
	}
	public Student() {
	}
	public Student(String name, int age) {
		super();
		this.name = name;
		this.age = age;
	}
	public String toString() {
		return "Student [name=" + name + ", age=" + age + "]";
	}	
}
/*主函数所在类*/
import java.util.Comparator;
import java.util.TreeSet;
public class Demo4 {
	public static void main(String[] args) {
		TreeSet<Student> treeSet=new TreeSet<Student>(new MyComparator());//2创建集合对象,指定比较器	
		//3添加
		Student stu1=new Student("小明", 22);
		Student stu2=new Student("校花", 24);
		Student stu3=new Student("小明2", 22);
		Student stu4=new Student("校花2", 18);
		Student stu5=new Student("小明3", 19);
		Student stu6=new Student("校花3", 18);
		treeSet.add(stu1);
		treeSet.add(stu2);
		treeSet.add(stu3);
		treeSet.add(stu4);
		treeSet.add(stu5);
		treeSet.add(stu6);
		System.out.println(treeSet);
		
	}
}
```

##### 9.2 Map接口

1.Map接口是将键映射到值的对象。一个映射不能包含重复的键；每个键最多只能映射到一个值。 
 A--->B
 C--->B

```
/*使用Map集合
- 特点：
- 1 存储键值对，键不能重复,值可以重复
- 2 无序的
	HashMap和Hashtable方法一样，使用一样。
	HashMap:允许使用null值和null键,相对无序存储,非线程安全，jdk1.2，Map集合的排重，只需要重写键所属的类的hashCode和equals方法即可。
	Hashtable：不允许使用null值和null键,相对无序存储,线程安全，jdk1.0
 */
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;
public class Demo1 {
	public static void main(String[] args) {
		Map<String, String> map=new HashMap<String,String>();//1创建对象
		map.put("cn", "中国");//2添加数据
		map.put("usa", "美国");
		map.put("jp", "日本");
		map.put("kor", "韩国");
		System.out.println(map.put("us","美国"));//put添加键不重复数据时，返回null
		System.out.println(map.put("us","美利坚"));//put添加重复的键时，键对应的新的值美利坚会覆盖原有值美国，同时返回被覆盖的值美国。
		System.out.println("元素个数:"+map.size());
		System.out.println(map.get("us"));
		System.out.println(map);
		//3删除
		//map.remove("us");
		//System.out.println("删除之后:"+map);
		//map.clear();
		//4遍历
		//4.1使用keySet遍历
		System.out.println("---------使用keySet方法遍历----------");
		//Set<String> keySet=map.keySet();
		for (String key : map.keySet()) {
			System.out.println(key+"----->"+map.get(key));
		}
		//4.2使用entrySet遍历
		System.out.println("---------使用entrySet方法遍历----------");
		//Set<Map.Entry<String, String>> entries=map.entrySet();//map.entrySet()返回的是键值关系，所以Set后面的数据类型表示键值关系类型，即：Map.Entry<String, String>；Map.Entry实际上是属于map接口的内部静态接口，
		for (Map.Entry<String, String> entry : map.entrySet()) {
			System.out.println(entry.getKey()+"---->"+entry.getValue());
		}
		//4.3使用迭代器
		//System.out.println("----------使用迭代器----------");
		//Set<Map.Entry<String, String>> entries=map.entrySet();
		//Iterator<Map.Entry<String, String>> iterator=entries.iterator();
		//while(iterator.hasNext()){
			//Map.Entry<String, String> entry=iterator.next();
			//System.out.println(entry.getKey()+"---->"+entry.getValue());
		//}
		//5判断
		System.out.println(map.containsKey("cn"));
		System.out.println(map.containsValue("泰国"));
    }
}

/*Map集合的排重，只需要重写键所属的类的hashCode和equals方法即可。*/
import java.util.HashMap;

/*
 * 1 使用学生对象作为key,使用地址作为value
 * 2 如果学生姓名和地址一样，则认为是同一个学生。
 */
/*测试类*/
public class Demo3 {
	public static void main(String[] args) {
		HashMap<Student, String> hashMap=new HashMap<Student,String>();
		Student s1=new Student("aaa", "北京昌平沙河");
		Student s2=new Student("bbb", "北京海淀");
		Student s3=new Student("ccc", "北京朝阳");
		Student s4=new Student("ddd", "北京大兴");
		Student s5=new Student("ddd", "北京大兴");
		hashMap.put(s1, s1.getAddress());
		hashMap.put(s2, s2.getAddress());
		hashMap.put(s3, s3.getAddress());
		hashMap.put(s4, s4.getAddress());
		hashMap.put(s5, s5.getAddress());
		hashMap.put(null, null);
		System.out.println("长度:"+hashMap.size());
		System.out.println(hashMap);	
	}
}
/*学生类*/
import java.util.TreeMap;
import java.util.TreeSet;
public class Student {
	private String name;
	private String address;
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public String getAddress() {
		return address;
	}
	public void setAddress(String address) {
		this.address = address;
	}
	public Student() {
	}
	public Student(String name, String address) {
		super();
		this.name = name;
		this.address = address;
	}
	public String toString() {
		return "Student [name=" + name + ", address=" + address + "]";
	}
	public int hashCode() {//重写hashCode()
		int num1=name.hashCode();
		int num2=address.hashCode();
		return num1+num2;
	}
	public boolean equals(Object obj) {//重写equals
		if(obj ==null){
			return false;
		}
		if(obj instanceof Student){
			Student s=(Student)obj;
			if(this.name.equals(s.getName())&&this.address.equals(s.getAddress())){
				return true;
			}
		}
		return false;
	}	
}

/*
 * LinkedHashMap集合的使用 可以保证添加和读取的顺序一致
 */
 
/*hashTable*/ 
import java.util.Enumeration;
import java.util.Hashtable;
public class Demo5 {
	public static void main(String[] args) {
		Hashtable<String, String> hashtable=new Hashtable<String,String>();
		//1添加
		hashtable.put("xxx", "北京");
		hashtable.put("yyy", "南京");
		//3遍历
		//3.1使用entrySet
		//3.2使用keySet
		//3.3使用枚举器(value)
		Enumeration<String> elements = hashtable.elements();
		while(elements.hasMoreElements()){
			String key=elements.nextElement();
			System.out.println(key);
		}
		//3.4使用枚举器(key)
		Enumeration<String> keys = hashtable.keys();
		while(keys.hasMoreElements()){
			String key=keys.nextElement();
			System.out.println(key);
		}	
	}
}

/**/
```

##### 9.3 Collections工具类

```
/*
 * Collections工具类
 */
public class Demo1 {
	public static void main(String[] args) {
		//copy();
		//binarySearch();
		//reverse();
		//shuffle();
		//replace();
		frequency();
	}
	/*
	 * 复制
	 */
	public static void copy(){
		ArrayList<String> arrayList=new ArrayList<String>();
		arrayList.add("abc");
		arrayList.add("bcd");
		arrayList.add("xyz");
		arrayList.add("opq");
		ArrayList<String> dest=new ArrayList<String>();
		//先向目标方法中添加空数据保证长度和源一样
		for(int i=0;i<arrayList.size();i++){
			dest.add(null);
		}
		System.out.println(arrayList.size());
		System.out.println(dest.size());
		Collections.copy(dest, arrayList);
		
		System.out.println(dest);
	}
	/*
	 * 二分查找
	 */
	public static void binarySearch(){
		List<String> arrayList=new ArrayList<String>();
		arrayList.add("abc");
		arrayList.add("xyz");
		arrayList.add("efg");
		arrayList.add("bcd");
		//排序
		Collections.sort(arrayList);
		System.out.println(arrayList);
		
		int result=Collections.binarySearch(arrayList,"bcd");
		System.out.println(result);
	}
	/*
	 * 反转
	 */
	public static void reverse(){
		List<String> arrayList=new ArrayList<String>();
		arrayList.add("abc");
		arrayList.add("xyz");
		arrayList.add("efg");
		arrayList.add("bcd");
		System.out.println(arrayList);
		Collections.reverse(arrayList);
		System.out.println("反转之后:"+arrayList);
		
	}
	
	/*
	 * 打乱
	 */
	public static void shuffle(){
		List<String> arrayList=new ArrayList<String>();
		arrayList.add("10");
		arrayList.add("12");
		arrayList.add("20");
		arrayList.add("30");
		arrayList.add("8");
		arrayList.add("5");
		System.out.println(arrayList);
		Collections.shuffle(arrayList);
		System.out.println("打乱:"+arrayList);
	}
	/*
	 * 替换
	 */
	public static void replace(){
		List<String> arrayList=new ArrayList<String>();
		arrayList.add("10");
		arrayList.add("12");
		arrayList.add("20");
		arrayList.add("30");
		arrayList.add("8");
		arrayList.add("5");
		System.out.println(arrayList);
		Collections.replaceAll(arrayList, "5", "100");//将所有的5都换成100
		System.out.println("替换后:"+arrayList);
	}
	/*
	 * 查找指定元素出现的次数
	 */
	public static void frequency(){
		List<String> arrayList=new ArrayList<String>();
		arrayList.add("10");
		arrayList.add("12");
		arrayList.add("20");
		arrayList.add("30");
		arrayList.add("10");
		arrayList.add("5");
		int count=Collections.frequency(arrayList, "10");
		System.out.println(count);
	}
}
```

##### 9.4 数组集合的转换

	import java.util.ArrayList;
	import java.util.Arrays;
	import java.util.Collections;
	import java.util.List;
	public class Demo2 {
		public static void main(String[] args) {
			//arrayToList();//数组转换成集合
			//listToArray();//集合转换成数组
			arrayToList2();//集合转换成数组
		}
		//1数组转换成集合
		public static void arrayToList(){
			String[] arr={"aaaa","bbbb","cccc"};
			//是一个受限制的集合，不能添加元素，不能删除;可以使用集合的方法来遍历，使用Collections
			List<String> list=Arrays.asList(arr);
			System.out.println(list);
			//list.add("dddd");
			//list.remove("aaaa");
			Collections.reverse(list);
			System.out.println(list);		
		}
		//2集合转换成数组
		public static void listToArray(){
			List<Integer> list=new ArrayList<Integer>();
			list.add(10);
			list.add(20);
			list.add(30);
			list.add(40);	
	//		Object[] obj=list.toArray();
	//		for (Object object : obj) {
	//			System.out.println(object);
	//		}
			Integer[] arr=list.toArray(new Integer[0]);
			for (Integer integer : arr) {
				System.out.println(integer);
			}
		}
		//3数组转换成集合
		public static void arrayToList2(){
			Integer[] arr={10,20,30};
			List<Integer> list= Arrays.asList(arr);
			System.out.println(list);	
		}
	}
####第十节 一维数组、二维数组和异常

##### 10.1 一维数组	

```Java
public class Demo1 {
	public static void main(String[] args) {
		int n=10;
		String s="beijing";
		//1声明数组
		int[] nums;//声明数组，推荐写法 ，声明int类型数组，表示数组的元素是int
		int nums2[];//声明数组
		String[] strs;//声明数组， 声明String类型数组，表示数组的每个元素是String类型
		Student[] stus;//声明数组，声明Student类型数组，表示数组的每个元素是Student类型
	
		//2数组初始化
		//2.1静态初始化：声明数组的同时，赋值每个元素数据，长度不需要指定，由系统自动计算
		int[] aaa=new int[]{10,20,30};//长度3 //每个元素必须是相同的类型int
		int[] bbb={100,200,300,400,500};//长度5 每个元素必须是相同的类型int
	
		String[] country={"中国","美国","泰国","新加坡"};//长度4 ，每个元素都是String 
		//注意：在使用简写静态初始化数组时，必须一条语句完成，不能分割成两条语句
	
		//2.2动态初始化，初始值(byte short int 默认值 0 long 默认值0L char 默认值0  boolean 默认值false float 0.0f  double 0.0  )
		// 引用类型默认值 null
		int[] arr=new int[5];//初始化数组，指定长度为5，并给每个元素赋值为默认值  0
		String[] stuNames=new String[3]; //初始化数组，指定长度是3，并给每个元素赋值为默认值  null
		//2.3动态初始化后赋值,使用下标(下标最大值是长度-1)
		arr[0]=100;//给数组的第一个元素赋值为100
		arr[1]=200;//给数组的第二个元素赋值为200
		arr[2]=300;
		arr[3]=400;
		arr[4]=500;
	
		stuNames[0]="zhangsan";
		stuNames[1]="lisi";
		stuNames[2]="wangwu";
	
		System.out.println(stuNames[1]);
		//2.4打印数组的个数 length属性
		System.out.println(stuNames.length);
		System.out.println(arr.length);
	
		//2.5修改元素的值
		int num=arr[4]; //把数组中第5个元素，赋值给num
		System.out.println(num);
		num=3;
		System.out.println(num);
		System.out.println(arr[4]);

		arr[4]=8; //修改arr[4]的值为8；
		System.out.println(arr[4]);
	}
}
	/*1 数组的遍历*/
public class Demo2 {
	public static void main(String[] args) {
		//Scanner input=new Scanner(System.in);
		int[] nums=new int[5];//声明数组，长度为5，每个元素是默认值
		//1.2遍历默认值
		System.out.println("赋值之前------------");
		for(int i=0;i<nums.length;i++){
			System.out.println(nums[i]);
		}	
		for (int i = 0; i < nums.length; i++) {//1.3给数组赋值
			nums[i]=(int)(Math.random()*100)+1;
			//nums[i]=input.nextInt();
		}
		System.out.println("赋值之后--------------");	
		for (int i = 0; i < nums.length; i++) {//1.4遍历数组
			System.out.println(nums[i]);
		}
		System.out.println("使用增强for循环遍历");//1.5在jdk1.5之后 使用foreach遍历  、增强for循环 (for ：) 
		for(int n : nums){ //遍历数组中的每个元素，赋值n,增强for没有下标
			System.out.println(n);
		}	
	}
}
```
##### 10.2 排序和查找

（1）冒泡排序：比较两个相邻的下标对应的元素，如果符合条件就交换位置（最值出现在最后位）

```Java
class ArraySortedDemo01 {
	public static void main(String[] args) {
		int[] arr = {23,54,65,3,5,2,87};
		//以升序为例
		//外层循环：控制比较的轮数
		for(int i = 0;i < arr.length - 1;i++) {
			//内层循环：控制每一轮比较的次数和参与比较的下标
			for(int j = 0;j < arr.length - 1 - i;j++) {
				if(arr[j] > arr[j + 1]) {	
					int temp = arr[j];//交换位置
					arr[j] = arr[j + 1];
					arr[j + 1] = temp;
				}
			}
		}
		for(int num:arr) {
			System.out.println(num);
		}
	}
}
```
（2）选择排序：固定一个下标，然后拿这个下标对应的值依次和后面的元素进行比较

	class ArraySortedDemo02 {
		public static void main(String[] args) {
			int[] arr = {23,54,65,3,5,2,87};
			//以升序为例
			//外层循环：控制比较的轮数
			for(int i = 0;i < arr.length - 1;i++) {
				//内层循环:控制每一轮比较的次数，参与比较的下标
				for(int j = i + 1;j < arr.length;j++) {
					if(arr[i] > arr[j]) {//交换位置
						int temp = arr[i];
						arr[i] = arr[j];
						arr[j] = temp;
					}
				}
			}
			for(int num:arr) {
				System.out.println(num);
			}
		}
	}
（3）顺序查找：遍历这个数组，依次把每一位元素和要查找的数据进行比较

（4）二分法查找：前提是数组是有序（升序或者降序）的，通过折半来缩小查找范围，提高查找效率

将待查找的元素与中间下标对应的元素比较，如果大于中间下标对应的元素，则去右半部分查找

	class ArraySearchDemo02 {
		public static void main(String[] args) {
			int[] arr = {12,43,54,65,87,88,90,343};
			int key = 88;//待查找的元素
			int left = 0;//相应的下标
			int right = arr.length - 1;
			while(left <= right) {
				int middle = (left + right) / 2;//中间下标，取整
				if(arr[middle] > key) {
					right = middle - 1;
				} else if(arr[middle] < key) {
					left = middle + 1;
				} else {
					System.out.println(middle);
					break;
				}
			}
		}
	}	
##### 10.3 二维数组

```
/*二维数组的使用*/
public class Demo1 {
	public static void main(String[] args) {
		//1声明二维数组	
		int[][] nums;//1.1第一中方式元素类型[][] 数组名称	
		int nums2[][];//1.2第二种方式元素类型 数组名称[][]
		//2初始化 
		int[][] nums3=new int[][]{{2,4},{8,10,12},{1,3,5,7,9}};//2.1静态初始化
		int[][] nums4={{1,2},{3,4,5},{6,7,8,9}};//简写(必须一条语句完成，不能分割s)
		
		int[][] nums5=new int[3][];//2.2动态初始化,只指定外面的元素个数
		nums5[0]=new int[]{2,3};
		nums5[1]=new int[]{10,20,30};
		nums5[2]=new int[]{100};
		int[][] nums6=new int[2][3];//2.3二维的长度都指定

		//3访问数组
		//3.1打印二维数组的长度
		System.out.println(nums6.length);//3.1.1一维数组的长度
		System.out.println(nums6[0].length);//3.1.2二维数组的长度
		System.out.println(nums6[1].length);
		
		//3.2 赋值
		nums6[0][0]=10;//3.2.1使用下标赋值
		nums6[0][1]=20;
		nums6[0][2]=30;
		nums6[1][0]=100;
		nums6[1][1]=200;
		nums6[1][2]=300;
		for(int i=0;i<nums6.length;i++){//3.2.2使用循环赋值
			for(int j=0;j<nums6[i].length;j++){
				nums6[i][j]=(int)(Math.random()*100)+1;
			}
		}

		//3.3遍历
		for(int i=0;i<nums6.length;i++){
			for(int j=0;j<nums6[i].length;j++){
				System.out.print(nums6[i][j]+" ");
			}
			System.out.println();
		}
		System.out.println("-----------------");
		
		//3.4使用增强for
		for(int[] n:nums6){
			for(int i:n){
				System.out.print(i+" ");
			}
			System.out.println();
		}
	}
}
```

##### 10.4 异常

（1）异常的分类:运行时异常和编译时异常。

​	 运行时异常：（RuntimeException）在编译过程不会发现（没有语法错误），但是在执行程序程中，由于重大的逻辑错误导致的程序中断。所有的RuntimeException的子类包括RuntimeException都属于运行时异常。常见的运行时异常：NullPointerException   空指针异常（一个对象没有初始化调用方法）；IndexOutOfBoundsException	下标越界异常；ClassCastException	类型转换异常（对象类型转换时）；

NumberFormatException	数字格式异常；ArithmeticException		算术异常。

​	编译时异常：又叫非运行时异常或检查异常，在程序设计过程中，编译时就会被发现，但是执行时可能发生也可能不发生的异常，为了程序不报错可以执行，那么这一类异常必须进行相应的处理。Exception的子类，除了RuntimeExcption之外都属于编译时异常。

​	Exception类：异常的父类。Error类：错误，错误比较严重的问题，不属于异常，程序猿无法处理。

（2）异常的处理。	

```java
/*try-catch*/
import java.util.Scanner;
public class Demo3 {
	public static void main(String[] args) {
		divide();
	}
	public static void divide(){
		try {//有可能发生异常...将所有可能发生异常的语句全放进try
			Scanner input=new Scanner(System.in);
			System.out.println("请输入第一个数");//可能发生输入错误，如填写了字母
			int num1=input.nextInt();
			System.out.println("请输入第二个数");//可能发生输入错误，如填写了字母或者0
			int num2=input.nextInt();
			int result=num1/num2;//分母输入的如果是0，就会出错误
			System.out.println("结果是:"+result);
		} catch (Exception e) {//捕获，并处理异常，(Exception e)是异常类型，当异常类型定义不能包含try中错误类型时，catch将不能运行，则程序会中断，异常不会被处理。
			System.out.println("出现异常了...");
			e.printStackTrace();//打印异常信息
		}
		System.out.println("程序执行完毕...");
	}
}

/*try catch finallys */
import java.util.Scanner;
import javax.print.DocFlavor.INPUT_STREAM;
public class Demo4 {
	public static void main(String[] args) {
		divide();
	}
	public static void divide(){
		Scanner input=new Scanner(System.in);
		try {//有可能发生异常...
				System.out.println("请输入第一个数");
				int num1=input.nextInt();
				System.out.println("请输入第二个数");
				int num2=input.nextInt();
				int result=num1/num2;
				System.out.println("结果是:"+result);
			} catch (Exception e) {//捕获，并处理异常
				System.out.println("出现异常了...");
				e.printStackTrace();//打印异常信息
				System.exit(1);//0正常退出，非0非正常退出
				//return;
			}finally { //包含必须执行的代码，比如，释放资源的代码，不执行的唯一情况：退出java虚拟机，System.exit(); 0正常退出，非0非正常退出
				System.out.println("finally执行了");
				input.close();
			}
			System.out.println("程序执行完毕...");	
	}
}

/*多重catch*/
import java.util.Scanner
public class Demo5 {
	public static void main(String[] args) {
		divide();
	}
	public static void divide() {
		Scanner input = new Scanner(System.in);
		try {// 有可能发生异常...
			System.out.println("请输入第一个数");
			int num1 = input.nextInt();
			System.out.println("请输入第二个数");
			int num2 = input.nextInt();
			int result = num1 / num2;
			System.out.println("结果是:" + result);
		} catch (NullPointerException e) {// 捕获，并处理异常
			System.out.println("出现空指针异常...");
			e.printStackTrace();// 打印异常信息
		} catch (ArithmeticException e) {
			System.out.println("出现算术异常...");
			e.printStackTrace();// 打印异常信息
		}catch (Exception e) {
			System.out.println("出现异常...");
			e.printStackTrace();// 打印异常信息
		}
		finally { // 包含必须执行的代码，比如，释放资源的代码
			System.out.println("finally执行了");
			input.close();
		}
		System.out.println("程序执行完毕...");
	}
}

/* try ... finally 处理不了异常，只能释放资源*/
public class Demo6 {
	public static void main(String[] args) {
			divide();	
	}
	public static void divide() {
		Scanner input = new Scanner(System.in);
		try {// 有可能发生异常...
			System.out.println("请输入第一个数");
			int num1 = input.nextInt();
			System.out.println("请输入第二个数");
			int num2 = input.nextInt();
			int result = num1 / num2;
			System.out.println("结果是:" + result);
		} 
		finally { // 包含必须执行的代码，比如，释放资源的代码
			System.out.println("finally执行了");
			input.close();
		}
		System.out.println("程序执行完毕...");
	}
}

/* throws :声明异常 ,一般不声明运行时异常，声明编译时异常,告诉调用者，此方法会发生异常。*/
public class Demo7 {
	public static void main(String[] args) throws Exception{
		divide();
	}
	public static void divide() throws  Exception{
		Scanner input = new Scanner(System.in);
		System.out.println("请输入第一个数");
		int num1 = input.nextInt();
		System.out.println("请输入第二个数");
		int num2 = input.nextInt();
		int result = num1 / num2;
		System.out.println("结果是:" + result);
		System.out.println("程序执行完毕...");
	}
}

/* Person,throw 抛出异常*/
public class Person {
	private String name;
	private int age;
	private char sex;
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public int getAge() {
		return age;
	}
	public void setAge(int age) {
		if(age>=1&&age<=100){
			this.age=age;
		}else{
			throw new AgeException("年龄必须在1-100之间");
		}	
	}
	public char getSex() {
		return sex;
	}
	public void setSex(char sex) {
		if(sex=='男'||sex=='女'){
			this.sex=sex;
		}else{
			//抛出异常
			throw new SexException("性别输入错误");//抛出异常
		}	
	}
	public void show(){
		System.out.println("姓名:"+this.name+" 年龄："+this.age+" 性别："+this.sex);
	}	
}

public class AgeException extends RuntimeException{//自定义年龄异常类继承运行类
	public AgeException() {
		super();
	}
	public AgeException(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace) {
		super(message, cause, enableSuppression, writableStackTrace);
	}
	public AgeException(String message, Throwable cause) {
		super(message, cause);	
	}
	public AgeException(String message) {
		super(message);	
	}
	public AgeException(Throwable cause) {
		super(cause);	
	}	
}

public class SexException extends RuntimeException{//自定义性别异常类继承运行类
	public SexException() {
		super();
	}
	public SexException(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace) {
		super(message, cause, enableSuppression, writableStackTrace);
	}
	public SexException(String message, Throwable cause) {
		super(message, cause);
	}
	public SexException(String message) {
		super(message);
	}
	public SexException(Throwable cause) {
		super(cause);
	}
}

public class TestPerson {
	public static void main(String[] args) {
		try {
			Person p=new Person();
			p.setName("亮亮");
			p.setAge(120);
			p.setSex('妖');
			p.show();
		} catch (Exception e) {
			System.out.println(e.getMessage());//打印抛出的异常
			e.printStackTrace();//打印捕获的异常e
		}
	}
}
```
##### 10.5 可变参数

（1）可变参数：即不定长参数，在设计方法时，方法的形参的个数是不确定的

​	语法：类型... 变量名称   例如int... num

	class PramaUsageDemo {
		public static void main(String[] args) {
			int result = add(2,5,65,76,87,98,9);
			System.out.println(result);
	
			//2.对于一个方法的参数是不定长参数时，实参可以直接传一个数组
			int[] arr = {2,5,65,76,87,98,9};
			System.out.println(add(arr));//num = arr;
	
			text1(10,"hello",1,545,656);
			//text1(1,545,656,"hello");
		}
	
		//需求：计算不确定个整数的和
		public static int add(int... num) {//1.不定长的参数在进行使用的时候被当做数组来进行处理
			//num其实就相当于一个数组的引用变量
			int sum = 0;
			for(int n :num) {
				sum += n;
			}
			return sum;
		}
		//3.不定长参数在使用的时候，必须出现在参数列表的最后一个
		//4.在同一个参数列表中，不定长参数只能出现一次
		public static void text1(int num1,String s,int... num) {
		}
	}
#### 第十一节 IO流：文件,字节流，缓冲流等

##### 11.1 File类		

在java程序中，对磁盘文件进行描述的类。文件和目录路径名的抽象表示形式。

	/*
	 * File类
	 * 表示硬盘的文件和文件夹
	 */
	public class Demo1 {
		public static void main(String[] args) throws Exception {
			//fileConstructor();
			//fileOpe();
			dirOpe();
		}
		/*
		 * 1 File类的构造方法
		 */
		public static void fileConstructor(){
			//1创建对象 表示硬盘上的文件,文件可能存在，也可能不存在
			File file=new File("d:\\aaa.txt");//当文件真实存在时，该对象会和文件关联
			File file2=new File("d:\\haha.txt");
			File file3=new File("d:\\", "heihei.txt" );
			File parent=new File("d:\\");
			File chile1=new File(parent, "123.txt");
			File chile2=new File(parent, "456.txt");
			File chile3=new File(parent, "789.txt");
			System.out.println(file.toString());
			System.out.println(file2.toString());
			System.out.println(file3.toString());
		}
	
		/*
		 * 2 文件操作
		 */
		public static void fileOpe() throws Exception{
			//1创建File对象
			File file=new File("d:\\123.txt");
			//File file2=new File("123.txt");
			//2创建文件
			if(!file.exists()){
				boolean b=file.createNewFile();
				System.out.println(b);
				System.out.println("123.txt创建成功");
			}
			//3删除
	//		boolean b1=file.delete();
			//file.deleteOnExit();//jvm退出时，删除文件
	//		if(b1){
	//			System.out.println("删除成功");
	//		}
			//4判断
			//4.1能不能执行，在windows系统中，文件存在则为true
			System.out.println("canExecute():"+file.canExecute());
			//4.2能不能读取
			System.out.println("canRead():"+file.canRead());
			//4.3能不能写
			System.out.println("canWrite():"+file.canWrite());
			//5获取
			//5.1获取绝对路径名字符串
			System.out.println("getAbsolutePath():"+file.getAbsolutePath());
			//5.2获取规范路径名字符串
			System.out.println("getCanonicalPath():"+file.getCanonicalPath());
			//5.3获取文件名称
			System.out.println("getName() :"+file.getName());
			//5.4获取父目录名称
			System.out.println("getParent() :"+file.getParent());
			//5.5获取路径名
			System.out.println("getPath() :"+file.getPath());
			//5.6获取最后的修改时间
			System.out.println("lastModified():"+new Date(file.lastModified()));
			//6判断
			//6.1判断是否是文件
			System.out.println("isFile():"+file.isFile());
			//6.2判断是否是隐藏的
			System.out.println("isHidden():"+file.isHidden());
			//7长度
			System.out.println("length() :"+file.length());
			}
		/*
		 * 3文件夹操作
		 */
		public static void dirOpe(){
			//1创建File
			File dir=new File("d:\\images\\fengjing\\caoyuan");
			//2创建文件夹
			if(!dir.exists()){
				//dir.mkdir();//只能创建一级目录
				dir.mkdirs();//创建多级目录
				System.out.println("创建文件夹成功");
			}
			//3删除
			//dir.delete();
			//4获取
			//4.1获取绝对路径
			System.out.println("getAbsolutePath() ："+dir.getAbsolutePath());
			//4.2获取路径
			System.out.println("getPath()："+dir.getPath());
			//5判断
			System.out.println("isDirectory() :"+dir.isDirectory());
			
			//6获取当前目录下的文件和子文件夹
			System.out.println("-------------list()方法--------------");
			File dir2=new File("d:\\");
			String[] list = dir2.list();
			for (String string : list) {
				System.out.println(string);
			}
			//7获取当前目录下的pdf文件
			System.out.println("-------------list(xxx)方法--------------");
			String[] list2=dir2.list(new FilenameFilter() {
				
				@Override
				public boolean accept(File dir, String name) {
					if(name.endsWith(".pdf")){
						return true;
					}
					return false;
				}
			});
			for (String string : list2) {
				System.out.println(string);
			}
			
			//8listRoots() 
			File[] files=File.listRoots();
			System.out.println("-----listRoots() ------");
			for (File file : files) {
				System.out.println(file);
			}
		}
	}
	
	/*重命名*/
	public class Demo3 {
		public static void main(String[] args) throws Exception{	
			File  file=new File("d:\\abc.txt");//1创建File对象
			file.createNewFile();//1创建abc.txt文件
			System.out.println(file.toString());//d:\\abc.txt
			//2重命名(具有剪切的功能)
			file.renameTo(new File("d:\\234.txt"));//abc.txt文件名字改为了234.txt
			System.out.println(file.toString());//d:\\abc.txt,底下的文件名会改，但toString输出的是对象名
		}
	}
	
	/*
	 * 要求：把一个目录下的所有文件和文件夹遍历出来，包括子目录
	 * 使用递归
	 */
	package com.qf.day17;
	import java.io.File;
	public class Demo2 {
		public static void main(String[] args) {
			listFiles(new File("d:\\王老五"));
			//deleteDir(new File("c:\\"));
		}
		public static void listFiles(File dir){//递归遍历文件夹
			System.out.println(dir.getAbsolutePath());
			File[] listFiles = dir.listFiles();
			if(listFiles!=null){
				for (File file : listFiles) {
					if(file.isDirectory()){//如果是文件夹自己调用自己
						listFiles(file);
					}else{
						System.out.println(file.getAbsolutePath());
					}
				}
			}
		}
		public static void deleteDir(File dir){//递归删除文件夹
	//		boolean b=dir.delete();//只能删除空目录
	//		System.out.println(b);
			File[] files=dir.listFiles();
			if(files!=null){
				for (File file : files) {
					if(file.isDirectory()){
						deleteDir(file);
					}else{
						System.out.println("删除文件:"+file.getAbsolutePath());
						file.delete();
					}
				}
				
			}
			//删除空文件夹
			System.out.println("删除文件夹:"+dir.getAbsolutePath());
			dir.delete();		
		}
	}

##### 11.2 IO流

​	1.在工作中，经常会操作磁盘上的资源，这个过程中实现了数据的输入和输出操作，磁盘上的文件和内存之间进行交互，数据的交互需要有一个媒介或者管道，把这个媒介或者管道就称为IO流，也被称为输入输出流【I:Input  O:Output】
​	输入：从外部存储设备到内存叫输入|读取。
​	输出: 从内存到外部存储设备叫输出|写入。

 2.  IO流的种类

     (1)按照流的流向分：输入流、输出流

     ​     输入流：表示将数据读取到java程序（内存）中使用的流。

     ​     输出流：表示从java程序（内存）向外传输使用的流。

     (2) 按照数据单位分：字符流、字节流

     ​      字节流：一次性传输一个字节数据，将数据以字节的形式传输。

     ​      字符流：一次性传输一个字符数据，将数据以字符的形式传输。

     (3) 按照层次分：节点流、处理流

     ​      节点流：可以从或向一个特定的地方(节点)读写数据。

     ​      处理流：是对一个已存在的流的连接和封装，通过所封装的流的功能调用实现数据读写。

```
/*
- 使用字节输入流读取数据
  */
import java.io.FileInputStream;
import java.io.InputStream;//InputStream是一个抽象类，不能实例化对象。
public class Demo1 {
  public static void main(String[] args) throws Exception{
  	InputStream is=new FileInputStream("d:\\123.txt");//1创建字节输入流	
	//System.out.println(is.available());//2文件内容长度
	//3读取文件中内容
	//3.1读取一个字节
	//	int d=is.read();
	//	System.out.println(d);
	//3.2一个一个字节的读	
	//	int d=0;
	//	while((d=is.read())!=-1){
	//		System.out.println((char)d);
	//	}
	//3.3一次读取多个字节
	byte[] buf=new byte[10];//创建缓冲区
	int len=0;//实际读取的字节个数
	while((len=is.read(buf))!=-1){//is.read(buf)返回的是读取的长度
		for(int i=0;i<len;i++){
			System.out.print((char)buf[i]);
		}
	}
	//4关闭
	is.close();
  }
}

/*
 * 使用字节输出流写入文件
 */
import java.io.FileOutputStream;
import java.io.OutputStream;
public class Demo2 {
	public static void main(String[] args) throws Exception{
		OutputStream os=new FileOutputStream("d:\\haha.txt");//1创建字节输出流（若文件不存在，则创建）
		//2一个一个的写入
        //os.write(97);
        //os.write(98);
        //os.write(99);
		//3一次写入多个字节
		String s="abcdefg";
		byte[] buf=s.getBytes();
		os.write(buf);
		//4关闭
		os.close();
		System.out.println("执行成功");
	}
}

/*
 * 使用字符输入流读取文件
 */
import java.io.FileReader;
import java.io.Reader;
import java.lang.ProcessBuilder.Redirect;

public class Demo1 {
	public static void main(String[] args) throws Exception{	
		Reader reader=new FileReader("d:\\123.txt");//1创建字符文件输入流
		//2读取
		//2.1一个一个字符的读取
		//int d=0;
		//while((d=reader.read())!=-1){
			//System.out.print((char)d);
		//}
		//2.2一次读取多个字符
		char[] buf=new char[10];
		int len=0;
		while((len=reader.read(buf))!=-1){
			for(int i=0;i<len;i++){
				System.out.print(buf[i]);
			}
		}
		//3关闭
		reader.close();	
	}
}

/*
 * 使用字符输出流
 */
import java.io.FileWriter;
import java.io.Writer;
public class Demo2 {
	public static void main(String[] args) throws Exception {	
		Writer writer=new FileWriter("d:\\info.txt");//1创建字符输出流
		//2写入字符串
		//writer.write("好好学习，天天向上");
		for(int i=0;i<100;i++){
			writer.write(i+"好好学习，天天向上\r\n");
			writer.flush();
		}
		//3关闭
		//writer.flush();
		writer.close();//close()时，会刷新缓冲区
		System.out.println("写入成功");
	}
}

/*
 * 1 使用字节流复制文件	  
 * 2 使用字符流复制文件
 * 如果复制的文件是文本文件 ，用字节流和字符流都可以
 * 如果复制的文件是图片、音乐、电影, 用字符流复制会不会出现问题?
 */
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.Reader;
import java.io.Writer;
public class CopyFile {
	public static void main(String[] args) throws Exception {
		copy2();
	}
	public static void copy1() throws Exception{// 1 使用字节流复制文件
		//1创建字节文件输入输出流
		InputStream is=new FileInputStream("d:\\003.jpg");
		OutputStream os=new FileOutputStream("d:\\004.jpg");
		//2读、写
		byte[] buf=new byte[1024*4];
		int len=0;
		while((len=is.read(buf))!=-1){
			//buf缓冲区,0从第一个位置写，len写的长度
			os.write(buf,0,len);
		}
		//3关闭
		is.close();
		os.close();
		System.out.println("复制完成");
	}
	//2使用字符流复制文件
	public static void copy2() throws Exception{
		//1创建字符输入输出流
		Reader reader=new FileReader("d:\\003.jpg");
		Writer writer=new FileWriter("d:\\005.jpg");
		//2读写
		char[] buf=new char[1024*4];
		int len=0;
		while((len=reader.read(buf))!=-1){
			writer.write(buf, 0, len);
		}
		//3关闭
		reader.close();
		writer.close();
		System.out.println("复制完成");	
	}	
}
```
##### 11.3 缓冲流等及各种流综合

1.转换流作用：（1）实现字节流到字符流的转换（2）解决中文乱码的问题（GBK (英文数字都是一个字节，中文是两个或四个字节)；Unicode （2个字节）；utf-8  （1,2,3个字节））（3）只有转换流才能指定读取和写入的字符集

```
2.(1)字节输入流InputStream类    和    字节输出流 OutputStream类（都是抽象类，不能实例化对象）
		|_____ 文件字节输入流FileInputStream			|_____ 文件字节输出流FileOutputStream
  
  (2)字符输入流Reader类    和     字符输出流Writer类（都是抽象类，不能实例化对象）
		|_____ 字符输入流FileReader			|_____ 字符输出流FileWriter

  (3)转换流:InputStreamReader类      OutputStreamWriter类
	 InputStreamReader：字节字符转换输入流，将字节输入流转换为字符输入流
	 OutputStreamWriter：字节字符转换输出流，将字节输出流转换为字符输出流
 （4）缓冲流主要是为了增强基础流的功能而存在的，提高了流的工作效率【读写效率】
	  BufferedInputStream类   和    BufferedOutputStream类 	
	  BufferedReader类   和    BufferedOutWriter类
	  注：缓冲输出流写数据结束最好调用一下flush方法
 （5）内存流：ByteArrayInputStream和ByteArrayOutputStream
 	  输入和输出都是从文件中来的，当然，也可将输出的位置设置在内存上，这就需要ByteArrayInputStream和ByteArrayOutputStream 
      ByteArrayInputStream:将内容写入到内存中，是Inputstream的子类
	  ByteArrayOutputStream：将内存中数据输出，是OutputStream的子类
	  此时的操作应该以内存为操作点	
 （6）Java的标准输入/输出分别通过System.in和System.out实现，默认情况下分别代表是键盘和显示器
 （7）对象流：流中流动的数据是对象
 	  如果将一个对象写入到本地文件中，被称为对象的序列化
	  如果将一个本地文本中的对象读取出来，被称为对象序列化
/*
- 使用InputStreamReader读取文本文件：InputStreamReader：字节字符转换输入流，将字节输入流转换为字符输入流 
- 采用指定编码来读取
  */
import java.io.FileInputStream;
import java.io.InputStream;
import java.io.InputStreamReader;
public class Demo1 {
	public static void main(String[] args) throws Exception{
		InputStream is=new FileInputStream("d:\\123.txt");//1创建对象
		InputStreamReader isr=new InputStreamReader(is, "utf-8"); //读取的文件是gbk
		//2读取
		char[] buf=new char[10];
		int len=0;
		while((len=isr.read(buf))!=-1){
			for(int i=0;i<len;i++){
				System.out.print(buf[i]);
			}
		}
		//3关闭
		isr.close();
		//is.close();
	}
}

/*使用OutputStreamWriter写入文件：OutputStreamWriter：字节字符转换输出流，将字节输出流转换为字符输出流
 * 指定编码
 */
import java.io.FileOutputStream;
import java.io.OutputStreamWriter;
public class Demo2 {
	public static void main(String[] args) throws Exception {
		//1创建OutputStreamWriter
		OutputStreamWriter osw=new OutputStreamWriter(new FileOutputStream("d:\\456.txt"), "utf-8");
		//2写入
		osw.write("我爱你中国");
		//3关闭
		osw.close();	
	}
}

/*缓冲流*/
作用：主要是为了增强基础流的功能而存在的，提高了流的工作效率【读写效率】
/*
 * 使用BufferedInputStream
 */
import java.io.BufferedInputStream;
import java.io.FileInputStream;
public class Demo1 {
	public static void main(String[] args) throws Exception{
		//1创建缓冲字节流
		BufferedInputStream bis=new BufferedInputStream(new FileInputStream("d:\\123.txt"));
		//2读取
		//2.1一个字节一个字节
//		int d=0;
//		while((d=bis.read())!=-1){
//			System.out.printf("%X ",d);
//		}
		//2.2一次读取多个字节
		byte[] buf=new byte[1024*4];
		int len=0;
		while((len=bis.read(buf))!=-1){
			for(int i=0;i<len;i++){
				System.out.printf("%X ",buf[i]);
			}
		}
		//3关闭
		bis.close();	
	}
}

/*
 * 使用BufferedOutputStream
 */
import java.io.BufferedOutputStream;
import java.io.FileOutputStream;
import java.nio.charset.Charset;
import java.util.SortedMap;
public class Demo2 {
	public static void main(String[] args) throws Exception{
		//1创建缓冲字节输出流
		BufferedOutputStream bos=new BufferedOutputStream(new FileOutputStream("d:\\info.txt"));
		//2写入
		String s="我爱你中国";
		byte[] bytes = s.getBytes("utf-8");//默认utf-8|gbk
		bos.write(bytes);
		//3关闭
		bos.close();
	
	}
}

/* BufferedReader
 * 缓存字符输入流
 */
import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.FileReader;
import java.io.InputStreamReader;
public class Demo1 {
	public static void main(String[] args) throws Exception{
		//1创建BufferedReader对象
		InputStreamReader isr=new InputStreamReader(new FileInputStream("d:\\log.txt"), "gbk");
		BufferedReader br=new BufferedReader(isr);//utf-8
		//2读取
		//2.1一个字符一个字符的读
//		int d;
//		while((d=br.read())!=-1){
//			System.out.print((char)d);
//		}
		//2.2一次读取多个
//		char[] buf=new char[1024];
//		int len=0;
//		while((len=br.read(buf))!=-1){
//			for(int i=0;i<len;i++){
//				System.out.print(buf[i]);
//			}
//		}
		//2.3一行一行读取
		String line=null;
		while((line=br.readLine())!=null){
			System.out.println(line);
		}
		//3关闭
		br.close();	
	}
}

/*
 * BufferedWriter
 * 缓冲字符输出流
 */
import java.io.BufferedWriter;
import java.io.FileOutputStream;
import java.io.FileWriter;
import java.io.OutputStreamWriter;
public class Demo2 {
	public static void main(String[] args) throws Exception{
		//1创建对象
		OutputStreamWriter osw=new OutputStreamWriter(new FileOutputStream("d:\\heihei.txt"),"gbk");
		BufferedWriter bw=new BufferedWriter(new FileWriter("d:\\haha.txt"));//utf-8
		//2写入
		bw.write("我爱北京天安门");
		bw.newLine();//写入行分隔符
		bw.write("学习java,找个好媳妇或老公");
		//3关闭
		bw.close();
		
	}
}

/*
 * ByteArrayInputStream
 * 字节内存输入流 
 */
import java.io.ByteArrayInputStream;
import java.util.concurrent.SynchronousQueue;
public class Demo1 {
	public static void main(String[] args) throws Exception{
		//1创建ByteArrayInputStream
		byte[] buf={10,20,30,40,50};//buf数据
		ByteArrayInputStream bais=new ByteArrayInputStream(buf);向内存中输出内容，注意：跟文件读取不一样，不设置文件路径
		//2读取
		int d=0;
		while((d=bais.read())!=-1){
			System.out.println(d);
		}
		//3关闭(可写可不写)
		bais.close();
	}
}

/*
 * 使用ByteArrayOutputStream
 * 字节内存输出流
 */
import java.io.ByteArrayOutputStream;
public class Demo2 {
	public static void main(String[] args) throws Exception {
		//1创建字节内存输出流(内部有缓冲区)
		ByteArrayOutputStream baos=new ByteArrayOutputStream();
		//2写数据
		baos.write(10);
		baos.write(100);
		baos.write(126);
		baos.write(-50);
		baos.write(5);
		//3关闭
		baos.close();
		//4从流的缓冲区中取数据
		byte[] data=baos.toByteArray();
		for (byte b : data) {
			System.out.println(b);
		}
	}
}

/* Java的标准输入/输出分别通过System.in和System.out实现，默认情况下分别代表是键盘和显示器
 * 重定向标准输入输出流
 */
import java.io.FileInputStream;
import java.io.OutputStream;
import java.io.PrintStream;
import java.util.Scanner;
public class Demo1 {
	public static void main(String[] args) throws Exception{
		//1重定向标准输出流(硬盘中一个文件中d:\\out.txt)
		System.setOut(new PrintStream("d:\\out.txt"));
		System.out.println("哈哈哈哈");
		System.out.println("嘿嘿嘿额");
		//2重定向标准输入流
//		System.setIn(new FileInputStream("d:\\in.txt"));
//		Scanner input=new Scanner(System.in);
//		String s=input.next();
//		System.out.println(s);
		//3重定向标准错误输出流
		System.setErr(new PrintStream("d:\\error.txt"));
		System.err.println("这是一个错误");
	}
}

/*
 * 使用ObjectInputStream;使用对象流Serializable 
 */

/*
 * 学生类
 * 实现Serializable接口，这是一个标记接口，作用表示这个类可以被序列化
 */
  import java.io.Serializable;
  public class Student implements Serializable{
	private static final long serialVersionUID = 200L;
	private String name;
	private transient int age;// transient ：瞬间的短暂的
	public static String country="中国";
	public Student() {
	
	}
	public Student(String name, int age) {
		super();
		this.name = name;
		this.age = age;
	}
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public int getAge() {
		return age;
	}
	public void setAge(int age) {
		this.age = age;
	}
	public String toString() {
		return "Student [name=" + name + ", age=" + age + "]";
	}	
}

/*
 * 使用对象流
 * Serializable
 */

/*
 * Serializable 标记接口
 */
import java.io.Serializable;
public class Car implements Serializable{//要实现类的序列化就必须实现该接口并声明serialVersionUID
	private static final long serialVersionUID = 200L;
	private String brand;
	private String color;
	private int money;
	public String getBrand() {
		return brand;
	}
	public void setBrand(String brand) {
		this.brand = brand;
	}
	public String getColor() {
		return color;
	}
	public void setColor(String color) {
		this.color = color;
	}
	public int getMoney() {
		return money;
	}
	public void setMoney(int money) {
		this.money = money;
	}
	public Car() {
		// TODO Auto-generated constructor stub
	}
	public Car(String brand, String color, int money) {
		super();
		this.brand = brand;
		this.color = color;
		this.money = money;
	}
	public String toString() {
		return "Car [brand=" + brand + ", color=" + color + ", money=" + money + "]";
	}	
}

/*
 * 序列化
 */
import java.io.FileOutputStream;
import java.io.ObjectOutputStream;
import java.util.ArrayList;
import java.util.List;
public class Demo1 {
	public static void main(String[] args) throws Exception{
		//1创建对象流
	   ObjectOutputStream oos=new ObjectOutputStream(new FileOutputStream("d:\\cars.bin",true));
		//2对象
	   Car car1=new Car("宝马", "红色", 30);
	   Car car2=new Car("保时捷", "蓝色", 150);
	   Car car3=new Car("法拉利","红色",300);
		
	   List<Car> cars=new ArrayList<Car>();
	   cars.add(car1);
	   cars.add(car2);
	   cars.add(car3);
//		
//		oos.writeObject(car1);
//		oos.writeObject(car2);
//		oos.writeObject(car3);
		oos.writeObject(cars);
		//3关闭
		oos.close();
		System.out.println("序列化成功");
	}
}

/*
 * 反序列化
 */
import java.io.FileInputStream;
import java.io.ObjectInputStream;
import java.util.List;
public class Demo2 {
	public static void main(String[] args) throws Exception {
		//1创建对象输入流
		ObjectInputStream ois=new ObjectInputStream(new FileInputStream("d:\\cars.bin"));
		//2读取
//		Car c1=(Car)ois.readObject();
//		Car c2=(Car)ois.readObject();
//		Car c3=(Car)ois.readObject();
		List<Car> cars=(List<Car>) ois.readObject();
		
//		System.out.println(c1.toString());
//		System.out.println(c2.toString());
//		System.out.println(c3.toString());
		for (Car car : cars) {
			System.out.println(car.toString());
		}
		//3关闭
		ois.close();
	}
}
```

##### 11.4 RandomAccessFile类

RandomAccessFile是用来访问那些保存数据记录的文件的，你就可以用seek( )方法来访问记录，并进行读写了。这些记录的大小不必相同；但是其大小和位置必须是可知的。但是该类仅限于操作文件。

	import java.io.FileNotFoundException;
	import java.io.IOException;
	import java.io.RandomAccessFile;
	public class RandomAccessFileDemo {
		public static void main(String[] args) throws Exception {
			//write();
			read();
			//method();
		}
		//写入
		private static void write() throws Exception {
			//1创建RandomAccessFile对象
			RandomAccessFile raf=new RandomAccessFile("d:\\ran.txt", "rw");
			//2写
			raf.write(20);
			raf.writeDouble(3.5);//占8个字节
			raf.writeInt(30);// 占4个字节
			raf.writeBoolean(true);// 占1个字节
			raf.writeUTF("张三疯");
			
			//写2
			raf.write(120);
			raf.writeDouble(13.5);
			raf.writeInt(130);
			raf.writeBoolean(false);
			raf.writeUTF("李思思");
			
			//3关闭
			raf.close();
			System.out.println("写入成功");
		}
		//读取
		public static void read() throws Exception{
			//1创建RandomAccessFile 对象
			RandomAccessFile randomAccessFile=new RandomAccessFile("d:\\ran.txt", "rw");
			//2读取
			//randomAccessFile.seek(0);//设置文件的偏移指针 ,从0开始
			//randomAccessFile.seek(25);
			//跳过字节个数
			//randomAccessFile.skipBytes(25);
			byte[] bs=new byte[25];
			randomAccessFile.readFully(bs);
			System.out.println(randomAccessFile.getFilePointer());
			
			int n=randomAccessFile.read();
			double d=randomAccessFile.readDouble();
			int n2=randomAccessFile.readInt();
			boolean b=randomAccessFile.readBoolean();
			String s=randomAccessFile.readUTF();
			System.out.println(n+"..."+d+"..."+n2+"..."+b+"..."+s);
			//3关闭
			randomAccessFile.close();
		}
		//其他方法
		public static void method() throws Exception{
			RandomAccessFile raf=new RandomAccessFile("d:\\ran2.txt", "rw");
			//1设置文件长度
			raf.setLength(1024*1024);
			//2获取长度
			System.out.println(raf.length());
			raf.close();	
		}
	}
	public class Test {
		public static void main(String[] args) throws Exception{
			String str="张三";
			byte[] bs=str.getBytes("utf-8");
			for (byte b : bs) {
				System.out.printf("%X",b);
			}
		}
	}
##### 12.5  Properties类

1.Properties是Map接口的一个实现类，并且是Hashtable的子类，Properties文件中元素也是以键值对的形式存在的

	/*
	 * Properties的使用
	 */
	import java.io.FileInputStream;
	import java.io.FileOutputStream;
	import java.io.FileReader;
	import java.io.FileWriter;
	import java.io.PrintStream;
	import java.util.Map;
	import java.util.Properties;
	import java.util.Set;
	public class PropertiesDemo {
		public static void main(String[] args)  throws Exception{
			//1创建Properteis集合
			Properties properties=new Properties();
			//2添加
			properties.setProperty("name", "zhangsan");
			properties.setProperty("age", "20");
			properties.setProperty("adress", "北京昌平沙河");
			//3删除
			//4遍历
			//4.1增强for
	//		for (Map.Entry<Object, Object> entry:properties.entrySet()) {
	//			System.out.println(entry.getKey()+"--->"+entry.getValue());
	//		}
			//4.2使用stringPropertyNames
			Set<String> set=properties.stringPropertyNames();
			for (String pro : set) {
				System.out.println(pro+"---"+properties.getProperty(pro));
			}	
			//5和流有关
			properties.list(System.out);
			//6获取系统有关的属性
			Properties sysPros= System.getProperties();
			sysPros.list(System.out);//输出到控制
			sysPros.list(new PrintStream(new FileOutputStream("d:\\sys.properties")));//输出文件	
			//7load加载文件setting.propertes
			Properties properties2=new Properties();
			properties2.load(new FileReader("d:\\setting.properties"));
			properties2.list(System.out);
			//8store 存储到文件中
			properties2.store(new FileWriter("d:\\setting2.properties"), "xxx");
		}
	}

#### 第十二节 多线程

##### 12.1 进程、线程

1.进程是程序的一个动态过程,它指的是从代码加载到执行完毕的一个完成过程，是一个程序的运行状态和资源占用（内存，CPU）的描述


	进程的特点：
		a.独立性：不同的进程之间是独立的，相互之间资源不共享（举例：两个正在上课的教室有各自的财产，相互之间不共享）
		b.动态性：进程在系统中不是静止不动的，而是在系统中一直活动的
		c.并发性：多个进程可以在单个处理器上同时进行，且互不影响
2.线程是进程的组成部分，一个进程可以有多个线程，每个线程去处理一个特定的子任务，线程的执行是抢占式的，多个线程在同一个进程中可以并发执行，其实就是CPU快速的在不同的线程之间切换，也就是说，当前运行的线程在任何时候都有可能被挂起，以便另外一个线程可以运行

3.进程和线程的关系以及区别

a.一个程序运行后至少有一个进程
b.一个进程可以包含多个线程，但是至少需要有一个线程，否则这个进程是没有意义的
c.进程间不能共享资源，但线程之间可以
d.系统创建进程需要为该进程重新分配系统资源，而创建线程则容易的多，因此使用线程实现多任务并发比多进程的效率高

#####12.2 多线程的实现

1.继承Thread类、实现Runnable接口、使用Callable接口共三种方式实现多线程

```
继承自Thread类，Thread类是所有线程类的父类，实现了对线程的抽取和封装
继承Thread类创建并启动多线程的步骤：1 定义一个类继承Thread类,重写run方法,该run方法的方法体就代表了线程需要完成的任务，因此，run方法的方法体被称为线程执行体.创建Thread子类的对象，即创建了子线程。2 创建线程对象。3 用线程对象的start方法来启动该线程
/*创建子线程*/
public class MyThread extends Thread{//继承Thread类
	public MyThread(String name) {//若不通过构造函数赋名字可以通过在主函数中t1.setName("");赋名
		super(name);
	}
	public void run() {//重写run方法
		for(int i=0;i<50;i++){//Thread.currentThread().getName()功能是获取当前线程名称	
			System.out.println("子线程在执行..."+i+"....."+Thread.currentThread().getName());
		}
	}
}
/*测试函数*/
public class Demo1 {
	public static void main(String[] args) {
		MyThread t1=new MyThread("线程1");//创建线程对象并通过构造方法给线程附名字
		MyThread t2=new MyThread("线程2");
		//3启动了一个子线程
		t1.start();//start（）方法会自动执行run方法的方法体
		t2.start();//线程的执行是抢占式，所以t2并不一定非要等t1执行完之后才执行
		for(int i=0;i<100;i++){//执行main方法的线程叫主线程
			System.out.println("主线程执行了******"+i);
		}		
	}
}

/*售票问题*/
/*四个窗口各卖100张票*/
public class SaleTicket extends Thread {
	public SaleTicket(String name){
		super(name);
	}
	private int ticket=100;//票
	
	public void run() {
		while(true){
			if(ticket<1){
				break;
			}
			System.out.println(Thread.currentThread().getName()+"卖了第"+ticket+"张票");
			ticket--;
		}
	}
}
public class Demo1 {
	public static void main(String[] args) {
		//1创建四个窗口
		SaleTicket w1=new SaleTicket("窗口1");
		SaleTicket w2=new SaleTicket("窗口2");
		SaleTicket w3=new SaleTicket("窗口3");
		SaleTicket w4=new SaleTicket("窗口4");
		//2启动
		w1.start();
		w2.start();
		w3.start();
		w4.start();
	}
}

/*四个窗口共卖100张票----实现Runnable接口*/
/*实现Runnable接口创建并启动多线程的步骤：1.定义一个Runnable接口的实现类，并重写该接口中的run方法，该run方法的方法体同样是该线程的线程执行体 2.创建Runnable实现类的实例，并以此实例作为Thread的target来创建Thread对象，该Thread对象才是真正的线程对象3.调用线程对象的start方法来启动该线程 */
public class TicketRes implements Runnable{//实现Runnable接口
	private  int ticket=100;//票资源共享
	public void run() {
		while(true){//问题在于，线程是抢占式的，当t1抢到cpu.开始卖票，打印第100张票，没有执行ticket--，时间到了，释放cpu，那么t2抢到cpu开始卖票，此时ticket仍然是100，那么t2也就会打印第100张票，这样程序就出错了，所以以此类推此程序会出现四个窗口同时卖100张票或者有的窗口卖的还是负数票，解决方法：见多线程同步章节
			if(ticket<1){
				break;
			}
			System.out.println(Thread.currentThread().getName()+"卖了第"+ticket+"张票");
			ticket--;
		}
	}
}
public class Demo2 {
	public static void main(String[] args) {	
		TicketRes res=new TicketRes();//1创建TicketRes	
		Thread w1=new Thread(res);//2创建线程
		Thread w2=new Thread(res);
		Thread w3=new Thread(res);
		Thread w4=new Thread(res);	
		//3启动
		w1.start();
		w2.start();
		w3.start();
		w4.start();	
	}
}
/*两种实现方式的比较*/
实现Runnable接口的方式
	a.资源类实现了Runnable接口。如果资源类有多个操作，需要把功能提出来，单独实现Runnable接口,可以继承其他类。
	b.可以多个线程共享同一个资源，所以非常适合多个线程来处理同一份资源的情况
	c.弊端：编程稍微复杂，不直观，如果要访问当前线程，必须使用Thread.currentThread()
继承Thread类的方式
	a.编写简单，如果要访问当前线程，除了可以通过Thread.currentThread()方式之外，还可以使用getName()
	b.弊端：因为线程类已经继承了Thread类，则不能再继承其他类【单继承】
	实际上大多数的多线程应用都可以采用实现Runnable接口的方式来实现【推荐使用匿名内部类】 
/*使用Callable接口实现多线程*/
/*
 * 定义一个类实现Callable接口,该方式的特点是有返回值
 */
public class MyCallable implements Callable<Integer>{
	public Integer call() throws Exception {
		int sum=0;
		for(int i=1;i<=100;i++){
			Thread.sleep(100);
			sum+=i;
		}
		System.out.println("子线程执行了........."+Thread.currentThread().getName());
		return sum;
	}
}
public class Demo1 {
	public static void main(String[] args) throws Exception{
		//1创建Mycallable对象(该对象是可调用的)
		MyCallable callable=new MyCallable();
		//2创建一个任务（就是一个线程）实现Runable接口
		FutureTask<Integer> task=new FutureTask<Integer>(callable);
		//3创建线程对象
		Thread thread=new Thread(task);
		//4启动
		thread.start();
		//5获取返回值
		Integer sum=task.get();//会等待子线程执行完毕，返回结果
		System.out.println(sum);	
	}
}
```

##### 12.3 线程的常用方法

```java
/*程序一*/
public class Test {
	public static void main(String[] args) throws Exception{
		System.out.println("主线程执行了.....");
		InterruptDemo interruptDemo=new InterruptDemo();
		interruptDemo.start();
		System.out.println("30秒内按任意键结束子线程");
		System.in.read();//程序会让用输入一个数据
		interruptDemo.interrupt();//打断线程
		System.out.println("主线程结束了.............");	
      	
      	YieldThread y1=new YieldThread();
		//y1.setPriority(10);//设置优先级；默认为5；数字越大，优先级越高，这个方法的设置要在start之前
		YieldThread y2=new YieldThread();
		y1.start();
		y2.start();
	}
}
public class InterruptDemo extends Thread{//线程中断 interrupt()
	public void run() {
		System.out.println("子线程开始执行了.............");
		try {
			System.out.println("子线程开始休眠 30秒.......");
			Thread.sleep(30000);//休眠30秒；线程进入阻塞状态；
			System.out.println("子线程正常苏醒了...");
		} catch (InterruptedException e) {
			System.out.println("子线程被打醒了.....");
		}
		System.out.println("子线程结束了.......");	
	}
}

public class YieldThread extends Thread{//线程让步子类
	public void run() {
		for(int i=0;i<10;i++){
			System.out.println(Thread.currentThread().getName()+"........"+i);
			//谦让 
			Thread.yield();让当前正在执行的线程暂停;不会阻塞该线程,只是将该线程转入就绪状态,当某个线程调用了yield方法暂停之后，线程调度器又将其调度出来重新执行也是完全可能的；实际上，当某个线程调用了yield方法暂停之后，只有优先级与当前线程相同，或者优先级比当前线程更高的就绪状态的线程才会获得执行的机会
		}
	}
}
/*程序二后台线程*/
public class Test {
	public static void main(String[] args) {
		//1创建线程对象(前台线程)
		DeamonThread d1=new DeamonThread();
		//2启动
		//设置d1线程为后台线程
		d1.setDaemon(true);//如果所有的前台线程都死亡，后台线程会自动死亡，设置后台线程必须要在start之前执行
		d1.start();	
		for(int i=0;i<10;i++){
			System.out.println("主线程***************"+i);
			try {
				Thread.sleep(5);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		}
	}
}
public class DeamonThread extends Thread {
	public void run() {
		for(int i=0;i<100;i++){
			System.out.println(Thread.currentThread().getName()+"....."+i);
			try {
				Thread.sleep(10);
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}
	}
}

/*程序三：合并线程*/
public class Test {
	public static void main(String[] args) throws Exception{
		//1创建线程对象
		JoinDemo j1=new JoinDemo();	
		j1.start();//2启动
		//3合并线程（加入线程）
		j1.join();//阻塞主线程；遇到了合并线程，则优先执行合并进来的线程，执行完合并进来的线程后，再回到原来的任务中，继续执行原来的线程；线程合并,当前线程一定会释放cpu时间片,cpu会将时间片分给要Join的线程；join之前,一定要将线程处于准备状态start
		for(int i=0;i<10;i++){
			System.out.println("主线程*******************"+i);
		}
	}
}
public class JoinDemo extends Thread{
	public void run() {
		for(int i=0;i<100;i++){
			System.out.println(Thread.currentThread().getName()+"...."+i);
			try {
				Thread.sleep(10);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		}
	}
}
```

##### 12.4 线程的生命周期

1.对于线程，当线程被创建并启动之后，它既不是一启动就进入了执行状态，也不是一直处于执行状态，在线程的生命周期中，他会经历各种不同的状态【在一个进程中，多个线程同时运行，是在争抢CPU时间片】

```
New(新生)：线程被实例化，但是还没有开始执行
Runnable（就绪）:没有抢到时间片
Running（运行）:抢到了时间片，CPU开始处理这个线程中的任务
Blocked(阻塞):	线程在执行过程中遇到特殊情况，使得其他线程就可以获得执行的机会，被阻塞的线程会等待合适的时机重新进入就绪状态
Dead(死亡):线程终止
	a.run方法执行完成，线程正常结束【正常的死亡】
	b.直接调用该线程的stop方法强制终止这个线程   
```

##### 12.5 多线程同步

1.多线程访问临界资源时的数据安全问题:

   (1)临界资源 :多个线程同时访问的资源。

   (2)产生原因：有多个线程在同时访问一个资源，如果一个线程在取值的过程中，时间片又被其他线程抢走了，临界资源问题就产生了

   (3)解决临界资源问题:一个线程在访问临界资源的时候，如果给这个资源“上一把锁”，这个时候如果其他线程也要访问这个资源，就得在“锁”外面等待(锁：任意的对象都可以被当做锁来使用)

	/*同步主类*/
	public class Test {
		public static void main(String[] args) {
			//1创建票资源
			TicketRes res=new TicketRes();
			//2创建四个窗口
			Thread t1=new Thread(res,"窗口1");
			Thread t2=new Thread(res,"窗口2");
			Thread t3=new Thread(res,"窗口3");
			Thread t4=new Thread(res,"窗口4");
			//3启动线程
			t1.start();
			t2.start();
			t3.start();
			t4.start();
		}
	}
	/*方式一：同步代码段实现锁*/
	public class TicketRes implements Runnable{
		private int ticket=100;
		private Object lock=new Object();//定义锁
		public void run() {
			while(true){
				synchronized (lock) {//也可以用this作为锁:表示当前对象，只有一个
						if(ticket<1){
							break;
						}
						System.out.println(Thread.currentThread().getName()+"卖第"+ticket+"张票");
						ticket--;
				}//同步代码块:程序走到代码段中，就用锁来锁住了临界资源，这个时候，其他线程不能执行代码段中的代码，只能在锁外边等待;执行完代码段中的这段代码，会自动解锁。然后剩下的其他线程开始争抢cpu时间片;一定要保证不同的线程看到的是同一把锁，否则同步代码块没有意义	
			}
		}
	}
	/*方式二：同步的非静态方法实现锁，锁是this；同步的静态方法实现锁，锁是类.class 类对象*/
	public class TicketRes implements Runnable{
		private  int ticket=100;
		public void run() {
			while(true){
				boolean b=sale();
				if(!b){
					break;
				}
			}
		}
		public synchronized  boolean sale(){//卖票(同步的非静态方法，锁是this)
				if(ticket<1){
					return false;//没票了
				}
				System.out.println(Thread.currentThread().getName()+"卖第"+ticket+"张票");
				ticket--;
				return true;
		}	
	//	public synchronized static boolean sale2(){//卖票2(同步的静态方法,锁是类.class 类对象)TicketRes.class		
	//			if(ticket<1){
	//				return false;//没票了
	//			}
	//			System.out.println(Thread.currentThread().getName()+"卖第"+ticket+"张票");
	//			ticket--;
	//			return true;		
	//	}
	}

2.ReentrantLock类(可重入锁)jdk1.5

​	通过显式定义同步锁对象来实现同步,同步锁提供了比synchronized代码块更广泛的锁定操作；最好将 unlock的操作放到finally块中；通过使用ReentrantLock这个类来进行锁的操作,它实现了Lock接口，使用ReentrantLock可以显式地加锁、释放锁。

	public class Test {
		public static void main(String[] args) {
			//1创建票资源
			TicketRes res=new TicketRes();
			//2创建四个窗口
			Thread t1=new Thread(res,"窗口1");
			Thread t2=new Thread(res,"窗口2");
			Thread t3=new Thread(res,"窗口3");
			Thread t4=new Thread(res,"窗口4");
			//3启动线程
			t1.start();
			t2.start();
			t3.start();
			t4.start();
		}
	}
	import java.util.concurrent.locks.ReentrantLock;
	public class TicketRes implements Runnable{
		private int ticket=100;
		//可重入锁
		private ReentrantLock lock=new ReentrantLock();
		public void run() {
			while(true){
						lock.lock();//上锁
						try {
							if (ticket < 1) {
								break;
							}
							System.out.println(Thread.currentThread().getName() + "卖第" + ticket + "张票");
							ticket--;
						} finally {
							lock.unlock();
						}
			}
		}
	}
3.避免死锁

   死锁条件：（1）两个以上的线程  （2）至少两个锁以上 （3）同步中嵌套同步

	/*会出现死锁的程序：*/
	public class Lock {
		public static Object locka=new Object();//第一个锁
		public static Object lockb=new Object();//第二个锁
	}	
	public class Boy extends Thread{
		public void run() {
			while (true) {
				synchronized (Lock.locka) {
					System.out.println("男孩拿着locka");
					synchronized (Lock.lockb) {
						System.out.println("男孩拿到lockb");
						System.out.println("男孩可以吃了....");
					}
				} 
			}
		}
	}
	public class Girl extends Thread{
		public void run() {
			while (true) {
				synchronized (Lock.lockb) {
					System.out.println("女孩拿着lockb");
					synchronized (Lock.locka) {
						System.out.println("女孩拿到了locka");
						System.out.println("女孩可以吃了...");
					}
				} 
			}
		}
	}
	public class Test {
		public static void main(String[] args) {
			Boy shaqiang=new Boy();
			Girl xiaofeng=new Girl();
			shaqiang.start();
			xiaofeng.start();
		}
	}
##### 12.6 多线程在单例中的应用

1.单例的实现方式：懒汉式和饿汉式

	其中，懒汉式是线程不安全的，当有多条线程同时访问单例对象时，则会出现多线程临界资源问题

2.代码实现：

	public class KingThread extends Thread{
		public void run() {
			King king=King.getKing();
			System.out.println(Thread.currentThread().getName()+"...."+king.hashCode());
		}
	}
	public class King {	
		private King(){}//1私有化构造方法
		private static King king;//2创建对象
		public static King getKing(){//3创建方法
			if(king==null){//提高性能
				synchronized (King.class) {//耗性能
					if (king == null) {
						king = new King();
					}
				}
			}
			return king;
		}
	}
	public class Test {
		public static void main(String[] args) {
	//		King qianlong1=King.getKing();
	//		King qianlong2=King.getKing();
	//		King qianlong3=King.getKing();
	//		System.out.println(qianlong1.hashCode());
	//		System.out.println(qianlong2.hashCode());
	//		System.out.println(qianlong3.hashCode());
			//创建线程对象
			KingThread k1=new KingThread();
			KingThread k2=new KingThread();
			KingThread k3=new KingThread();
			//启动线程
			k1.start();
			k2.start();
			k3.start();
		}
	}
##### 12.7 线程的通信【生产者与消费者设计模式】

1.原理：它描述的是有一块缓冲区作为仓库，生产者可以将产品放入仓库，消费者可以从仓库中取走产品，解决生产者/消费者问题，我们需要采用某种机制保护生产者和消费者之间的同步，同步问题核心在于：如何保证同一资源被多个线程并发访问时的完整性，常用的方法就是加锁，保证资源在任意时刻只被一个线程访问

2.代码实现

	public class BankCard {
		private int balance;
		private boolean flag;//定义标记，false表示没钱，可以存取 ，true表示有钱,可以取钱
		public int getBalance() {
			return balance;
		}
		public void setBalance(int balance) {
			this.balance = balance;
		}
		public synchronized void save(){//this；存钱
			while(flag==true){	
				try {//等待
					this.wait();//线程停止自己的执行，放弃锁，使自己处于等待状态(在锁外边等待)，让其他线程执行;等待，必须放到同步代码段中执行	
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
			}
			balance=balance+10000;
			System.out.println(Thread.currentThread().getName()+"存了10000，余额是:"+balance);
			flag=true;//有钱了
			//通知
			this.notifyAll();//通知小苍取钱
	        /*notify()：向其他等待的线程发出可执行的通知（唤醒对象所标记外边在等待的一个线程），同时放弃锁，使自己处于等待状态*/
	        /*notifyAll():全部唤醒*/
		}	
		public synchronized void sub(){	//this/*取钱*/
			while(flag==false){
				try {
					this.wait();
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
			}
			balance=balance-10000;
			System.out.println(Thread.currentThread().getName() + "取了10000,余额是:" + balance);
			//修改标记
			flag=false;
			//通知张三存取
			this.notifyAll();
		}	
	}
	
	public class SaveMoney implements Runnable{
		private BankCard card;
		public SaveMoney(BankCard card) {
			this.card=card;
		}
		public void run() {
			for(int i=0;i<10;i++){
					card.save();
			}
		}
	}
	public class SubMoney implements Runnable{
		private BankCard card;
		public SubMoney(BankCard card) {
			this.card=card;
		}
		public void run() {
			for(int i=0;i<10;i++){
					card.sub();
			}
		}
	}
	
	public class Test extends Object{
		public static void main(String[] args) {	
			BankCard  card=new BankCard();//1创建银行卡
			SaveMoney save=new SaveMoney(card);//2存取
			//3取钱
			SubMoney sub=new SubMoney(card);
			//4创建线程对象
			Thread zhangsan=new Thread(save,"张三");
			Thread lisi=new Thread(save,"李四");
			Thread xiaocang=new Thread(sub,"小苍");
			Thread xiaoze=new Thread(sub,"小泽");
			zhangsan.start();
			lisi.start();
			xiaocang.start();
			xiaoze.start();
		}
	}
#### 第十三节 网络编程

##### 13.1 网络编程基础知识

1.所谓网络编程，指的就是在同一个网络中不同机器之间的通信

2.网络参考模型：

 （1）OSI参考模型:包括七层：[物理层]、[数据链路层]、[网络层]、[传输层]、[会话层]、[表示层]和[应用层]

 （2）TCP/IP参考模型：包括四层：

​	 **1.链路层（数据链路层/网络接口层）**：包括操作系统中的设备驱动程序、计算机中对应的网络接口卡

​	 2.网络层（互联网层）：处理分组在网络中的活动，比如分组的选路。

​	 3.传输层：主要为两台主机上的应用提供端到端的通信。

​	 4.应用层（应用层/表示层/会话层）：负责处理特定的应用程序细节。

3.计算机之间通信需要的条件

（1） IP地址：IP地址可以唯一的确定网络上的一个通信实体，但一个通信实体可以有多个通信程序同时提供网络服务，此时还需要使用端口

（2） 端口：数据的发送和接收都需要通过端口出入计算机，端口号用于唯一标识通信实体上进行网络通讯的程序，同一台机器上不能两个程序占用同一个端口；端口号的取值范围：0~65535

（3）通信协议：需要通信的设备之间需要实现相同的通信协议

​	  通信协议分类：

​		网络层IP协议：IPV4和IPV6，互联网协议

​		传输层协议：TCP和UDP

​		应用层协议：HTTP	

​	 TCP协议：TCP（Transmission Control Protocol 传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议。数据大小无限制。

​	 UDP协议：UDP 是User Datagram Protocol的简称， 中文名是用户数据报协议，是TCP/IP参考模型中一种无连接的传输层协议，提供面向事务的简单不可靠信息传送服务,每个包的大小64Kb。

​	 IP协议：[Internet Protocol]网际协议，能使连接到网上的所有计算机网络实现相互通信的一套规则，规定了计算机在因特网上进行通信时应当遵守的规则。IP协议中包含一块非常重要的内容就是为计算机分配了一个唯一标识即IP地址。

##### 13.2 相关类的使用

1.InetAddress类

```java
import java.net.InetAddress;
public class InetAddressDemo {
	public static void main(String[] args) throws Exception {
		//1 表示本机IP
		InetAddress ia1=InetAddress.getLocalHost();//1.1第一种方式
		System.out.println("主机名:"+ia1.getHostName());//主机名:PC-20180226XFFD
		System.out.println("ip地址:"+ia1.getHostAddress());//ip地址:10.9.156.50
		//1.2使用LAPTOP-GQCKSGUC获取
		System.out.println("----");
		InetAddress ia2=InetAddress.getByName("LAPTOP-GQCKSGUC");
		System.out.println("主机名:"+ia2.getHostName());
		System.out.println("ip地址:"+ia2.getHostAddress());
		//1.3使用ip地址
		System.out.println("---");
		InetAddress ia3=InetAddress.getByName("10.9.156.87");
		System.out.println("主机名:"+ia3.getHostName());
		System.out.println("ip地址:"+ia3.getHostAddress());
		//1.4使用localhost或127.0.0.1获取
		System.out.println("---");
		InetAddress ia4=InetAddress.getByName("127.0.0.1");
		System.out.println("主机名:"+ia4.getHostName());
		System.out.println("ip地址:"+ia4.getHostAddress());
		
		//2 表示局域网
		InetAddress ia5=InetAddress.getByName("10.9.156.100");
		System.out.println("主机名:"+ia5.getHostName());
		System.out.println("ip地址:"+ia5.getHostAddress());
		
		//3表示外网
		InetAddress ia6=InetAddress.getByName("www.baidu.com");
		System.out.println("主机名:"+ia6.getHostName());
		System.out.println("ip地址:"+ia6.getHostAddress());
		//4获取一个主机对应的所有ip
		System.out.println("-----------获取一个主机对应的所有ip---------");
		InetAddress[] ias=InetAddress.getAllByName("LAPTOP-GQCKSGUC");
		//InetAddress[] ias=InetAddress.getAllByName("www.baidu.com");
		for (InetAddress inetAddress : ias) {
			System.out.println("主机名:"+inetAddress.getHostName());
			System.out.println("ip地址:"+inetAddress.getHostAddress());
		}	
	}
}
```

2.URLEncoder类和URLDecoder类

```java
import java.net.URLEncoder;
public class EncoderDemo {
	public static void main(String[] args) throws Exception {
		String s=URLEncoder.encode("好久不见","utf-8");//URL编码 
		System.out.println(s);//%E5%A5%BD%E4%B9%85%E4%B8%8D%E8%A7%81
		String con="好久不见";
		byte[] bs=con.getBytes("utf-8");
		for (byte b : bs) {
			System.out.printf("%X",b);//E5A5BDE4B985E4B88DE8A781
		}
	}
}
import java.net.URLDecoder;
public class DecodeDemo {
	public static void main(String[] args) throws Exception{
		String s=URLDecoder.decode("%E5%A5%BD%E4%B9%85%E4%B8%8D%E8%A7%81", "utf-8");
		System.out.println(s);
	}
}
```

##### 13.3 基于TCP的网络编程

1.TCP:

（1）概念:TCP，Transmission Control Protocol，传输控制协议，基于字节流的传输层通信协议。

（2）特点：a.安全的	b.面向连接  c.传输数据大小限制，一旦连接建立，双方可以按统一的格式传输大的数据。 （3）TCP的三次握手：a.客户端向服务端发送一个请求  b.服务端收到请求后，回客户端一个响应 c.客户端向收到服务端的响应后，回服务端一个确认信息

2.Socket（套接字）通信模型

Socket是操作系统提供的一种底层的通信机制，Java仅仅是对底层的socket的一种封装。供开发人员方便使用。

3.客户端发送消息，服务端回复消息

```java
/*
 * TCP协议的服务器端
 */
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.net.ServerSocket;
import java.net.Socket;
public class TcpServer {
	public static void main(String[] args) throws Exception {	
		ServerSocket listener=new ServerSocket(10010);//1创建侦听套接字
		System.out.println("服务器已启动.........");//2侦听
		Socket socket = listener.accept();	
		InputStream is=socket.getInputStream();//3获取输入输出流
		OutputStream os=socket.getOutputStream();
		BufferedReader br=new BufferedReader(new InputStreamReader(is, "utf-8"));
		BufferedWriter bw=new BufferedWriter(new OutputStreamWriter(os, "utf-8"));
		//4读取
		String con=br.readLine();// \r\n
		System.out.println("客户说:"+con);
		//5回复
		bw.write("十分想念");
		//6关闭
		bw.close();
		br.close();
		socket.close();
		listener.close();
	}
}

/*TCP客户端
 */
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.net.Socket;
public class TcpClient {
	public static void main(String[] args) throws Exception{		
		Socket client=new Socket("10.9.156.87", 10010);//1创建客户端套接字
		OutputStream os=client.getOutputStream();//2获取输出输入流
		InputStream is=client.getInputStream();
		BufferedWriter bw=new BufferedWriter(new OutputStreamWriter(os,"utf-8"));
		BufferedReader br=new BufferedReader(new InputStreamReader(is, "utf-8"));
		//3发送
		bw.write("好久不见了.....");
		bw.newLine();
		bw.flush();//刷新缓冲
		//4接收回复
		String reply=br.readLine();
		System.out.println("服务器回复:"+reply);
		//5关闭
		bw.close();
		br.close();
		client.close();
	}
}
```

4.客户端上传文件到服务端【以图片为例】

```java
/*
 * 服务器:使用Tcp接收客户端发送的文件
 */
public class FileServer {
	public static void main(String[] args) throws Exception {	
		ServerSocket listener=new ServerSocket(10011);//1创建ServerSocket	
		System.out.println("服务器已准备就绪...");//2开始侦听
		Socket socket = listener.accept();
		InputStream is=socket.getInputStream();//3获取输入流
		byte[] buf=new byte[1024*4];
		int len=0;
		//4处理
		FileOutputStream fos=new FileOutputStream("d:\\aaa.jpg");
		while((len=is.read(buf))!=-1){
			fos.write(buf,0,len);
		}
		//5关闭
		is.close();
		fos.close();
		socket.close();
		listener.close();
		System.out.println("接收完毕..........");	
	}
}
/*
 * 客户端: 读取硬盘中一个文件，发送给服务器
 */
public class FileClient {
	public static void main(String[] args)  throws Exception{
		//1创建客户端套接字
		Socket client=new Socket("10.9.156.87", 10011);
		//2获取流
		OutputStream os=client.getOutputStream();
		//3创建文件输入流
		FileInputStream fis=new FileInputStream("d:\\timg.jpg");
		byte[] buf=new byte[1024*4];
		int len=0;
		//4处理
		while((len=fis.read(buf))!=-1){
			os.write(buf,0,len);
		}
		//5关闭
		os.close();
		fis.close();
		client.close();
		System.out.println("发送完毕................");
	}
}
```

5.客户端从服务端下载文件【以图片为例】

```java
/*
 * 服务器端，服务器给客户发送文件
 */
public class FileServer {
	public static void main(String[] args) throws Exception{
		ServerSocket listener=new ServerSocket(12306);//1创建服务器套接字
		System.out.println("服务器已启动");
		Socket socket = listener.accept();//2侦听
		//3输出流
		System.out.println("开始发送数据");
		OutputStream os = socket.getOutputStream();
		FileInputStream fis=new FileInputStream("d:\\timg.jpg");
		byte[] buf=new byte[1024*4];
		int len=0;
		while((len=fis.read(buf))!=-1){
			os.write(buf,0,len);
		}
		//4关闭
		fis.close();
		os.close();
		socket.close();
		listener.close();
		System.out.println("发送完毕.....");	
	}
}
/*
 * 客户端，客户端下载服务器的文件
 */
public class FileClient {
	public static void main(String[] args)  throws Exception{
		//1创建client
		Socket client=new Socket("10.9.156.87", 12306);
		//2获取输入流
		InputStream is = client.getInputStream();
		byte[] buf=new byte[1024*4];
		int len=0;
		FileOutputStream fos=new FileOutputStream("d:\\abc.jpg");
		while((len=is.read(buf))!=-1){
			fos.write(buf,0,len);	
		}
		//3关闭
		fos.close();
		is.close();
		client.close();
		System.out.println("下载完毕.......");
	}
}
```

6.多个客户端和一个服务端通信【线程版本】

```java
/*
 * 服务器，接收多个客户端请求
 * 主线程: 负责接收请求
 * 子线程: 负责接收数据(得到socket)
 */
public class ChatServer {
	public static void main(String[] args){
		//1创建侦听套接字
		try {
			ServerSocket listener=new ServerSocket(8888);
			System.out.println("服务器已启动...");
			while(true){			
				Socket socket=listener.accept();
				ChatThread c=new ChatThread(socket);
				c.start();
			}
		} catch (IOException e) {
			e.printStackTrace();
		}		
	}
}
/*
 * 处理客户发送的数据线程类
 */
public class ChatThread extends Thread{
	private Socket socket;
	public ChatThread(Socket socket) {
		this.socket=socket;
	}
	public void run() {
		//接收数据
		try {
			InputStream is = socket.getInputStream();
			BufferedReader br=new BufferedReader(new InputStreamReader(is, "utf-8"));
			while(true){
				String s=br.readLine();
				System.out.println(socket.getInetAddress().getHostAddress()+"说:"+s);
				if(s!=null&&s.equals("886")){
					System.out.println(socket.getInetAddress().getHostAddress()+"退出了聊天");
					break;
				}
			}
		} catch (Exception e) {
			System.out.println(socket.getInetAddress().getHostAddress()+"退出了聊天");
		}
	}
}
public class ChatClient {
	public static void main(String[] args) throws Exception {
		//1创建Client
		Socket client=new Socket("10.9.156.87", 8888);
		//2获取输出流
		OutputStream os=client.getOutputStream();
		BufferedWriter bw=new BufferedWriter(new OutputStreamWriter(os,"utf-8"));
		//3发送
		Scanner input=new Scanner(System.in);
		while(true){
			String s=input.nextLine();
			bw.write(s);
			bw.newLine();
			bw.flush();
			if(s.equals("886")){
				break;
			}
		}
		bw.close();
		client.close();
		System.out.println("退出了聊天");
	}
}
```

7.TCP实现注册登录

```
/*服务器 注册 客户端发送的注册数据 zhangsan,123 登录
 */
public class Server {
	private Properties userPros;
	public Server() {
		userPros=new Properties();
		//判断硬盘上有没有文件
		File file=new File("d:\\userPros.properties");
		if(file.exists()){
			//加载
			try {
				userPros.load(new FileReader(file));
			} catch (Exception e) {
				System.out.println("加载文件失败");
			}
		}
	}
	//注册
	public void regiserUser() {
			new Thread(){
				@Override
				public void run() {
					ServerSocket listener;
					try {
						listener = new ServerSocket(6666);
						System.out.println("注册线程已启动....");
						while (true) {
							Socket socket = listener.accept();
							new RegThread(socket, userPros).start();
						}
					} catch (IOException e) {
						e.printStackTrace();
					}
				}
			}.start();		
	}
	//登录
	public void login(){
		//创建侦听
		try {
			ServerSocket listener=new ServerSocket(7777);
			//启动
			System.out.println("登录线程已启动....");
			Socket socket=listener.accept();
			//输入流
			InputStream is = socket.getInputStream();
			OutputStream os=socket.getOutputStream();
			BufferedReader br=new BufferedReader(new InputStreamReader(is, "utf-8"));
			BufferedWriter bw=new BufferedWriter(new OutputStreamWriter(os,"utf-8"));
			String con=br.readLine();
			String[] cons=con.split(",");
			String username=cons[0];
			String pwd=cons[1];	
			if(userPros.containsKey(username)){
				if(userPros.getProperty(username).equals(pwd)){
					//给客户端回复
					bw.write("登录成功...");
					bw.newLine();
					bw.flush();
				}else{
					bw.write("登录失败...密码错误");
					bw.newLine();
					bw.flush();
				}
			}else{
				bw.write("登录失败...账号不存在");
				bw.newLine();
				bw.flush();
			}
			bw.close();
			br.close();
			socket.close();
			listener.close();	
		} catch (IOException e) {
			e.printStackTrace();
		}
	}
}

public class TestServer {
	public static void main(String[] args) {
		Server server=new Server();
		new Thread(){
			public void run() {
				server.regiserUser();
			};
		}.start();
		
		new Thread(){
			public void run() {
				server.login();
			};
		}.start();
	}
}

public class TestClient {
	public static void main(String[] args) {
		Client client=new Client();
		System.out.println("欢迎进入xxx系统");
		Scanner input=new Scanner(System.in);
		String answer=null;
	
		do {
			System.out.println("1 注册  2登录");
			int choice = input.nextInt();
			switch (choice) {
			case 1:
				client.reg();
				break;
			case 2:
				client.log();
				break;
			default:
				break;
			}
			System.out.println("是否继续y/n");
			answer=input.next();
		} while (answer.equals("y"));
		System.out.println("欢迎下次光临");
		
	}
}
public class RegThread extends Thread{
	private Socket socket;
	private Properties userPros;
	public  RegThread(Socket socket,Properties userPros) {
		this.socket=socket;
		this.userPros=userPros;
	}
	public void run() {
		try {
			BufferedReader br;
			BufferedWriter bw;
			InputStream is = socket.getInputStream();
			OutputStream os = socket.getOutputStream();
			br = new BufferedReader(new InputStreamReader(is, "utf-8"));
			bw = new BufferedWriter(new OutputStreamWriter(os, "utf-8"));
			String con = br.readLine();
			String[] cons = con.split(",");
			String username = cons[0];
			String pwd = cons[1];
			//判断用户名是否存在
			if (userPros.containsKey(username)) {
				bw.write("用户已存在,请重新输入...");
				bw.newLine();
				bw.flush();
			} else {
				//保存数据
				userPros.setProperty(username, pwd);
				//保存到硬盘
				userPros.store(new FileWriter("d:\\userPros.properties"), "用户信息");
				//给客户端回复
				bw.write("注册成功...");
				bw.newLine();
				bw.flush();
			} 
			bw.close();
			br.close();
			socket.close();
		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}
}

/*
 * 注册和登录
 */
public class Client {
	/*
	 * 注册
	 */
	public void reg(){
		//1创建Client
		try {
			Socket client=new Socket("10.9.156.87", 6666);
			Scanner input=new Scanner(System.in);
			System.out.println("请输入用户名");
			String username=input.next();
			System.out.println("请输入密码");
			String pwd=input.next();
			String con=username+","+pwd;
			//2获取流
			OutputStream os = client.getOutputStream();
			InputStream is=client.getInputStream();
			BufferedWriter bw=new BufferedWriter(new OutputStreamWriter(os,"utf-8"));
			BufferedReader br=new BufferedReader(new InputStreamReader(is, "utf-8"));
			bw.write(con);
			bw.newLine();
			bw.flush();
			//3接收回复
			String reply=br.readLine();
			System.out.println(reply);
			//4关闭
			bw.close();
			br.close();
			client.close();	
		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}
	//登录
	public void log(){
		//1创建Client
			try {
				Socket client=new Socket("10.9.156.87", 7777);
				Scanner input=new Scanner(System.in);
				System.out.println("请输入用户名");
				String username=input.next();
				System.out.println("请输入密码");
				String pwd=input.next();
				String con=username+","+pwd;
				//2获取流
				OutputStream os = client.getOutputStream();
				InputStream is=client.getInputStream();
				BufferedWriter bw=new BufferedWriter(new OutputStreamWriter(os,"utf-8"));
				BufferedReader br=new BufferedReader(new InputStreamReader(is, "utf-8"));
				bw.write(con);
				bw.newLine();
				bw.flush();
				//3接收回复
				String reply=br.readLine();
				System.out.println(reply);
				//4关闭
				bw.close();
				br.close();
				client.close();
					
				} catch (Exception e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
	}	
}
```

##### 13.4 UDP编程(了解)

1.概念：

​	User Datagram Protocol的简称，用户数据包协议，提供面向事务的简单不可靠信息传送服务。

2.特点：

​	a.不安全； b.无连接  c.效率高  d.UDP传输数据时是有大小限制的，每个被传输的数据报必须限定在64KB之内

3.DatagramSocket和DatagramPacket

```
/*
 * 发送方
 * 
 */
public class Sender {
	public static void main(String[] args) throws Exception{
		//1创建DatagramSocket
		DatagramSocket ds=new DatagramSocket();
		//2创建DatagramPacket(发送)
		String con="送给你个生日礼物:鲜花"; // 最大是64kb
		DatagramPacket dp=new DatagramPacket(con.getBytes(), con.getBytes().length, InetAddress.getByName("10.9.156.255"), 1314);//ip指定接收方的ip地址；端口号表示的是指定的接收方的端口号，而发送方的端口是由系统自动分配的;
		//3发送
		ds.send(dp);
		//4关闭
		ds.close();
		System.out.println("发送完毕");
	}
}
/*
 * 负责接收
 * 接收方
 */
public class Receiver {
	public static void main(String[] args) throws Exception {
		//1创建datagramSocket
		DatagramSocket ds=null;
		try {
			ds = new DatagramSocket(1314);
			//2创建接收数据报包
			byte[] buf = new byte[1024 * 4];
			DatagramPacket dp = new DatagramPacket(buf, buf.length);
			//3接收
			System.out.println("准备接收....");
			while (true) {
				ds.receive(dp);
				//4处理数据
				String con = new String(dp.getData(), 0, dp.getLength());
				System.out.println("发送说:" + con);
			} 
		} finally {
			//5关闭
			ds.close();
		}		
	}
}
```



#### 第十四节 NIO

##### 14.1 NIO简介

1.java.nio全称java non-blocking IO，是指jdk1.4 及以上版本里提供的新api（New IO） ，为所有的原始类型（boolean类型除外）提供[缓存](https://baike.baidu.com/item/%E7%BC%93%E5%AD%98)支持的数据容器，使用它可以提供非阻塞式的高伸缩性网络。

2.Java NIO 由以下几个核心部分组成：

Channels：通道         Buffers：缓冲区      Selectors：选择器

3.NIO和普通IO的区别：

NIO：面向缓冲区；非阻塞IO；有选择器

IO：面向流；阻塞IO，无选择器

4.Channel 和 Buffer：

​     基本上，所有的 IO 在NIO 中都从一个Channel 开始。Channel 有点象流。 数据可以从Channel读到Buffer中，也可以从Buffer 写到Channel中。

5.JAVA NIO中的一些主要Channel的实现：

  FileChannel；DatagramChannel；SocketChannel；ServerSocketChannel

6.Java NIO里关键的Buffer实现：

ByteBuffer；CharBuffer；DoubleBuffer；FloatBuffer；IntBuffer；LongBuffer；ShortBuffer

7.Selector：

   Selector允许单线程处理多个 Channel。如果你的应用打开了多个连接（通道），但每个连接的流量都很低，使用Selector就会很方便。要使用Selector，得向Selector注册Channel，然后调用它的select()方法。这个方法会一直阻塞到某个注册的通道有事件就绪。一旦这个方法返回，线程就可以处理这些事件。

##### 14.2 Buffer

1.Buffer的使用：

   Java NIO中的Buffer用于和NIO通道进行交互。如你所知，数据是从通道读入缓冲区，从缓冲区写入到通道中的，缓冲区本质上是一块可以写入数据，然后可以从中读取数据的内存。这块内存被包装成NIO Buffer对象，并提供了一组方法，用来方便的访问该块内存。

2.Buffer的基本用法：

​	使用Buffer读写数据一般遵循以下四个步骤：（1）写入数据到Buffer（2）调flip()方法（3）从Buffer中读取数据（4）调用clear()方法或者compact()方法

```
/*
 * 缓冲区的使用
 * buffer中属性： position :位置；limit：限制；capacity:容量；position<=limit<=capacity
 */
public class BufferDemo {
	public static void main(String[] args) {
		//1创建缓冲区
		ByteBuffer buffer=ByteBuffer.allocate(1024);//1.1 创建缓冲区(jvm的堆中 间接缓冲区（空间有限，速度慢）)	,缓冲区大小为1024字节
		//ByteBuffer buffer2=ByteBuffer.allocateDirect(1024);//1.2创建缓冲区(直接缓冲区，没有堆中，(空间比较大，速度快，缺点：不受jvm控制，创建和销毁耗性能))
		//2写入数据
		System.out.println("写入数据之前");
		System.out.println("position:"+buffer.position()+" limit:"+buffer.limit()+" capacity:"+buffer.capacity());//position:0 ;limit:1024 ;capacity:1024
		buffer.put("helloworld".getBytes());
		System.out.println("写入数据之后");//当向buffer写入数据时，buffer会记录下写了多少数据
		System.out.println("position:"+buffer.position()+" limit:"+buffer.limit()+" capacity:"+buffer.capacity());//position:10 limit:1024 capacity:1024
		//3取数据
		buffer.flip();//一旦要读取数据，需要通过flip()方法将Buffer从写模式切换到读模式。
		System.out.println("设置读取模式后");//设置为读模式，指针会回到可读取数据的开头，所以position会变为0，同时限制可读的范围，防止读到空字节，所以limit会变成输入数据的长度10 
		System.out.println("position:"+buffer.position()+" limit:"+buffer.limit()+" capacity:"+buffer.capacity());//position:0 limit:10 capacity:1024；
		for(int i=0;i<buffer.limit();i++){
			byte b=buffer.get();
			System.out.println((char)b);
		}
		System.out.println("读取完毕");
		System.out.println("position:"+buffer.position()+" limit:"+buffer.limit()+" capacity:"+buffer.capacity());//position:10 limit:10 capacity:1024
		//再读取一次
		buffer.rewind();//倒回
		for(int i=0;i<buffer.limit();i++){
			byte b=buffer.get();
			System.out.println((char)b);
		}
		System.out.println("第二遍读取完毕");
		System.out.println("position:"+buffer.position()+" limit:"+buffer.limit()+" capacity:"+buffer.capacity());//position:10 limit:10 capacity:1024
		//5清空缓冲区:一旦读完了所有的数据，就需要清空缓冲区，让它可以再次被写入。
		buffer.clear();//有两种方式清空缓冲区：调用clear()或compact()方法。clear()方法会清空整个缓冲区。compact()方法只会清除已经读过的数据。任何未读的数据都被移到缓冲区的起始处，新写入的数据将放到缓冲区未读数据的后面。
		System.out.println("清空之后");
		System.out.println("position:"+buffer.position()+" limit:"+buffer.limit()+" capacity:"+buffer.capacity());	
	}
}

/*
 * 0=<mark<=position<=limit<=capacity;mark和reset的使用
 */
public class BufferDemo2 {
	public static void main(String[] args) {		
		ByteBuffer buf=ByteBuffer.allocate(10);//1创建缓冲区	
		buf.put("hello".getBytes());//2放入数据	
		buf.flip();//3切换读模式
		byte[] b=new byte[2];//将要读取的数据放入字节数组，本次设置两个字节
		buf.get(b);//把数据读到b中
		for (byte c : b) {
			System.out.println((char)c);
		}
		System.out.println("position:"+buf.position());//position:2
		//4做一个标记
		buf.mark();
		//5再读取两个字节
		buf.get(b);
		for (byte c : b) {
			System.out.println((char)c);
		}
		System.out.println("position:"+buf.position());//position:4
		//6重置
		buf.reset();//返回到标记处
		System.out.println("重置之后........");
		System.out.println("position:"+buf.position());//position:2
	}
}
```

##### 14.3 FileChannel的使用

```java
/*
 * 文件通道；读
 */
public class FileChannelDemo {
	public static void main(String[] args) throws Exception{
		RandomAccessFile raf=new RandomAccessFile("d:\\aaa.txt", "rw");//1创建流
		FileChannel fileChannel=raf.getChannel();//2获取通道
		ByteBuffer buf=ByteBuffer.allocate(1024);//3创建缓冲区
		//4读取
//		int len=fileChannel.read(buf);//把文件中数据放入缓冲区；len收到的返回值是数据的字节数
//		//5切换成读模式
//		buf.flip();
//		
//		for(int i=0;i<len;i++){
//			System.out.print((char)buf.get());
//		}
		int len=0;
		while((len=fileChannel.read(buf))!=-1){
			buf.flip();//切换成读模式
			String s=new String(buf.array(), 0, len);
			System.out.println(s);
			buf.clear();//positon=0 
		}
		//6关闭
		fileChannel.close();
		raf.close();
	}
}

/*
 * FileChannel写
 */
public class FileChannelDemo2 {
	public static void main(String[] args) throws Exception{
		RandomAccessFile raf=new RandomAccessFile("d:\\bbb.txt", "rw");//1创建RandomeAccessFile
		FileChannel channel = raf.getChannel();//2获取通道
		ByteBuffer buf=ByteBuffer.allocate(1024);//3创建缓冲区
		//3写
		buf.put("hello world 世界你好".getBytes());
		//4切换成读取
		buf.flip();
		while(buf.hasRemaining()) {
		    channel.write(buf);
		}
		//5关闭
		channel.close();
		raf.close();
	}
}

```

  文件复制：

```java
public class FileCopy {
	public static void main(String[] args) throws Exception{
		//1jdk1.7 FileChannel.open
		FileChannel readChannel=FileChannel.open(Paths.get("d:\\timg.jpg"), StandardOpenOption.READ);
		FileChannel writeChannel=FileChannel.open(Paths.get("d:\\timg2.jpg"), StandardOpenOption.CREATE,StandardOpenOption.WRITE);
		//2写
		ByteBuffer buf=ByteBuffer.allocate(1024*4);
		while((readChannel.read(buf))!=-1){
			buf.flip();
			writeChannel.write(buf);
			buf.clear();//清空之后可以接着写
		}
		//3关闭
		readChannel.close();
		writeChannel.close();
		System.out.println("复制完毕");	
	}
}

public class FileCopy2 {
	public static void main(String[] args)throws Exception {
		//1创建FileChannel
		FileChannel fileChannel1=FileChannel.open(Paths.get("d:\\Java虚拟机.pdf"),StandardOpenOption.READ);
		FileChannel fileChannel2= FileChannel.open(Paths.get("d:\\Java2.pdf"),StandardOpenOption.CREATE,StandardOpenOption.WRITE);
		//2创建内存映射（直接缓冲区）
		MappedByteBuffer buffer=fileChannel1.map(MapMode.READ_ONLY, 0, fileChannel1.size());
		fileChannel2.write(buffer);
		//3关闭
		fileChannel1.close();
		fileChannel2.close();
		System.out.println("复制完毕");
	}
}
```

##### 14.4 SocketChannel和ServerSocketChannel使用

**选择器（Selector)：**Selector选择器类管理着一个被注册的通道集合的信息和它们的就绪状态。通道是和选择器一起被注册的，并且使用选择器来更新通道的就绪状态。

**可选择通道(SelectableChannel)：**SelectableChannel这个抽象类提供了实现通道的可选择性所需要的公共方法。它是所有支持就绪检查的通道类的父类。因为FileChannel类没有继承SelectableChannel因此是不是可选通道，而所有socket通道都是可选择的，SocketChannel和ServerSocketChannel是SelectableChannel的子类。

**选择键(SelectionKey)：**选择键封装了特定的通道与特定的选择器的注册关系。选择键对象被SelectableChannel.register()返回并提供一个表示这种注册关系的标记。选择键包含了两个比特集(以整数的形式进行编码)，选择键支持四种操作类型：

- Connect 连接
- Accept 接受
- Read 读
- Write 写

Java中定义了四个常量来表示这四种操作类型：

> SelectionKey.OP_CONNECT 
> SelectionKey.OP_ACCEPT 
> SelectionKey.OP_READ 
> SelectionKey.OP_WRITE

```java
/*
 * 使用NIO实现Tcp服务端
 */
public class Server {
	public static void main(String[] args){
		//1创建ServerSocketChannel
		ServerSocketChannel listener=null;
		try {
			listener = ServerSocketChannel.open();
			//2绑定地址
			listener.bind(new InetSocketAddress("10.9.156.87", 9999));
			//3设置为非阻塞式
			listener.configureBlocking(false);
			//4创建选择器
			Selector selector=Selector.open();
			//5把listener通道注册到selector
			listener.register(selector,SelectionKey.OP_ACCEPT);
			//6轮询选择器
			System.out.println("服务器已启动....");
			while(selector.select()>0){//判断选择器是否有事件发生，如果没有则阻塞
				Iterator<SelectionKey> it = selector.selectedKeys().iterator();
				while(it.hasNext()){
					SelectionKey selectionKey=it.next();
					if(selectionKey.isAcceptable()){//表示有客户已经连接上
						//7客户端通道
						 SocketChannel channel = listener.accept();
						 //8设置为非阻塞式
						 channel.configureBlocking(false);
						 //9客户端channel注册到选择器
						 channel.register(selector, SelectionKey.OP_READ);
					}else if(selectionKey.isReadable()){//通道是不是有数据
						//10获取channel
						SocketChannel channel =(SocketChannel) selectionKey.channel();
						//11读取
						ByteBuffer buf=ByteBuffer.allocate(1024);
						ByteBuffer buffer = ByteBuffer.allocate(1024);
						int len = 0;
						try {
							while((len = channel.read(buffer)) > 0 ){
								buffer.flip();								System.out.println(channel.socket().getInetAddress().getHostAddress()+"说:"+new String(buffer.array(), 0, len));
								buffer.clear();
							}
						} catch (Exception e) {							System.out.println(channel.socket().getInetAddress().getHostAddress()+"退出了...");
							channel.close();						
						}
					}
					//12移除事件
					it.remove();
				}
			}
		} catch (Exception e) {
			
		}finally {
			
			try {
				if(listener!=null){
					listener.close();
				}
			} catch (IOException e) {
				e.printStackTrace();
			}
		}	
	}
}


public class Client {
	public static void main(String[] args) throws Exception{
		//1创建SocketChannel
		SocketChannel client=SocketChannel.open(new InetSocketAddress("10.9.156.87", 9999));
		//2设置非阻塞模式
		client.configureBlocking(false);
		//3写
		ByteBuffer buf=ByteBuffer.allocate(1024);
		Scanner input=new Scanner(System.in);
		while(input.hasNext()){//如果有数据则返回true,没有数据等待输入
			String s=input.nextLine();
			buf.put(s.getBytes());
			buf.flip();
			client.write(buf);
			buf.clear();
			if(s.equals("886")){
				break;
			}
		}
		//4关闭
		client.close();
	}
}
```

#### 第十五节 反射

##### 15.1 反射（Reflection）

1.反射概念和引入反射的目的：

（1）概念：

​	反射就是把Java类中的各种成分映射成一个个的java对象。例如，一个类有：成员变量，方法，构造方法，包等等信息，利用反射技术可以对一个类进行解剖，把各个组成部分映射成一个个对象。

（2）反射引入目的：

​	我公司定义了一组接口，然后第三方公司按照我公司的接口实现了一套功能，然后交给我们，但是我们公司的项目已经结束，如何实现动态加载第三方公司提供的功能。

（3）反射常用类：

​	Class类—可获取类和类的成员信息 ；

​	Field类—可访问类的属性 ；

​	Method类—可调用类的方法 ；

​	Constructor类—可调用类的构造方法

（4）使用反射的基本步骤：

​	a.导入java.lang.reflect.*

​	b.获得需要操作的类的Java.lang.Class对象

​	c.调用Class的方法获取Field、Method等对象

​	d.使用反射API进行操作(设置属性﹑调用方法）

（5）反射技术的优点和缺点

​	优点：a.提高了Java程序的灵活性和扩展性，降低了耦合性，提高自适应能力

​	b.允许程序创建和控制任何类的对象，无需提前硬编码目标类

​	缺点：a.性能问题  b.代码维护问题

##### 15.2 Class类

1.Class类是反射机制的起源和入口（Class类继承自Object类）

​    每个类都有自己的Class对象;用于获取与类相关的各种信息;提供了获取类信息的相关方法。

2.Class类存放类的结构信息：	

- 类名
- 父类﹑接口
- 方法﹑构造方法﹑属性
- 注释

```

```

##### 15.3 获得类的对象、方法、属性

```
/**
 *创建student类
 */
public class Student {
	private String name;
	private int age;
	private String sex;
	private static String country;
	static{
		country="中国";
	}
	public Student() {
		System.out.println("默认构造方法执行了....");
	}
	public Student(String name, int age, String sex) {
		super();
		this.name = name;
		this.age = age;
		this.sex = sex;
		System.out.println("带参构造方法执行了....");	
	}
	public void show(){
		System.out.println("姓名:"+name+" 年龄:"+age+" 性别："+sex);
	}
	public void show(String say){
		System.out.println(name+"说："+say);
	}
	public String getInfo(){
		return "学生信息:"+name+" 年龄："+age+" 性别："+sex;
	}
	public static void print(){
		System.out.println("这是一个静态方法.............");
	}
	private void sayHi(){
		System.out.println("这是一个私有方法");
	}	
}

/**
 * 使用反射操作Student
 */
public class Demo1 {
	public static void main(String[] args) throws Exception {
		getClassObj();//获得类的类对象
		getConstructor();//获得类的构造方法
		getMethod();//获得类的普通方法
		getField();//获得类的属性
	}
	
	（1）/* 获取一个类的类对象*/
	public static void getClassObj() throws Exception{
		//1第一种方式 通过对象的getClass方法获取
		Student zhangsan=new Student();
		Class<?> class1 = zhangsan.getClass();
		System.out.println(class1.hashCode());
		//2第二种方式，通过类名.class属性
		Class<?> class2=Student.class;
		System.out.println(class2.hashCode());
		//3第三种方式，通过Class的forName方法获取
		Class<?> class3=Class.forName("com.qf.day23.Student");
		System.out.println(class3.hashCode());	
	}
	
	（2）/* 获取构造方法*/
	public static void getConstructor() throws Exception{
		//1获取类对象
		Class<?> class1 = Class.forName("com.qf.day23.Student");
		//2获取所有构造方法(公开的)
		//Constructor<?>[] constructors = class1.getConstructors();
		//3获取私有、公开的所有构造方法
		Constructor<?>[] constructors = class1.getDeclaredConstructors();
		for (Constructor<?> con : constructors) {
			System.out.println(con);
		}
		//3获取一个
		Constructor<?> con2=class1.getConstructor();
Constructor<?>con3=class1.getConstructor(String.class,int.class,String.class);
		System.out.println(con2);
		System.out.println(con3);
		//4创建对象
		Object lisi = con2.newInstance();
		Object wangwu=con3.newInstance("王五",20,"男");
	}
	
	（3）/* 获取普通方法*/
	public static void getMethod() throws Exception{
		//1创建Student的类对象
		Class<?> class1 = Class.forName("com.qf.day23.Student");
		//2获取普通方法 
		//2.1获取所有的公开的方法，包括继承的
		//Method[] methods = class1.getMethods();
		//2.2获取所有的方法，不包括继承的
		Method[] methods = class1.getDeclaredMethods();
		for (Method method : methods) {
			System.out.println(method);
		}
		
		//2.3获取一个方法--->无参无返回值
		Method method=class1.getMethod("show"); 
		//2.4调用方法
		Object lisi=class1.newInstance();//默认调用无参构造方法创建对象
		method.invoke(lisi); //lisi.show();
		//2.5获取一个方法---->带参数的方法
		Method method2=class1.getMethod("show", String.class);
		method2.invoke(lisi, "你是谁啊，不认识你");
		//2.6获取一个带返回值的方法
		Method method3=class1.getMethod("getInfo");
		String result=(String) method3.invoke(lisi);
		System.out.println(result);
		//2.7获取静态方法 
		Method method4=class1.getMethod("print");//正常调用静态方法，类名.print 
		method4.invoke(null);
		//2.8获取私有方法
		Method method5=class1.getDeclaredMethod("sayHi");
		//访问权限无效
		method5.setAccessible(true);
		method5.invoke(lisi);	
	}
	
	（4）/*获取属性*/
	public static void getField() throws Exception{
		//1获取类对象
		Class<?> class1=Class.forName("com.qf.day23.Student");
		//2获取所有属性
		/*Field[] declaredFields = class1.getDeclaredFields();
		for (Field field : declaredFields) {
			System.out.println(field);
		}*/
		//获取单个属性
		Field nameField = class1.getDeclaredField("name"); 
		//3赋值
		Object wangwu = class1.newInstance();
		nameField.setAccessible(true);
		nameField.set(wangwu, "王五");
		//4获取
		Object result=nameField.get(wangwu);
		System.out.println(result);
		//5获取静态属性
		Field countryField = class1.getDeclaredField("country");
		countryField.setAccessible(true);
		countryField.set(null, "china");
		System.out.println(countryField.get(null));
		
		//6获取包
		Package package1 = class1.getPackage();
		System.out.println(package1.getName());
	}
}

	（5）/*反射main方法*/
public class HelloWorld {
	public static void main(String[] args) {
		System.out.println("hello world");
		for (String string : args) {
			System.out.println(string);
		}
	}
}
public class Demo2 {
	public static void main(String[] args) throws Exception{
		Class<?> class1=Class.forName("com.qf.day23.HelloWorld");
		Method method=class1.getMethod("main", String[].class);
		method.invoke(null,(Object)new String[]{"xxx","yyy","zzz"});
	}
}
```

##### 15.4 XML语言

1.概述：可扩展性标记语言（eXtensible Markup Language）,文件扩展名.xml，用来描述、传输数据，可用于持久化存储数据，跨平台、跨操作系统的数据交互，数据配置

2.xml语法：

```
/*编写XML文档时，要先使用文档声明，声明XML文档的类型（版本）和字符编码*/
<?xml version="1.0" encoding="utf-8" ?>
//开始标签(跟标签)
<Person>
	<sanguo>//子标签
    	<ID>1002</ID>
    	<Name>曹操</Name>
    	<Age>20</Age>
    	<!-- -->//xml文件的注释格式<!--注释-->；xml声明之前不能有注释，注释不许嵌套
    	<ID>1001</ID>
    	<Name>周瑜</Name>
    	<Age>22</Age>
    </sanguo>
//结束标签
</Person>
注：（1）对于XML标签中出现的所有空格和换行，XML解析程序都会当作标签内容进行处理。例如：下面两段内容的意义是不一样的。
<Name>
	冰冰
</Name>
和
<Name>冰冰</Name>
（2）xml元素的名称不能以数字或标点符号开始，也不能以‘‘xml’’开始；不能包含空格。
 (3)使用浏览器验证文件格式有效性
（4）编写XML文件时记得修改文件扩展名
```

3.良好的XML文档符合以下条件：

```
必须有XML声明语句  <?xml version="1.0" encoding="utf-8" ?> 
必须有且仅有一个根元素
标签大小写敏感
属性值用双引号或单引号:<Name>周瑜</Name>等同于<person name=“周瑜”>
标签成对
元素正确嵌套
```

##### 15.4 XML解析

1.解析方式：

（1）DOM解析：(Document Object Model) 文档对象模型，使用DOM4J(DOM For Java)实现DOM解析 ，易于操作，遍历 、删除、修改、写入，内存大。

（2） 解析步骤：下载Dom4j相应的jar文件-->在eclipse软件建立的工程文件夹处右击新建folder文件夹并命名为lib--选中下载好的dom4j-1.6.1.jar文件点击Ctrl+c--->选中eclipse建好的lib文件夹点击ctrl+v--->用添加jar文件同样的方法在src‘文件夹下添加需要解析的xml文件--->右击已添加的jar文件，点击buil path，再点击add ***，这样会将jar添加到referenced Libraries中--->然后就可以建立类进行对xml文件操作了。

（3）SAX解析：和pull解析相似，了解即可。Sax只能读取文件 ，不能删除 修改，内存小。

2.解析语法：

```
(1)//books.xml文件
<?xml version="1.0" encoding="utf-8"?>
<Books>
	<!-- 这是第一本书-->
	<book id='1001'>
		<name>java葵花宝典</name>
		<author>东方不败</author>
		<price>998</price>
	</book>
	<!-- 这是第二本书-->
	<book id="1002">
		<name>html宝典</name>
		<author>令狐冲</author>
		<price>98</price>
	</book>
</Books>

（2）//创建book类
public class Book {
	private int id;
	private String name;
	private String author;
	private double price;
	public Book() {
	}
	public Book(int id, String name, String author, double price) {
		super();
		this.id = id;
		this.name = name;
		this.author = author;
		this.price = price;
	}
	public int getId() {
		return id;
	}
	public void setId(int id) {
		this.id = id;
	}
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public String getAuthor() {
		return author;
	}
	public void setAuthor(String author) {
		this.author = author;
	}
	public double getPrice() {
		return price;
	}
	public void setPrice(double price) {
		this.price = price;
	}
	@Override
	public String toString() {
		return "Book [id=" + id + ", name=" + name + ", author=" + author + ", price=" + price + "]";
	}	
}
（3）//测试类
/*
 * 解析books.xml文件
 */
public class Demo1 {
	public static void main(String[] args) throws Exception{
		readxml();//1读取xml文件
		writeXml();//2写入xml文件
		updateXml();//3修改和删除xml文件内容
		updateXml2();//4注释
	}
	
	(3.1)//1读取xml文件
	public static void readxml() throws Exception{
		//1创建SaxReader
		SAXReader reader=new SAXReader();
		//2获取Document对象
		Document document=reader.read(new FileReader("src\\books.xml"));
		//3获取根节点
		Element root=document.getRootElement();//books
		//System.out.println(root.getName());
		//4获取book集合
		List<Element> bookList=root.elements("book");
		for (Element b : bookList) {
			//System.out.println(b.getName());
			//5获取属性
			String id=b.attributeValue("id");
			String name=b.element("name").getText();
			String author=b.element("author").getText();
			String price=b.elementText("price");
			Book book=new Book(Integer.parseInt(id), name, author, Double.parseDouble(price));
			System.out.println(book.toString());
		}
		
	}
	
	(3.2)//2写入xml文件
	public static void writeXml() throws Exception{
		//1 创建SaxReader
		SAXReader reader=new SAXReader();
		//2读取
		Document document=reader.read(new FileReader("src\\books2.xml"));
		//3获取根节点
		Element root = document.getRootElement();
		//4添加节点
		Element newbook = root.addElement("book");
		//5添加属性
		newbook.addAttribute("id","1003");
		//6newbook添加name author price
		newbook.addElement("name").setText("android开发");;
		newbook.addElement("author").setText("老张");;
		newbook.addElement("price").setText("88.8");;
		
		//7写入文件中
		OutputFormat format=OutputFormat.createPrettyPrint();//创建输出格式
		format.setEncoding("utf-8");
		XMLWriter writer=new XMLWriter(new FileWriter("src\\books.xml"), format);
		writer.write(document);
		writer.close();
		System.out.println("写入成功");	
	}
	
	(3.3)//3 修改和删除xml文件内容
	public static void updateXml() throws Exception{
		//1创建Xmlreader
		SAXReader reader=new SAXReader();
		//2文档
		Document document = reader.read(new FileReader("src\\books2.xml"));
		//3获取根节点
		Element root = document.getRootElement();
		//4获取id=1003的book
		List<Element> elements = root.elements("book");
		Element bookEle = elements.get(2);
		bookEle.element("name").setText("android从入门到大神");
		Element first =elements.get(0);
		//5删除
		root.remove(first);
		//6写入
		OutputFormat format=OutputFormat.createPrettyPrint();
		format.setEncoding("utf-8");
		XMLWriter writer=new XMLWriter(new FileWriter("src\\books2.xml"), format);
		writer.write(document);
		writer.close();
		System.out.println("修改删除完毕");
	}
	(3.4)//注释
	public static void updateXml2() throws Exception{
		//1创建Xmlreader
		SAXReader reader=new SAXReader();
		//2文档
		Document document = reader.read(new FileReader("src\\books2.xml"));
		//3获取根节点
		Element root = document.getRootElement();	
		Iterator iterator = root.nodeIterator();
		int count=0;
		while(iterator.hasNext()){
			Object obj=iterator.next();
			if(obj instanceof Comment){
				count++;
				if(count==1){
					Comment comment=(Comment) obj;
					root.remove(comment);
					break;
				}		
			}
		}
		//6写入
		OutputFormat format=OutputFormat.createPrettyPrint();
		format.setEncoding("utf-8");
		XMLWriter writer=new XMLWriter(new FileWriter("src\\books2.xml"), format);
		writer.write(document);
		writer.close();
		System.out.println("修改删除完毕");
	}
}
```



​     